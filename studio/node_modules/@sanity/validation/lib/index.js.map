{"version":3,"file":"index.js","sources":["../src/ValidationError.ts","../src/util/escapeRegex.ts","../src/util/pathToString.ts","../src/util/convertToValidationMarker.ts","../src/util/typeString.ts","../src/util/deepEquals.ts","../src/validators/genericValidator.ts","../src/validators/booleanValidator.ts","../src/validators/numberValidator.ts","../src/validators/stringValidator.ts","../src/validators/arrayValidator.ts","../src/validators/objectValidator.ts","../src/validators/dateValidator.ts","../src/Rule.ts","../src/util/requestIdleCallback.ts","../src/validators/slugValidator.ts","../src/util/normalizeValidationRules.ts","../src/validateDocument.ts","../src/inferFromSchemaType.ts","../src/inferFromSchema.ts"],"sourcesContent":["import {\n  Path,\n  ValidationMarker,\n  ValidationError as IValidationError,\n  ValidationErrorOptions,\n  ValidationErrorClass,\n} from '@sanity/types'\n\n// Follows the same pattern as Rule and RuleClass. @see Rule\nconst ValidationError: ValidationErrorClass = class ValidationError implements IValidationError {\n  message: string\n  paths: Path[]\n  children: ValidationMarker[] | undefined\n  operation: 'AND' | 'OR' | undefined\n\n  constructor(message: string, options: ValidationErrorOptions = {}) {\n    this.message = message\n    this.paths = options.paths || []\n    this.children = options.children\n    this.operation = options.operation\n  }\n\n  cloneWithMessage(msg: string): ValidationError {\n    return new ValidationError(msg, {\n      paths: this.paths,\n      children: this.children,\n      operation: this.operation,\n    })\n  }\n}\n\nexport default ValidationError\n","/* eslint-disable no-useless-escape */\nexport default (string: string): string => {\n  // Escape ^$.*+-?=!:|\\/()[]{},\n  return string.replace(/[\\^\\$\\.\\*\\+\\-\\?\\=\\!\\:\\|\\\\\\/\\(\\)\\[\\]\\{\\}\\,]/g, '\\\\$&')\n}\n","import {Path, isKeyedObject} from '@sanity/types'\n\nexport default function pathToString(path: Path | undefined = []): string {\n  return path.reduce<string>((target, segment, i) => {\n    const segmentType = typeof segment\n    if (segmentType === 'number') {\n      return `${target}[${segment}]`\n    }\n\n    if (segmentType === 'string') {\n      const separator = i === 0 ? '' : '.'\n      return `${target}${separator}${segment}`\n    }\n\n    if (isKeyedObject(segment)) {\n      return `${target}[_key==\"${segment._key}\"]`\n    }\n\n    throw new Error(`Unsupported path segment \"${segment}\"`)\n  }, '')\n}\n","import {ValidationMarker, ValidationError, ValidationContext} from '@sanity/types'\nimport ValidationErrorClass from '../ValidationError'\nimport pathToString from '../util/pathToString'\n\ntype ValidationErrorLike = Pick<ValidationError, 'message'> & Partial<ValidationError>\n\nexport function isNonNullable<T>(t: T): t is NonNullable<T> {\n  return t !== null || t !== undefined\n}\n\nexport function convertToValidationMarker(\n  validatorResult:\n    | true\n    | true[]\n    | string\n    | string[]\n    | ValidationError\n    | ValidationError[]\n    | ValidationErrorLike\n    | ValidationErrorLike[],\n  level: 'error' | 'warning' | 'info' | undefined,\n  context: ValidationContext\n): ValidationMarker[] {\n  if (!context) {\n    throw new Error('missing context')\n  }\n\n  if (validatorResult === true) return []\n\n  if (Array.isArray(validatorResult)) {\n    return validatorResult\n      .flatMap((child) => convertToValidationMarker(child, level, context))\n      .filter(isNonNullable)\n  }\n\n  if (typeof validatorResult === 'string') {\n    return convertToValidationMarker(new ValidationErrorClass(validatorResult), level, context)\n  }\n\n  if (!(validatorResult instanceof ValidationErrorClass)) {\n    // in order to accept the `ValidationErrorLike`, it at least needs to have\n    // a `message` in the object\n    if (typeof validatorResult?.message !== 'string') {\n      throw new Error(\n        `${pathToString(\n          context.path\n        )}: Validator must return 'true' if valid or an error message as a string on errors`\n      )\n    }\n\n    // this is the occurs when an object is returned that wasn't created with the\n    // `ValidationErrorClass`. in this case, we want to convert it to a class\n    return convertToValidationMarker(\n      new ValidationErrorClass(validatorResult.message, validatorResult),\n      level,\n      context\n    )\n  }\n\n  const results: ValidationMarker[] = []\n\n  // the validator result does not include any item-level relative paths,\n  // then just return the top-level path with the validation result\n  if (!validatorResult.paths?.length) {\n    return [\n      {\n        level: level || 'error',\n        item: validatorResult,\n        path: context.path || [],\n      },\n    ]\n  }\n\n  // if the validator result did include item-level relative paths, then for\n  // each item-level relative path, create a validation marker that concatenates\n  // the relative path with the path from the validation context\n  return results.concat(\n    validatorResult.paths.map((path) => ({\n      path: (context.path || []).concat(path),\n      level: level || 'error',\n      item: validatorResult,\n    }))\n  )\n}\n","// this file was adapted from a previous dependency `type-of-is`\n// https://github.com/stephenhandley/type-of-is/blob/7138a7e79f5af7c286bf8123f60843a91aaebf38/index.js\nconst _toString = {}.toString\n\nconst builtIns = [Object, Function, Array, String, Boolean, Number, Date, RegExp, Error]\n\nfunction isBuiltIn(_constructor: unknown) {\n  for (let i = 0; i < builtIns.length; i++) {\n    if (builtIns[i] === _constructor) return true\n  }\n  return false\n}\n\nexport default function typeString(obj: unknown): string {\n  // [object Blah] -> Blah\n  const stringType = _toString.call(obj).slice(8, -1)\n  if (obj === null || obj === undefined) return stringType.toLowerCase()\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  const constructorType = (obj as object).constructor\n  if (constructorType && !isBuiltIn(constructorType)) return constructorType.name\n  return stringType\n}\n","/**\n * Modified version of fast-deep-equal (https://github.com/epoberezkin/fast-deep-equal)\n * MIT-licensed, copyright (c) 2017 Evgeny Poberezkin\n **/\n\n// NOTE: when converting to typescript, some of the checks were inlined (vs\n// having them in a variable) because the type predicate type narrowing only\n// works when type predicate is called inline in the condition that starts the\n// control flow branch.\n// see here: https://www.typescriptlang.org/docs/handbook/2/narrowing.html\nexport default function deepEquals(a: unknown, b: unknown): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length != b.length) return false\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEquals(a[i], b[i])) {\n        return false\n      }\n    }\n    return true\n  }\n\n  if (Array.isArray(a) != Array.isArray(b)) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    const keys = Object.keys(a)\n    if (keys.length !== Object.keys(b).length) {\n      return false\n    }\n\n    if (a instanceof Date && b instanceof Date) {\n      return a.getTime() === b.getTime()\n    }\n\n    if (a instanceof Date != b instanceof Date) {\n      return false\n    }\n\n    if (a instanceof RegExp && b instanceof RegExp) {\n      return a.toString() == b.toString()\n    }\n\n    if (a instanceof RegExp != b instanceof RegExp) {\n      return false\n    }\n\n    for (let i = 0; i < keys.length; i++) {\n      if (keys[i] === '_key') {\n        continue\n      }\n\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) {\n        return false\n      }\n    }\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i] as keyof typeof a\n      if (key === '_key') {\n        continue\n      }\n\n      if (!deepEquals(a[key], b[key])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  return false\n}\n","import {ValidationMarker, Validators} from '@sanity/types'\nimport typeString from '../util/typeString'\nimport deepEquals from '../util/deepEquals'\nimport pathToString from '../util/pathToString'\nimport ValidationErrorClass from '../ValidationError'\n\nconst SLOW_VALIDATOR_TIMEOUT = 5000\n\nconst formatValidationErrors = (options: {\n  message: string | undefined\n  results: ValidationMarker[]\n  operation: 'AND' | 'OR'\n}) => {\n  let message\n\n  if (options.message) {\n    message = options.message\n  } else if (options.results.length === 1) {\n    message = options.results[0]?.item.message\n  } else {\n    message = `[${options.results\n      .map((err) => err.item.message)\n      .join(` - ${options.operation} - `)}]`\n  }\n\n  return new ValidationErrorClass(message, {\n    children: options.results.length > 1 ? options.results : undefined,\n    operation: options.operation,\n  })\n}\n\nconst genericValidators: Validators = {\n  type: (expected, value, message) => {\n    const actualType = typeString(value)\n    if (actualType !== expected && actualType !== 'undefined') {\n      return message || `Expected type \"${expected}\", got \"${actualType}\"`\n    }\n\n    return true\n  },\n\n  presence: (expected, value, message) => {\n    if (value === undefined && expected === 'required') {\n      return message || 'Value is required'\n    }\n\n    return true\n  },\n\n  all: async (children, value, message, context) => {\n    const resolved = await Promise.all(children.map((child) => child.validate(value, context)))\n    const results = resolved.flat()\n\n    if (!results.length) return true\n\n    return formatValidationErrors({\n      message,\n      results,\n      operation: 'AND',\n    })\n  },\n\n  either: async (children, value, message, context) => {\n    const resolved = await Promise.all(children.map((child) => child.validate(value, context)))\n    const results = resolved.flat()\n\n    // Read: There is at least one rule that matched\n    if (results.length < children.length) return true\n\n    return formatValidationErrors({\n      message,\n      results,\n      operation: 'OR',\n    })\n  },\n\n  valid: (allowedValues, actual, message) => {\n    const valueType = typeof actual\n    if (valueType === 'undefined') {\n      return true\n    }\n\n    const value = (valueType === 'number' || valueType === 'string') && `${actual}`\n    const strValue = value && value.length > 30 ? `${value.slice(0, 30)}…` : value\n\n    const defaultMessage = value\n      ? `Value \"${strValue}\" did not match any allowed values`\n      : 'Value did not match any allowed values'\n\n    return allowedValues.some((expected) => deepEquals(expected, actual))\n      ? true\n      : message || defaultMessage\n  },\n\n  custom: async (fn, value, message, context) => {\n    const slowTimer = setTimeout(() => {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `Custom validator at ${pathToString(\n          context.path\n        )} has taken more than ${SLOW_VALIDATOR_TIMEOUT}ms to respond`\n      )\n    }, SLOW_VALIDATOR_TIMEOUT)\n\n    let result\n    try {\n      result = await fn(value, context)\n    } finally {\n      clearTimeout(slowTimer)\n    }\n\n    if (typeof result === 'string') return message || result\n    return result\n  },\n}\n\nexport default genericValidators\n","import {Validators} from '@sanity/types'\nimport genericValidator from './genericValidator'\n\nconst booleanValidators: Validators = {\n  ...genericValidator,\n\n  presence: (flag, value, message) => {\n    if (flag === 'required' && typeof value !== 'boolean') {\n      return message || 'Required'\n    }\n\n    return true\n  },\n}\n\nexport default booleanValidators\n","import {Validators} from '@sanity/types'\nimport genericValidator from './genericValidator'\n\nconst precisionRx = /(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/\n\nconst numberValidators: Validators = {\n  ...genericValidator,\n\n  integer: (_unused, value, message) => {\n    if (!Number.isInteger(value)) {\n      return message || 'Must be an integer'\n    }\n\n    return true\n  },\n\n  precision: (limit, value, message) => {\n    if (value === undefined) return true\n\n    const places = value.toString().match(precisionRx)\n    const decimals = Math.max(\n      (places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0),\n      0\n    )\n\n    if (decimals > limit) {\n      return message || `Max precision is ${limit}`\n    }\n\n    return true\n  },\n\n  min: (minNum, value, message) => {\n    if (value >= minNum) {\n      return true\n    }\n\n    return message || `Must be greater than or equal ${minNum}`\n  },\n\n  max: (maxNum, value, message) => {\n    if (value <= maxNum) {\n      return true\n    }\n\n    return message || `Must be less than or equal ${maxNum}`\n  },\n\n  greaterThan: (num, value, message) => {\n    if (value > num) {\n      return true\n    }\n\n    return message || `Must be greater than ${num}`\n  },\n\n  lessThan: (maxNum, value, message) => {\n    if (value < maxNum) {\n      return true\n    }\n\n    return message || `Must be less than ${maxNum}`\n  },\n}\n\nexport default numberValidators\n","import {Validators} from '@sanity/types'\nimport genericValidator from './genericValidator'\n\nconst DUMMY_ORIGIN = 'http://sanity'\nconst emailRegex =\n  /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\nconst isRelativeUrl = (url: string) => /^\\.*\\//.test(url)\n\nconst stringValidators: Validators = {\n  ...genericValidator,\n\n  min: (minLength, value, message) => {\n    if (!value || value.length >= minLength) {\n      return true\n    }\n\n    return message || `Must be at least ${minLength} characters long`\n  },\n\n  max: (maxLength, value, message) => {\n    if (!value || value.length <= maxLength) {\n      return true\n    }\n\n    return message || `Must be at most ${maxLength} characters long`\n  },\n\n  length: (wantedLength, value, message) => {\n    const strValue = value || ''\n    if (strValue.length === wantedLength) {\n      return true\n    }\n\n    return message || `Must be exactly ${wantedLength} characters long`\n  },\n\n  uri: (constraints, value, message) => {\n    const strValue = value || ''\n    const {options} = constraints\n    const {allowCredentials, relativeOnly} = options\n    const allowRelative = options.allowRelative || relativeOnly\n\n    let url\n    try {\n      // WARNING: Safari checks for a given `base` param by looking at the length of arguments passed\n      // to new URL(str, base), and will fail if invoked with new URL(strValue, undefined)\n      url = allowRelative ? new URL(strValue, DUMMY_ORIGIN) : new URL(strValue)\n    } catch (err) {\n      return message || 'Not a valid URL'\n    }\n\n    if (relativeOnly && url.origin !== DUMMY_ORIGIN) {\n      return message || 'Only relative URLs are allowed'\n    }\n\n    if (!allowRelative && url.origin === DUMMY_ORIGIN && isRelativeUrl(strValue)) {\n      return message || 'Relative URLs are not allowed'\n    }\n\n    if (!allowCredentials && (url.username || url.password)) {\n      return message || `Username/password not allowed`\n    }\n\n    const urlScheme = url.protocol.replace(/:$/, '')\n    const matchesAllowedScheme = options.scheme.some((scheme) => scheme.test(urlScheme))\n    if (!matchesAllowedScheme) {\n      return message || 'Does not match allowed protocols/schemes'\n    }\n\n    return true\n  },\n\n  stringCasing: (casing, value, message) => {\n    const strValue = value || ''\n    if (casing === 'uppercase' && strValue !== strValue.toLocaleUpperCase()) {\n      return message || `Must be all uppercase letters`\n    }\n\n    if (casing === 'lowercase' && strValue !== strValue.toLocaleLowerCase()) {\n      return message || `Must be all lowercase letters`\n    }\n\n    return true\n  },\n\n  presence: (flag, value, message) => {\n    if (flag === 'required' && !value) {\n      return message || 'Required'\n    }\n\n    return true\n  },\n\n  regex: (options, value, message) => {\n    const {pattern, name, invert} = options\n    const regName = name || `\"${pattern.toString()}\"`\n    const strValue = value || ''\n    const matches = pattern.test(strValue)\n    if ((!invert && !matches) || (invert && matches)) {\n      const defaultMessage = invert\n        ? `Should not match ${regName}-pattern`\n        : `Does not match ${regName}-pattern`\n\n      return message || defaultMessage\n    }\n\n    return true\n  },\n\n  email: (_unused, value, message) => {\n    const strValue = `${value || ''}`.trim()\n    if (!strValue || emailRegex.test(strValue)) {\n      return true\n    }\n\n    return message || 'Must be a valid email address'\n  },\n}\n\nexport default stringValidators\n","import {Path, PathSegment, Validators} from '@sanity/types'\nimport deepEquals from '../util/deepEquals'\nimport ValidationErrorClass from '../ValidationError'\nimport genericValidator from './genericValidator'\n\nconst arrayValidators: Validators = {\n  ...genericValidator,\n\n  min: (minLength, value, message) => {\n    if (!value || value.length >= minLength) {\n      return true\n    }\n\n    return message || `Must have at least ${minLength} items`\n  },\n\n  max: (maxLength, value, message) => {\n    if (!value || value.length <= maxLength) {\n      return true\n    }\n\n    return message || `Must have at most ${maxLength} items`\n  },\n\n  length: (wantedLength, value, message) => {\n    if (!value || value.length === wantedLength) {\n      return true\n    }\n\n    return message || `Must have exactly ${wantedLength} items`\n  },\n\n  presence: (flag, value, message) => {\n    if (flag === 'required' && !value) {\n      return message || 'Required'\n    }\n\n    return true\n  },\n\n  valid: (allowedValues, values, message) => {\n    const valueType = typeof values\n    if (valueType === 'undefined') {\n      return true\n    }\n\n    const paths: Path[] = []\n    for (let i = 0; i < values.length; i++) {\n      const value = values[i]\n      if (allowedValues.some((expected) => deepEquals(expected, value))) {\n        continue\n      }\n\n      const pathSegment: PathSegment = value && value._key ? {_key: value._key} : i\n      paths.push([pathSegment])\n    }\n\n    return paths.length === 0\n      ? true\n      : new ValidationErrorClass(message || 'Value did not match any allowed values', {paths})\n  },\n\n  unique: (_unused, value, message) => {\n    const dupeIndices = []\n    if (!value) {\n      return true\n    }\n\n    for (let x = 0; x < value.length; x++) {\n      for (let y = x + 1; y < value.length; y++) {\n        const itemA = value[x]\n        const itemB = value[y]\n\n        if (!deepEquals(itemA, itemB)) {\n          continue\n        }\n\n        if (dupeIndices.indexOf(x) === -1) {\n          dupeIndices.push(x)\n        }\n\n        if (dupeIndices.indexOf(y) === -1) {\n          dupeIndices.push(y)\n        }\n      }\n    }\n\n    const paths = dupeIndices.map((idx) => {\n      const item = value[idx]\n      const pathSegment = item && item._key ? {_key: item._key} : idx\n      return [pathSegment]\n    })\n\n    return dupeIndices.length > 0\n      ? new ValidationErrorClass(message || `Can't be a duplicate`, {paths})\n      : true\n  },\n}\n\nexport default arrayValidators\n","import {Validators, isReference} from '@sanity/types'\nimport genericValidator from './genericValidator'\n\nconst metaKeys = ['_key', '_type', '_weak']\n\nconst objectValidators: Validators = {\n  ...genericValidator,\n\n  presence: (expected, value, message) => {\n    if (expected !== 'required') {\n      return true\n    }\n\n    const keys = value && Object.keys(value).filter((key) => !metaKeys.includes(key))\n\n    if (value === undefined || (keys && keys.length === 0)) {\n      return message || 'Required'\n    }\n\n    return true\n  },\n\n  reference: async (_unused, value: unknown, message, context) => {\n    if (!value) {\n      return true\n    }\n\n    if (!isReference(value)) {\n      return message || true\n    }\n\n    const {type, getDocumentExists} = context\n\n    if (!type) {\n      throw new Error(`\\`type\\` was not provided in validation context`)\n    }\n\n    if ('weak' in type && type.weak) {\n      return true\n    }\n\n    if (!getDocumentExists) {\n      throw new Error(`\\`getDocumentExists\\` was not provided in validation context`)\n    }\n\n    const exists = await getDocumentExists({id: value._ref})\n    if (!exists) {\n      return 'This reference must be published'\n    }\n\n    return true\n  },\n\n  assetRequired: (flag, value, message) => {\n    if (!value || !value.asset || !value.asset._ref) {\n      const assetType = flag.assetType || 'Asset'\n      return message || `${assetType} required`\n    }\n\n    return true\n  },\n}\n\nexport default objectValidators\n","import {Validators} from '@sanity/types'\nimport formatDate from 'date-fns/format'\nimport genericValidator from './genericValidator'\n\nexport function isRecord(obj: unknown): obj is Record<string, unknown> {\n  return typeof obj === 'object' && obj !== null && !Array.isArray(obj)\n}\n\nconst isoDate =\n  /^(?:[-+]\\d{2})?(?:\\d{4}(?!\\d{2}\\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\\1(?:[12]\\d|0[1-9]|3[01]))?|W(?:[0-4]\\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\\d|[12]\\d{2}|3(?:[0-5]\\d|6[1-6])))(?![T]$|[T][\\d]+Z$)(?:[T\\s](?:(?:(?:[01]\\d|2[0-3])(?:(:?)[0-5]\\d)?|24:?00)(?:[.,]\\d+(?!:))?)(?:\\2[0-5]\\d(?:[.,]\\d+)?)?(?:[Z]|(?:[+-])(?:[01]\\d|2[0-3])(?::?[0-5]\\d)?)?)?)?$/\n\n// eslint-disable-next-line no-warning-comments\n// TODO (eventually): move these to schema type package\ninterface DateTimeOptions {\n  dateFormat?: string\n  timeFormat?: string\n}\n\nconst getFormattedDate = (type = '', value: string | number | Date, options?: DateTimeOptions) => {\n  let format = 'yyyy-MM-dd'\n  if (options && options.dateFormat) {\n    format = options.dateFormat\n  }\n\n  if (type === 'date') {\n    // If the type is date only\n    return formatDate(new Date(value), format)\n  }\n\n  // If the type is datetime\n  if (options && options.timeFormat) {\n    format += ` ${options.timeFormat}`\n  } else {\n    format += ' HH:mm'\n  }\n\n  return formatDate(new Date(value), format)\n}\n\nfunction parseDate(date: unknown): Date | null\nfunction parseDate(date: unknown, throwOnError: true): Date\nfunction parseDate(date: unknown, throwOnError = false): Date | null {\n  if (!date) return null\n  if (date === 'now') return new Date()\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const parsed = new Date(date as any)\n  const isInvalid = isNaN(parsed.getTime())\n  if (isInvalid && throwOnError) {\n    throw new Error(`Unable to parse \"${date}\" to a date`)\n  }\n\n  return isInvalid ? null : parsed\n}\n\nconst dateValidators: Validators = {\n  ...genericValidator,\n\n  type: (_unused, value, message) => {\n    const strVal = `${value}`\n    if (!strVal || isoDate.test(value)) {\n      return true\n    }\n\n    return message || 'Must be a valid ISO-8601 formatted date string'\n  },\n\n  min: (minDate, value, message, context) => {\n    const dateVal = parseDate(value)\n    if (!dateVal) {\n      return true // `type()` should catch parse errors\n    }\n\n    if (!value || dateVal >= parseDate(minDate, true)) {\n      return true\n    }\n    if (!context.type) {\n      throw new Error(`\\`type\\` was not provided in validation context.`)\n    }\n\n    const dateTimeOptions: DateTimeOptions = isRecord(context.type.options)\n      ? (context.type.options as DateTimeOptions)\n      : {}\n\n    const date = getFormattedDate(context.type.name, minDate, dateTimeOptions)\n\n    return message || `Must be at or after ${date}`\n  },\n\n  max: (maxDate, value, message, context) => {\n    const dateVal = parseDate(value)\n    if (!dateVal) {\n      return true // `type()` should catch parse errors\n    }\n\n    if (!value || dateVal <= parseDate(maxDate, true)) {\n      return true\n    }\n\n    if (!context.type) {\n      throw new Error(`\\`type\\` was not provided in validation context.`)\n    }\n\n    const dateTimeOptions: DateTimeOptions = isRecord(context.type.options)\n      ? (context.type.options as DateTimeOptions)\n      : {}\n\n    const date = getFormattedDate(context.type.name, maxDate, dateTimeOptions)\n    return message || `Must be at or before ${date}`\n  },\n}\n\nexport default dateValidators\n","import {\n  SchemaType,\n  Rule as IRule,\n  RuleClass,\n  CustomValidator,\n  RuleSpecConstraint,\n  FieldRules,\n  ValidationContext,\n  RuleSpec,\n  ValidationMarker,\n  RuleTypeConstraint,\n  Validator,\n} from '@sanity/types'\nimport {cloneDeep, get} from 'lodash'\nimport ValidationErrorClass from './ValidationError'\nimport escapeRegex from './util/escapeRegex'\nimport {convertToValidationMarker} from './util/convertToValidationMarker'\nimport pathToString from './util/pathToString'\nimport genericValidator from './validators/genericValidator'\nimport booleanValidator from './validators/booleanValidator'\nimport numberValidator from './validators/numberValidator'\nimport stringValidator from './validators/stringValidator'\nimport arrayValidator from './validators/arrayValidator'\nimport objectValidator from './validators/objectValidator'\nimport dateValidator from './validators/dateValidator'\n\nconst typeValidators = {\n  Boolean: booleanValidator,\n  Number: numberValidator,\n  String: stringValidator,\n  Array: arrayValidator,\n  Object: objectValidator,\n  Date: dateValidator,\n}\n\nconst getBaseType = (type: SchemaType | undefined): SchemaType | undefined => {\n  return type && type.type ? getBaseType(type.type) : type\n}\n\nconst isFieldRef = (constraint: unknown): constraint is {type: symbol; path: string | string[]} => {\n  if (typeof constraint !== 'object' || !constraint) return false\n  return (constraint as Record<string, unknown>).type === Rule.FIELD_REF\n}\n\nconst EMPTY_ARRAY: unknown[] = []\nconst FIELD_REF = Symbol('FIELD_REF')\nconst ruleConstraintTypes: RuleTypeConstraint[] = [\n  'Array',\n  'Boolean',\n  'Date',\n  'Number',\n  'Object',\n  'String',\n]\n\n// Note: `RuleClass` and `Rule` are split to fit the current `@sanity/types`\n// setup. Classes are a bit weird in the `@sanity/types` package because classes\n// create an actual javascript class while simultaneously creating a type\n// definition.\n//\n// This implicitly creates two types:\n// 1. the instance type — `Rule` and\n// 2. the static/class type - `RuleClass`\n//\n// The `RuleClass` type contains the static methods and the `Rule` instance\n// contains the instance methods.\n//\n// This package exports the RuleClass as a value without implicitly exporting\n// an instance definition. This should help reminder downstream users to import\n// from the `@sanity/types` package.\nconst Rule: RuleClass = class Rule implements IRule {\n  static readonly FIELD_REF = FIELD_REF\n  static array = (def?: SchemaType): Rule => new Rule(def).type('Array')\n  static object = (def?: SchemaType): Rule => new Rule(def).type('Object')\n  static string = (def?: SchemaType): Rule => new Rule(def).type('String')\n  static number = (def?: SchemaType): Rule => new Rule(def).type('Number')\n  static boolean = (def?: SchemaType): Rule => new Rule(def).type('Boolean')\n  static dateTime = (def?: SchemaType): Rule => new Rule(def).type('Date')\n  static valueOfField = (path: string | string[]): {type: symbol; path: string | string[]} => ({\n    type: FIELD_REF,\n    path,\n  })\n\n  _type: RuleTypeConstraint | undefined = undefined\n  _level: 'error' | 'warning' | 'info' | undefined = undefined\n  _required: 'required' | 'optional' | undefined = undefined\n  _typeDef: SchemaType | undefined = undefined\n  _message: string | undefined = undefined\n  _rules: RuleSpec[] = []\n  _fieldRules: FieldRules | undefined = undefined\n\n  constructor(typeDef?: SchemaType) {\n    this._typeDef = typeDef\n    this.reset()\n  }\n\n  private _mergeRequired(next: Rule) {\n    if (this._required === 'required' || next._required === 'required') return 'required'\n    if (this._required === 'optional' || next._required === 'optional') return 'optional'\n    return undefined\n  }\n\n  // Alias to static method, since we often have access to an _instance_ of a rule but not the actual Rule class\n  valueOfField = Rule.valueOfField.bind(Rule)\n\n  error(message?: string): Rule {\n    const rule = this.clone()\n    rule._level = 'error'\n    rule._message = message || undefined\n    return rule\n  }\n\n  warning(message?: string): Rule {\n    const rule = this.clone()\n    rule._level = 'warning'\n    rule._message = message || undefined\n    return rule\n  }\n\n  info(message?: string): Rule {\n    const rule = this.clone()\n    rule._level = 'info'\n    rule._message = message || undefined\n    return rule\n  }\n\n  reset(): this {\n    this._type = this._type || undefined\n    this._rules = (this._rules || []).filter((rule) => rule.flag === 'type')\n    this._message = undefined\n    this._required = undefined\n    this._level = 'error'\n    this._fieldRules = undefined\n    return this\n  }\n\n  isRequired(): boolean {\n    return this._required === 'required'\n  }\n\n  clone(): Rule {\n    const rule = new Rule()\n    rule._type = this._type\n    rule._message = this._message\n    rule._required = this._required\n    rule._rules = cloneDeep(this._rules)\n    rule._level = this._level\n    rule._fieldRules = this._fieldRules\n    rule._typeDef = this._typeDef\n    return rule\n  }\n\n  cloneWithRules(rules: RuleSpec[]): Rule {\n    const rule = this.clone()\n    const newRules = new Set()\n    rules.forEach((curr) => {\n      if (curr.flag === 'type') {\n        rule._type = curr.constraint\n      }\n\n      newRules.add(curr.flag)\n    })\n\n    rule._rules = rule._rules\n      .filter((curr) => {\n        const disallowDuplicate = ['type', 'uri', 'email'].includes(curr.flag)\n        const isDuplicate = newRules.has(curr.flag)\n        return !(disallowDuplicate && isDuplicate)\n      })\n      .concat(rules)\n\n    return rule\n  }\n\n  merge(rule: Rule): Rule {\n    if (this._type && rule._type && this._type !== rule._type) {\n      throw new Error('merge() failed: conflicting types')\n    }\n\n    const newRule = this.cloneWithRules(rule._rules)\n    newRule._type = this._type || rule._type\n    newRule._message = this._message || rule._message\n    newRule._required = this._mergeRequired(rule)\n    newRule._level = this._level === 'error' ? rule._level : this._level\n    return newRule\n  }\n\n  // Validation flag setters\n  type(targetType: RuleTypeConstraint | Lowercase<RuleTypeConstraint>): Rule {\n    const type = `${targetType.slice(0, 1).toUpperCase()}${targetType.slice(1)}` as Capitalize<\n      typeof targetType\n    >\n\n    if (!ruleConstraintTypes.includes(type)) {\n      throw new Error(`Unknown type \"${targetType}\"`)\n    }\n\n    const rule = this.cloneWithRules([{flag: 'type', constraint: type}])\n    rule._type = type\n    return rule\n  }\n\n  all(children: Rule[]): Rule {\n    return this.cloneWithRules([{flag: 'all', constraint: children}])\n  }\n\n  either(children: Rule[]): Rule {\n    return this.cloneWithRules([{flag: 'either', constraint: children}])\n  }\n\n  // Shared rules\n  optional(): Rule {\n    const rule = this.cloneWithRules([{flag: 'presence', constraint: 'optional'}])\n    rule._required = 'optional'\n    return rule\n  }\n\n  required(): Rule {\n    const rule = this.cloneWithRules([{flag: 'presence', constraint: 'required'}])\n    rule._required = 'required'\n    return rule\n  }\n\n  custom<T = unknown>(fn: CustomValidator<T>): Rule {\n    return this.cloneWithRules([{flag: 'custom', constraint: fn as CustomValidator}])\n  }\n\n  min(len: number): Rule {\n    return this.cloneWithRules([{flag: 'min', constraint: len}])\n  }\n\n  max(len: number): Rule {\n    return this.cloneWithRules([{flag: 'max', constraint: len}])\n  }\n\n  length(len: number): Rule {\n    return this.cloneWithRules([{flag: 'length', constraint: len}])\n  }\n\n  valid(value: unknown | unknown[]): Rule {\n    const values = Array.isArray(value) ? value : [value]\n    return this.cloneWithRules([{flag: 'valid', constraint: values}])\n  }\n\n  // Numbers only\n  integer(): Rule {\n    return this.cloneWithRules([{flag: 'integer'}])\n  }\n\n  precision(limit: number): Rule {\n    return this.cloneWithRules([{flag: 'precision', constraint: limit}])\n  }\n\n  positive(): Rule {\n    return this.cloneWithRules([{flag: 'min', constraint: 0}])\n  }\n\n  negative(): Rule {\n    return this.cloneWithRules([{flag: 'lessThan', constraint: 0}])\n  }\n\n  greaterThan(num: number): Rule {\n    return this.cloneWithRules([{flag: 'greaterThan', constraint: num}])\n  }\n\n  lessThan(num: number): Rule {\n    return this.cloneWithRules([{flag: 'lessThan', constraint: num}])\n  }\n\n  // String only\n  uppercase(): Rule {\n    return this.cloneWithRules([{flag: 'stringCasing', constraint: 'uppercase'}])\n  }\n\n  lowercase(): Rule {\n    return this.cloneWithRules([{flag: 'stringCasing', constraint: 'lowercase'}])\n  }\n\n  regex(pattern: RegExp, name: string, options: {name?: string; invert?: boolean}): Rule\n  regex(pattern: RegExp, options: {name?: string; invert?: boolean}): Rule\n  regex(pattern: RegExp, name: string): Rule\n  regex(pattern: RegExp): Rule\n  regex(\n    pattern: RegExp,\n    a?: string | {name?: string; invert?: boolean},\n    b?: {name?: string; invert?: boolean}\n  ): Rule {\n    const name = typeof a === 'string' ? a : a?.name ?? b?.name\n    const invert = typeof a === 'string' ? false : a?.invert ?? b?.invert\n\n    const constraint: RuleSpecConstraint<'regex'> = {\n      pattern,\n      name,\n      invert: invert || false,\n    }\n\n    return this.cloneWithRules([{flag: 'regex', constraint}])\n  }\n\n  email(): Rule {\n    return this.cloneWithRules([{flag: 'email'}])\n  }\n\n  uri(opts?: {\n    scheme?: (string | RegExp) | Array<string | RegExp>\n    allowRelative?: boolean\n    relativeOnly?: boolean\n    allowCredentials?: boolean\n  }): Rule {\n    const optsScheme = opts?.scheme || ['http', 'https']\n    const schemes = Array.isArray(optsScheme) ? optsScheme : [optsScheme]\n\n    if (!schemes.length) {\n      throw new Error('scheme must have at least 1 scheme specified')\n    }\n\n    const constraint: RuleSpecConstraint<'uri'> = {\n      options: {\n        scheme: schemes.map((scheme) => {\n          if (!(scheme instanceof RegExp) && typeof scheme !== 'string') {\n            throw new Error('scheme must be a RegExp or a String')\n          }\n\n          return typeof scheme === 'string' ? new RegExp(`^${escapeRegex(scheme)}$`) : scheme\n        }),\n        allowRelative: opts?.allowRelative || false,\n        relativeOnly: opts?.relativeOnly || false,\n        allowCredentials: opts?.allowCredentials || false,\n      },\n    }\n\n    return this.cloneWithRules([{flag: 'uri', constraint}])\n  }\n\n  // Array only\n  unique(): Rule {\n    return this.cloneWithRules([{flag: 'unique'}])\n  }\n\n  // Objects only\n  reference(): Rule {\n    return this.cloneWithRules([{flag: 'reference'}])\n  }\n\n  fields(rules: FieldRules): Rule {\n    if (this._type !== 'Object') {\n      throw new Error('fields() can only be called on an object type')\n    }\n\n    const rule = this.cloneWithRules([])\n    rule._fieldRules = rules\n    return rule\n  }\n\n  assetRequired(): Rule {\n    const base = getBaseType(this._typeDef)\n    let assetType: 'Asset' | 'Image' | 'File'\n    if (base && ['image', 'file'].includes(base.name)) {\n      assetType = base.name === 'image' ? 'Image' : 'File'\n    } else {\n      assetType = 'Asset'\n    }\n\n    return this.cloneWithRules([{flag: 'assetRequired', constraint: {assetType}}])\n  }\n\n  async validate(value: unknown, context: ValidationContext): Promise<ValidationMarker[]> {\n    if (!context) {\n      throw new Error('missing context')\n    }\n\n    const valueIsEmpty = value === null || value === undefined\n\n    // Short-circuit on optional, empty fields\n    if (valueIsEmpty && this._required === 'optional') {\n      return EMPTY_ARRAY as ValidationMarker[]\n    }\n\n    const rules =\n      // Run only the _custom_ functions if the rule is not set to required or optional\n      this._required === undefined && valueIsEmpty\n        ? this._rules.filter((curr) => curr.flag === 'custom')\n        : this._rules\n\n    const validators = (this._type && typeValidators[this._type]) || genericValidator\n\n    const results = await Promise.all(\n      rules.map(async (curr) => {\n        if (curr.flag === undefined) {\n          throw new Error('Invalid rule, did not contain \"flag\"-property')\n        }\n\n        const validator: Validator | undefined = validators[curr.flag]\n        if (!validator) {\n          const forType = this._type ? `type \"${this._type}\"` : 'rule without declared type'\n          throw new Error(`Validator for flag \"${curr.flag}\" not found for ${forType}`)\n        }\n\n        let specConstraint = 'constraint' in curr ? curr.constraint : null\n        if (isFieldRef(specConstraint)) {\n          specConstraint = get(context.parent, specConstraint.path)\n        }\n\n        let result\n        try {\n          result = await validator(specConstraint, value, this._message, context)\n        } catch (err) {\n          const errorFromException = new ValidationErrorClass(\n            `${pathToString(context.path)}: Exception occurred while validating value: ${\n              err.message\n            }`\n          )\n          return convertToValidationMarker(errorFromException, 'error', context)\n        }\n\n        return convertToValidationMarker(result, this._level, context)\n      })\n    )\n\n    return results.flat()\n  }\n}\n\nexport default Rule\n","/**\n * Simple requestIdleCallback polyfill\n * Can be removed when all browsers support requestIdleCallback: https://caniuse.com/requestidlecallback\n * @param callback\n * @param options\n */\nconst requestIdleCallbackShim: typeof window.requestIdleCallback = function requestIdleCallbackShim(\n  callback,\n  options?\n): number {\n  const start = Date.now()\n  return window.setTimeout(() => {\n    callback({\n      didTimeout: false,\n      timeRemaining() {\n        return Math.max(0, Date.now() - start)\n      },\n    })\n  }, 0)\n}\n\nconst cancelIdleCallbackShim: typeof window.cancelIdleCallback = function cancelIdleCallbackShim(\n  handle: number\n): void {\n  return window.clearTimeout(handle)\n}\n\nconst win = typeof window === 'undefined' ? undefined : window\n\nexport const requestIdleCallback = win?.requestIdleCallback || requestIdleCallbackShim\nexport const cancelIdleCallback = win?.cancelIdleCallback || cancelIdleCallbackShim\n","import {\n  SlugIsUniqueValidator,\n  Path,\n  CustomValidator,\n  isKeyedObject,\n  SlugValidationContext,\n  SlugParent,\n  SlugSchemaType,\n} from '@sanity/types'\nimport {memoize} from 'lodash'\n// import getClient from '../getClient'\n\nconst memoizedWarnOnArraySlug = memoize(warnOnArraySlug)\n\nfunction getDocumentIds(id: string) {\n  const isDraft = id.indexOf('drafts.') === 0\n  return {\n    published: isDraft ? id.slice('drafts.'.length) : id,\n    draft: isDraft ? id : `drafts.${id}`,\n  }\n}\n\nfunction serializePath(path: Path): string {\n  return path.reduce<string>((target, part, i) => {\n    const isIndex = typeof part === 'number'\n    const isKey = isKeyedObject(part)\n    const separator = i === 0 ? '' : '.'\n    const add = isIndex || isKey ? '[]' : `${separator}${part}`\n    return `${target}${add}`\n  }, '')\n}\n\nconst defaultIsUnique: SlugIsUniqueValidator = (slug, context) => {\n  const {getClient, document, path, type} = context\n  const schemaOptions = type?.options as {disableArrayWarning?: boolean} | undefined\n\n  if (!document) {\n    throw new Error(`\\`document\\` was not provided in validation context.`)\n  }\n  if (!path) {\n    throw new Error(`\\`path\\` was not provided in validation context.`)\n  }\n\n  const disableArrayWarning = schemaOptions?.disableArrayWarning || false\n  const {published, draft} = getDocumentIds(document._id)\n  const docType = document._type\n  const atPath = serializePath(path.concat('current'))\n\n  if (!disableArrayWarning && atPath.includes('[]')) {\n    memoizedWarnOnArraySlug(serializePath(path))\n  }\n\n  const constraints = [\n    '_type == $docType',\n    `!(_id in [$draft, $published])`,\n    `${atPath} == $slug`,\n  ].join(' && ')\n\n  return getClient({apiVersion: '2022-09-09'}).fetch<boolean>(\n    `!defined(*[${constraints}][0]._id)`,\n    {\n      docType,\n      draft,\n      published,\n      slug,\n    },\n    {tag: 'validation.slug-is-unique'}\n  )\n}\n\nfunction warnOnArraySlug(serializedPath: string) {\n  /* eslint-disable no-console */\n  console.warn(\n    [\n      `Slug field at path ${serializedPath} is within an array and cannot be automatically checked for uniqueness`,\n      `If you need to check for uniqueness, provide your own \"isUnique\" method`,\n      `To disable this message, set \\`disableArrayWarning: true\\` on the slug \\`options\\` field`,\n    ].join('\\n')\n  )\n  /* eslint-enable no-console */\n}\n\n/**\n * Validates slugs values by querying for uniqueness from the client.\n *\n * This is a custom rule implementation (e.g. `Rule.custom(slugValidator)`)\n * that's populated in `inferFromSchemaType` when the type name is `slug`\n */\nexport const slugValidator: CustomValidator = async (value, context) => {\n  if (!value) {\n    return true\n  }\n  if (typeof value !== 'object') {\n    return 'Slug must be an object'\n  }\n\n  const slugValue = (value as {current?: string}).current\n  if (!slugValue) {\n    return 'Slug must have a value'\n  }\n\n  const options = context?.type?.options as {isUnique?: SlugIsUniqueValidator} | undefined\n  const isUnique = options?.isUnique || defaultIsUnique\n\n  const slugContext: SlugValidationContext = {\n    ...context,\n    parent: context.parent as SlugParent,\n    type: context.type as SlugSchemaType,\n    defaultIsUnique,\n  }\n  const wasUnique = await isUnique(slugValue, slugContext)\n  if (wasUnique) {\n    return true\n  }\n\n  return 'Slug is already in use'\n}\n","import {SchemaType, Rule, RuleTypeConstraint} from '@sanity/types'\nimport RuleClass from '../Rule'\nimport {slugValidator} from '../validators/slugValidator'\n\nconst ruleConstraintTypes: {[P in Lowercase<RuleTypeConstraint>]: true} = {\n  array: true,\n  boolean: true,\n  date: true,\n  number: true,\n  object: true,\n  string: true,\n}\n\nconst isRuleConstraint = (typeString: string): typeString is Lowercase<RuleTypeConstraint> =>\n  typeString in ruleConstraintTypes\n\nfunction getTypeChain(type: SchemaType | undefined, visited: Set<SchemaType>): SchemaType[] {\n  if (!type) return []\n  if (visited.has(type)) return []\n\n  visited.add(type)\n\n  const next = type.type ? getTypeChain(type.type, visited) : []\n  return [...next, type]\n}\n\nfunction baseRuleReducer(inputRule: Rule, type: SchemaType) {\n  let baseRule = inputRule\n\n  if (isRuleConstraint(type.jsonType)) {\n    baseRule = baseRule.type(type.jsonType)\n  }\n\n  const typeOptionsList =\n    // if type.options is truthy\n    type?.options &&\n    // and type.options is an object (non-null from the previous)\n    typeof type.options === 'object' &&\n    // and if `list` is in options\n    'list' in type.options &&\n    // then finally access the list\n    type.options.list\n\n  if (Array.isArray(typeOptionsList)) {\n    baseRule = baseRule.valid(\n      typeOptionsList.map((option) => extractValueFromListOption(option, type))\n    )\n  }\n\n  if (type.name === 'datetime') return baseRule.type('Date')\n  if (type.name === 'date') return baseRule.type('Date')\n  if (type.name === 'url') return baseRule.uri()\n  if (type.name === 'slug') return baseRule.custom(slugValidator)\n  if (type.name === 'reference') return baseRule.reference()\n  if (type.name === 'email') return baseRule.email()\n  return baseRule\n}\n\nfunction hasValueField(typeDef: SchemaType | undefined): boolean {\n  if (!typeDef) return false\n  if (!('fields' in typeDef) && typeDef.type) return hasValueField(typeDef.type)\n  if (!('fields' in typeDef)) return false\n  if (!Array.isArray(typeDef.fields)) return false\n  return typeDef.fields.some((field) => field.name === 'value')\n}\n\nfunction extractValueFromListOption(option: unknown, typeDef: SchemaType): unknown {\n  // If you define a `list` option with object items, where the item has a `value` field,\n  // we don't want to treat that as the value but rather the surrounding object\n  // This differs from the case where you have a title/value pair setup for a string/number, for instance\n  if (typeDef.jsonType === 'object' && hasValueField(typeDef)) return option\n\n  return (option as Record<string, unknown>).value === undefined\n    ? option\n    : (option as Record<string, unknown>).value\n}\n\n/**\n * Takes in `SchemaValidationValue` and returns an array of `Rule` instances.\n */\nexport default function normalizeValidationRules(typeDef: SchemaType | undefined): Rule[] {\n  if (!typeDef) {\n    return []\n  }\n\n  const validation = typeDef.validation\n\n  if (Array.isArray(validation)) {\n    return validation.flatMap((i) =>\n      normalizeValidationRules({\n        ...typeDef,\n        validation: i,\n      })\n    )\n  }\n\n  if (validation instanceof RuleClass) {\n    return [validation]\n  }\n\n  const baseRule =\n    // using an object + Object.values to de-dupe the type chain by type name\n    Object.values(\n      getTypeChain(typeDef, new Set()).reduce<Record<string, SchemaType>>((acc, type) => {\n        acc[type.name] = type\n        return acc\n      }, {})\n    ).reduce(baseRuleReducer, new RuleClass(typeDef))\n\n  if (!validation) {\n    return [baseRule]\n  }\n\n  return normalizeValidationRules({\n    ...typeDef,\n    validation: validation(baseRule),\n  })\n}\n","import {\n  SanityDocument,\n  Schema,\n  SchemaType,\n  ValidationContext,\n  ValidationMarker,\n  isKeyedObject,\n  isTypedObject,\n  isBlockSchemaType,\n  isSpanSchemaType,\n  isPortableTextTextBlock,\n} from '@sanity/types'\nimport {concat, defer, firstValueFrom, lastValueFrom, merge, Observable, of} from 'rxjs'\nimport {catchError, map, mergeAll, mergeMap, toArray} from 'rxjs/operators'\nimport {flatten, uniqBy} from 'lodash'\nimport type {SanityClient} from '@sanity/client'\nimport typeString from './util/typeString'\nimport {cancelIdleCallback, requestIdleCallback} from './util/requestIdleCallback'\nimport ValidationErrorClass from './ValidationError'\nimport normalizeValidationRules from './util/normalizeValidationRules'\n\nconst isRecord = (maybeRecord: unknown): maybeRecord is Record<string, unknown> =>\n  typeof maybeRecord === 'object' && maybeRecord !== null && !Array.isArray(maybeRecord)\n\nconst isNonNullable = <T>(value: T): value is NonNullable<T> =>\n  value !== null && value !== undefined\n\n/**\n * @internal\n */\nexport function resolveTypeForArrayItem(\n  item: unknown,\n  candidates: SchemaType[]\n): SchemaType | undefined {\n  // if there is only one type available, assume that it's the correct one\n  if (candidates.length === 1) return candidates[0]\n\n  const itemType = isTypedObject(item) && item._type\n  const primitive =\n    item === undefined || item === null || (!itemType && typeString(item).toLowerCase())\n\n  if (primitive && primitive !== 'object') {\n    return candidates.find((candidate) => candidate.jsonType === primitive)\n  }\n\n  return (\n    candidates.find((candidate) => candidate.type?.name === itemType) ||\n    candidates.find((candidate) => candidate.name === itemType) ||\n    candidates.find((candidate) => candidate.name === 'object' && primitive === 'object')\n  )\n}\nconst EMPTY_MARKERS: ValidationMarker[] = []\n\nexport default async function validateDocument(\n  getClient: (options: {apiVersion: string}) => SanityClient,\n  doc: SanityDocument,\n  schema: Schema,\n  context?: Pick<ValidationContext, 'getDocumentExists'>\n): Promise<ValidationMarker[]> {\n  return lastValueFrom(validateDocumentObservable(getClient, doc, schema, context))\n}\n\nexport function validateDocumentObservable(\n  getClient: (options: {apiVersion: string}) => SanityClient,\n  doc: SanityDocument,\n  schema: Schema,\n  context?: Pick<ValidationContext, 'getDocumentExists'>\n): Observable<ValidationMarker[]> {\n  const documentType = schema.get(doc._type)\n  if (!documentType) {\n    console.warn('Schema type for object type \"%s\" not found, skipping validation', doc._type)\n    return of(EMPTY_MARKERS)\n  }\n\n  const client = getClient({apiVersion: '2021-06-07'})\n  const validationOptions: ValidateItemOptions = {\n    client,\n    getClient,\n    schema,\n    parent: undefined,\n    value: doc,\n    path: [],\n    document: doc,\n    type: documentType,\n    getDocumentExists: context?.getDocumentExists,\n  }\n\n  // <TEMPORARY UGLY HACK TO PRINT DEPRECATION WARNINGS ON USE>\n  /* eslint-disable no-proto */\n  const wrappedClient = client as any\n  validationOptions.client = [\n    ...Object.keys(client),\n    ...Object.keys(wrappedClient.__proto__),\n  ].reduce((acc, key) => {\n    const original = Object.hasOwnProperty.call(client, key)\n      ? wrappedClient[key]\n      : wrappedClient.__proto__[key]\n\n    return Object.defineProperty(acc, key, {\n      get() {\n        console.warn(\n          '`configContext.client` is deprecated and will be removed in the next release! Use `context.getClient({apiVersion: \"2021-06-07\"})` instead'\n        )\n        return original\n      },\n    })\n  }, {}) as any as SanityClient\n  /* eslint-enable no-proto */\n  // </TEMPORARY UGLY HACK TO PRINT DEPRECATION WARNINGS ON USE>\n\n  return validateItemObservable(validationOptions).pipe(\n    catchError((err) => {\n      console.error(err)\n      return of([\n        {\n          type: 'validation' as const,\n          level: 'error' as const,\n          path: [],\n          item: new ValidationErrorClass(err?.message),\n        },\n      ])\n    })\n  )\n}\n\n/**\n * this is used make optional properties required by replacing optionals with\n * `T[P] | undefined`. this is used to prevent errors in `validateItem` where\n * an option from a previous invocation would be incorrectly passed down.\n *\n * https://medium.com/terria/typescript-transforming-optional-properties-to-required-properties-that-may-be-undefined-7482cb4e1585\n */\ntype ExplicitUndefined<T> = {\n  [P in keyof Required<T>]: Pick<T, P> extends Required<Pick<T, P>> ? T[P] : T[P] | undefined\n}\n\ntype ValidateItemOptions = {\n  value: unknown\n} & ExplicitUndefined<ValidationContext>\n\nexport function validateItem(opts: ValidateItemOptions): Promise<ValidationMarker[]> {\n  return lastValueFrom(validateItemObservable(opts))\n}\n\nfunction validateItemObservable({\n  value,\n  type,\n  path = [],\n  parent,\n  ...restOfContext\n}: ValidateItemOptions): Observable<ValidationMarker[]> {\n  const rules = normalizeValidationRules(type)\n  // run validation for the current value\n  const selfChecks = rules.map((rule) =>\n    defer(() =>\n      rule.validate(value, {\n        ...restOfContext,\n        parent,\n        path,\n        type,\n      })\n    )\n  )\n\n  // run validation for nested values (conditionally)\n  let nestedChecks: Array<Observable<ValidationMarker[]>> = []\n\n  const selfIsRequired = rules.some((rule) => rule.isRequired())\n  const shouldRunNestedObjectValidation =\n    // run nested validation for objects\n    type?.jsonType === 'object' &&\n    // if the value is truthy\n    (!!value || // or\n      // (the value is null or undefined) and the top-level value is required\n      ((value === null || value === undefined) && selfIsRequired))\n\n  if (shouldRunNestedObjectValidation) {\n    const fieldTypes = type.fields.reduce<Record<string, SchemaType>>((acc, field) => {\n      acc[field.name] = field.type\n      return acc\n    }, {})\n\n    // Validation for rules set at the object level with `Rule.fields({/* ... */})`\n    nestedChecks = nestedChecks.concat(\n      rules\n        .map((rule) => rule._fieldRules)\n        .filter(isNonNullable)\n        .flatMap((fieldResults) => Object.entries(fieldResults))\n        .flatMap(([name, validation]) => {\n          const fieldType = fieldTypes[name]\n          return normalizeValidationRules({...fieldType, validation}).map((subRule) => {\n            const nestedValue = isRecord(value) ? value[name] : undefined\n            return defer(() =>\n              subRule.validate(nestedValue, {\n                ...restOfContext,\n                parent: value,\n                path: path.concat(name),\n                type: fieldType,\n              })\n            )\n          })\n        })\n    )\n\n    // Validation from each field's schema `validation: Rule => {/* ... */}` function\n    nestedChecks = nestedChecks.concat(\n      type.fields.map((field) =>\n        validateItemObservable({\n          ...restOfContext,\n          parent: value,\n          value: isRecord(value) ? value[field.name] : undefined,\n          path: path.concat(field.name),\n          type: field.type,\n        })\n      )\n    )\n  }\n\n  // note: unlike objects, arrays should not run nested validation for undefined\n  // values because we won't have a valid path to put a marker (i.e. missing the\n  // key or index in the path) and the downstream form builder won't have a\n  // valid target component\n  const shouldRunNestedValidationForArrays = type?.jsonType === 'array' && Array.isArray(value)\n\n  if (shouldRunNestedValidationForArrays) {\n    nestedChecks = nestedChecks.concat(\n      value.map((item, index) =>\n        validateItemObservable({\n          ...restOfContext,\n          parent: value,\n          value: item,\n          path: path.concat(isKeyedObject(item) ? {_key: item._key} : index),\n          type: resolveTypeForArrayItem(item, type.of),\n        })\n      )\n    )\n  }\n\n  // markDefs also do no run nested validation if the parent object is undefined\n  // for a similar reason to arrays\n  const shouldRunNestedValidationForMarkDefs =\n    isPortableTextTextBlock(value) && value.markDefs?.length && isBlockSchemaType(type)\n\n  if (shouldRunNestedValidationForMarkDefs) {\n    const [spanChildrenField] = type.fields\n    const spanType = spanChildrenField.type.of.find(isSpanSchemaType)\n\n    const annotations = (spanType?.annotations || []).reduce<Map<string, SchemaType>>(\n      (acc, annotationType) => {\n        acc.set(annotationType.name, annotationType)\n        return acc\n      },\n      new Map()\n    )\n\n    nestedChecks = nestedChecks.concat(\n      (value.markDefs || []).map((markDef) =>\n        validateItemObservable({\n          ...restOfContext,\n          parent: value,\n          value: markDef,\n          path: path.concat(['markDefs', {_key: markDef._key}]),\n          type: annotations.get(markDef._type),\n        })\n      )\n    )\n  }\n\n  return defer(() => merge([...selfChecks, ...nestedChecks])).pipe(\n    mergeMap((validateNode) => concat(idle(), validateNode), 40),\n    mergeAll(),\n    toArray(),\n    map(flatten),\n    map((results) => {\n      // run `uniqBy` if `_fieldRules` are present because they can\n      // cause repeat markers\n      if (rules.some((rule) => rule._fieldRules)) {\n        return uniqBy(results, (rule) => JSON.stringify(rule))\n      }\n      return results\n    })\n  )\n}\n\nfunction idle(timeout?: number): Observable<never> {\n  return new Observable<never>((observer) => {\n    const handle = requestIdleCallback(\n      () => {\n        observer.complete()\n      },\n      timeout ? {timeout} : undefined\n    )\n\n    return () => cancelIdleCallback(handle)\n  })\n}\n","import {Schema, SchemaType} from '@sanity/types'\nimport normalizeValidationRules from './util/normalizeValidationRules'\n\nfunction traverse(typeDef: SchemaType, visited: Set<SchemaType>) {\n  if (visited.has(typeDef)) {\n    return\n  }\n\n  visited.add(typeDef)\n\n  typeDef.validation = normalizeValidationRules(typeDef)\n\n  if ('fields' in typeDef) {\n    for (const field of typeDef.fields) {\n      traverse(field.type, visited)\n    }\n  }\n\n  if ('of' in typeDef) {\n    for (const candidate of typeDef.of) {\n      traverse(candidate, visited)\n    }\n  }\n\n  // eslint-disable-next-line no-warning-comments\n  // @ts-expect-error TODO (eventually): `annotations` does not exist on the SchemaType yet\n  if (typeDef.annotations) {\n    // eslint-disable-next-line no-warning-comments\n    // @ts-expect-error TODO (eventually): `annotations` does not exist on the SchemaType yet\n    for (const annotation of typeDef.annotations) {\n      traverse(annotation, visited)\n    }\n  }\n}\n\n// NOTE: this overload is for TS API compatibility with a previous implementation\nfunction inferFromSchemaType(\n  typeDef: SchemaType,\n  // these are intentionally unused\n  _schema: Schema,\n  _visited?: Set<SchemaType>\n): SchemaType\n// note: this seemingly redundant overload is required\nfunction inferFromSchemaType(typeDef: SchemaType): SchemaType\nfunction inferFromSchemaType(typeDef: SchemaType): SchemaType {\n  traverse(typeDef, new Set())\n  return typeDef\n}\n\nexport default inferFromSchemaType\n","import {Schema} from '@sanity/types'\nimport inferFromSchemaType from './inferFromSchemaType'\n\n// Note: Mutates schema. Refactor when @sanity/schema supports middlewares\nfunction inferFromSchema(schema: Schema): Schema {\n  const typeNames = schema.getTypeNames()\n\n  typeNames.forEach((typeName) => {\n    const schemaType = schema.get(typeName)\n\n    if (schemaType) {\n      inferFromSchemaType(schemaType)\n    }\n  })\n\n  return schema\n}\n\nexport default inferFromSchema\n"],"names":["ValidationError","constructor","message","options","paths","children","operation","cloneWithMessage","msg","escapeRegex","string","replace","pathToString","path","reduce","target","segment","i","segmentType","separator","isKeyedObject","_key","Error","isNonNullable","t","convertToValidationMarker","validatorResult","level","context","_a","Array","isArray","flatMap","child","filter","ValidationErrorClass","results","length","item","concat","map","_toString","toString","builtIns","Object","Function","String","Boolean","Number","Date","RegExp","isBuiltIn","_constructor","typeString","obj","stringType","call","slice","toLowerCase","constructorType","name","deepEquals","a","b","keys","getTime","prototype","hasOwnProperty","key","SLOW_VALIDATOR_TIMEOUT","formatValidationErrors","err","join","genericValidators","type","expected","value","actualType","presence","all","resolved","Promise","validate","flat","either","valid","allowedValues","actual","valueType","strValue","defaultMessage","some","custom","fn","slowTimer","setTimeout","console","warn","result","clearTimeout","booleanValidators","genericValidator","flag","precisionRx","numberValidators","integer","_unused","isInteger","precision","limit","places","match","decimals","Math","max","parseInt","min","minNum","maxNum","greaterThan","num","lessThan","DUMMY_ORIGIN","emailRegex","isRelativeUrl","url","test","stringValidators","minLength","maxLength","wantedLength","uri","constraints","allowCredentials","relativeOnly","allowRelative","URL","origin","username","password","urlScheme","protocol","matchesAllowedScheme","scheme","stringCasing","casing","toLocaleUpperCase","toLocaleLowerCase","regex","pattern","invert","regName","matches","email","trim","arrayValidators","values","pathSegment","push","unique","dupeIndices","x","y","itemA","itemB","indexOf","idx","metaKeys","objectValidators","includes","reference","isReference","getDocumentExists","weak","exists","id","_ref","assetRequired","asset","assetType","isRecord","isoDate","getFormattedDate","format","dateFormat","formatDate","default","timeFormat","parseDate","date","throwOnError","parsed","isInvalid","isNaN","dateValidators","strVal","minDate","dateVal","dateTimeOptions","maxDate","typeValidators","booleanValidator","numberValidator","stringValidator","arrayValidator","objectValidator","dateValidator","getBaseType","isFieldRef","constraint","Rule","FIELD_REF","EMPTY_ARRAY","Symbol","ruleConstraintTypes","typeDef","_type","_level","_required","_typeDef","_message","_rules","_fieldRules","valueOfField","bind","reset","_mergeRequired","next","error","rule","clone","warning","info","isRequired","cloneDeep","cloneWithRules","rules","newRules","Set","forEach","curr","add","disallowDuplicate","isDuplicate","has","merge","newRule","targetType","toUpperCase","optional","required","len","positive","negative","uppercase","lowercase","_b","opts","optsScheme","schemes","fields","base","valueIsEmpty","validators","validator","forType","specConstraint","get","parent","errorFromException","array","def","object","number","boolean","dateTime","requestIdleCallbackShim","callback","start","now","window","didTimeout","timeRemaining","cancelIdleCallbackShim","handle","win","requestIdleCallback","cancelIdleCallback","memoizedWarnOnArraySlug","memoize","warnOnArraySlug","getDocumentIds","isDraft","published","draft","serializePath","part","isIndex","isKey","defaultIsUnique","slug","getClient","document","schemaOptions","disableArrayWarning","_id","docType","atPath","apiVersion","fetch","tag","serializedPath","slugValidator","slugValue","current","isUnique","slugContext","wasUnique","isRuleConstraint","getTypeChain","visited","baseRuleReducer","inputRule","baseRule","jsonType","typeOptionsList","list","option","extractValueFromListOption","hasValueField","field","normalizeValidationRules","validation","RuleClass","acc","maybeRecord","resolveTypeForArrayItem","candidates","itemType","isTypedObject","primitive","find","candidate","EMPTY_MARKERS","validateDocument","doc","schema","lastValueFrom","validateDocumentObservable","documentType","of","client","validationOptions","wrappedClient","__proto__","original","defineProperty","validateItemObservable","pipe","catchError","restOfContext","selfChecks","defer","nestedChecks","selfIsRequired","shouldRunNestedObjectValidation","fieldTypes","fieldResults","entries","fieldType","subRule","nestedValue","shouldRunNestedValidationForArrays","index","shouldRunNestedValidationForMarkDefs","isPortableTextTextBlock","markDefs","isBlockSchemaType","spanChildrenField","spanType","isSpanSchemaType","annotations","annotationType","set","Map","markDef","mergeMap","validateNode","idle","mergeAll","toArray","flatten","uniqBy","JSON","stringify","timeout","Observable","observer","complete","traverse","annotation","inferFromSchemaType","inferFromSchema","typeNames","getTypeNames","typeName","schemaType"],"mappings":"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"}