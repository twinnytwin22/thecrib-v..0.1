(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.SanityClient = factory());
})(this, (function () { 'use strict';

  function getSelection(sel) {
    if (typeof sel === 'string' || Array.isArray(sel)) {
      return {id: sel}
    }

    if (sel && sel.query) {
      return 'params' in sel ? {query: sel.query, params: sel.params} : {query: sel.query}
    }

    const selectionOpts = [
      '* Document ID (<docId>)',
      '* Array of document IDs',
      '* Object containing `query`',
    ].join('\n');

    throw new Error(`Unknown selection - must be one of:\n\n${selectionOpts}`)
  }

  const VALID_ASSET_TYPES = ['image', 'file'];
  const VALID_INSERT_LOCATIONS = ['before', 'after', 'replace'];

  const dataset = (name) => {
    if (!/^(~[a-z0-9]{1}[-\w]{0,63}|[a-z0-9]{1}[-\w]{0,63})$/.test(name)) {
      throw new Error(
        'Datasets can only contain lowercase characters, numbers, underscores and dashes, and start with tilde, and be maximum 64 characters'
      )
    }
  };

  const projectId = (id) => {
    if (!/^[-a-z0-9]+$/i.test(id)) {
      throw new Error('`projectId` can only contain only a-z, 0-9 and dashes')
    }
  };

  const validateAssetType = (type) => {
    if (VALID_ASSET_TYPES.indexOf(type) === -1) {
      throw new Error(`Invalid asset type: ${type}. Must be one of ${VALID_ASSET_TYPES.join(', ')}`)
    }
  };

  const validateObject = (op, val) => {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      throw new Error(`${op}() takes an object of properties`)
    }
  };

  const validateDocumentId = (op, id) => {
    if (typeof id !== 'string' || !/^[a-z0-9_.-]+$/i.test(id)) {
      throw new Error(`${op}(): "${id}" is not a valid document ID`)
    }
  };

  const requireDocumentId = (op, doc) => {
    if (!doc._id) {
      throw new Error(`${op}() requires that the document contains an ID ("_id" property)`)
    }

    validateDocumentId(op, doc._id);
  };

  const validateInsert = (at, selector, items) => {
    const signature = 'insert(at, selector, items)';
    if (VALID_INSERT_LOCATIONS.indexOf(at) === -1) {
      const valid = VALID_INSERT_LOCATIONS.map((loc) => `"${loc}"`).join(', ');
      throw new Error(`${signature} takes an "at"-argument which is one of: ${valid}`)
    }

    if (typeof selector !== 'string') {
      throw new Error(`${signature} takes a "selector"-argument which must be a string`)
    }

    if (!Array.isArray(items)) {
      throw new Error(`${signature} takes an "items"-argument which must be an array`)
    }
  };

  const hasDataset = (config) => {
    if (!config.dataset) {
      throw new Error('`dataset` must be provided to perform queries')
    }

    return config.dataset || ''
  };

  const requestTag = (tag) => {
    if (typeof tag !== 'string' || !/^[a-z0-9._-]{1,75}$/i.test(tag)) {
      throw new Error(
        `Tag can only contain alphanumeric characters, underscores, dashes and dots, and be between one and 75 characters long.`
      )
    }

    return tag
  };

  function Patch(selection, operations = {}, client = null) {
    this.selection = selection;
    this.operations = Object.assign({}, operations);
    this.client = client;
  }

  Object.assign(Patch.prototype, {
    clone() {
      return new Patch(this.selection, Object.assign({}, this.operations), this.client)
    },

    set(props) {
      return this.assign('set', props)
    },

    diffMatchPatch(props) {
      validateObject('diffMatchPatch', props);
      return this.assign('diffMatchPatch', props)
    },

    unset(attrs) {
      if (!Array.isArray(attrs)) {
        throw new Error('unset(attrs) takes an array of attributes to unset, non-array given')
      }

      this.operations = Object.assign({}, this.operations, {unset: attrs});
      return this
    },

    setIfMissing(props) {
      return this.assign('setIfMissing', props)
    },

    replace(props) {
      validateObject('replace', props);
      return this._set('set', {$: props}) // eslint-disable-line id-length
    },

    inc(props) {
      return this.assign('inc', props)
    },

    dec(props) {
      return this.assign('dec', props)
    },

    insert(at, selector, items) {
      validateInsert(at, selector, items);
      return this.assign('insert', {[at]: selector, items})
    },

    append(selector, items) {
      return this.insert('after', `${selector}[-1]`, items)
    },

    prepend(selector, items) {
      return this.insert('before', `${selector}[0]`, items)
    },

    splice(selector, start, deleteCount, items) {
      // Negative indexes doesn't mean the same in Sanity as they do in JS;
      // -1 means "actually at the end of the array", which allows inserting
      // at the end of the array without knowing its length. We therefore have
      // to substract negative indexes by one to match JS. If you want Sanity-
      // behaviour, just use `insert('replace', selector, items)` directly
      const delAll = typeof deleteCount === 'undefined' || deleteCount === -1;
      const startIndex = start < 0 ? start - 1 : start;
      const delCount = delAll ? -1 : Math.max(0, start + deleteCount);
      const delRange = startIndex < 0 && delCount >= 0 ? '' : delCount;
      const rangeSelector = `${selector}[${startIndex}:${delRange}]`;
      return this.insert('replace', rangeSelector, items || [])
    },

    ifRevisionId(rev) {
      this.operations.ifRevisionID = rev;
      return this
    },

    serialize() {
      return Object.assign(getSelection(this.selection), this.operations)
    },

    toJSON() {
      return this.serialize()
    },

    commit(options = {}) {
      if (!this.client) {
        throw new Error(
          'No `client` passed to patch, either provide one or pass the ' +
            'patch to a clients `mutate()` method'
        )
      }

      const returnFirst = typeof this.selection === 'string';
      const opts = Object.assign({returnFirst, returnDocuments: true}, options);
      return this.client.mutate({patch: this.serialize()}, opts)
    },

    reset() {
      this.operations = {};
      return this
    },

    _set(op, props) {
      return this.assign(op, props, false)
    },

    assign(op, props, merge = true) {
      validateObject(op, props);
      this.operations = Object.assign({}, this.operations, {
        [op]: Object.assign({}, (merge && this.operations[op]) || {}, props),
      });
      return this
    },
  });

  const defaultMutateOptions = {returnDocuments: false};

  function Transaction(operations = [], client, transactionId) {
    this.trxId = transactionId;
    this.operations = operations;
    this.client = client;
  }

  Object.assign(Transaction.prototype, {
    clone() {
      return new Transaction(this.operations.slice(0), this.client, this.trxId)
    },

    create(doc) {
      validateObject('create', doc);
      return this._add({create: doc})
    },

    createIfNotExists(doc) {
      const op = 'createIfNotExists';
      validateObject(op, doc);
      requireDocumentId(op, doc);
      return this._add({[op]: doc})
    },

    createOrReplace(doc) {
      const op = 'createOrReplace';
      validateObject(op, doc);
      requireDocumentId(op, doc);
      return this._add({[op]: doc})
    },

    delete(documentId) {
      validateDocumentId('delete', documentId);
      return this._add({delete: {id: documentId}})
    },

    patch(documentId, patchOps) {
      const isBuilder = typeof patchOps === 'function';
      const isPatch = documentId instanceof Patch;

      // transaction.patch(client.patch('documentId').inc({visits: 1}))
      if (isPatch) {
        return this._add({patch: documentId.serialize()})
      }

      // patch => patch.inc({visits: 1}).set({foo: 'bar'})
      if (isBuilder) {
        const patch = patchOps(new Patch(documentId, {}, this.client));
        if (!(patch instanceof Patch)) {
          throw new Error('function passed to `patch()` must return the patch')
        }

        return this._add({patch: patch.serialize()})
      }

      return this._add({patch: Object.assign({id: documentId}, patchOps)})
    },

    transactionId(id) {
      if (!id) {
        return this.trxId
      }

      this.trxId = id;
      return this
    },

    serialize() {
      return this.operations.slice()
    },

    toJSON() {
      return this.serialize()
    },

    commit(options) {
      if (!this.client) {
        throw new Error(
          'No `client` passed to transaction, either provide one or pass the ' +
            'transaction to a clients `mutate()` method'
        )
      }

      return this.client.mutate(
        this.serialize(),
        Object.assign({transactionId: this.trxId}, defaultMutateOptions, options || {})
      )
    },

    reset() {
      this.operations = [];
      return this
    },

    _add(mut) {
      this.operations.push(mut);
      return this
    },
  });

  const enc = encodeURIComponent;

  var encodeQueryString = ({query, params = {}, options = {}}) => {
    // We generally want tag at the start of the query string
    const {tag, ...opts} = options;
    const q = `query=${enc(query)}`;
    const base = tag ? `?tag=${enc(tag)}&${q}` : `?${q}`;

    const qString = Object.keys(params).reduce(
      (qs, param) => `${qs}&${enc(`$${param}`)}=${enc(JSON.stringify(params[param]))}`,
      base
    );

    return Object.keys(opts).reduce((qs, option) => {
      // Only include the option if it is truthy
      return options[option] ? `${qs}&${enc(option)}=${enc(options[option])}` : qs
    }, qString)
  };

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function getAugmentedNamespace(n) {
    if (n.__esModule) return n;
    var f = n.default;
  	if (typeof f == "function") {
  		var a = function a () {
  			if (this instanceof a) {
  				var args = [null];
  				args.push.apply(args, arguments);
  				var Ctor = Function.bind.apply(f, args);
  				return new Ctor();
  			}
  			return f.apply(this, arguments);
  		};
  		a.prototype = f.prototype;
    } else a = {};
    Object.defineProperty(a, '__esModule', {value: true});
  	Object.keys(n).forEach(function (k) {
  		var d = Object.getOwnPropertyDescriptor(n, k);
  		Object.defineProperty(a, k, d.get ? d : {
  			enumerable: true,
  			get: function () {
  				return n[k];
  			}
  		});
  	});
  	return a;
  }

  var eventsourceExports = {};
  var eventsource = {
    get exports(){ return eventsourceExports; },
    set exports(v){ eventsourceExports = v; },
  };

  /** @license
   * eventsource.js
   * Available under MIT License (MIT)
   * https://github.com/Yaffle/EventSource/
   */

  (function (module, exports) {
  	/*jslint indent: 2, vars: true, plusplus: true */
  	/*global setTimeout, clearTimeout */

  	(function (global) {

  	  var setTimeout = global.setTimeout;
  	  var clearTimeout = global.clearTimeout;
  	  var XMLHttpRequest = global.XMLHttpRequest;
  	  var XDomainRequest = global.XDomainRequest;
  	  var ActiveXObject = global.ActiveXObject;
  	  var NativeEventSource = global.EventSource;

  	  var document = global.document;
  	  var Promise = global.Promise;
  	  var fetch = global.fetch;
  	  var Response = global.Response;
  	  var TextDecoder = global.TextDecoder;
  	  var TextEncoder = global.TextEncoder;
  	  var AbortController = global.AbortController;

  	  if (typeof window !== "undefined" && typeof document !== "undefined" && !("readyState" in document) && document.body == null) { // Firefox 2
  	    document.readyState = "loading";
  	    window.addEventListener("load", function (event) {
  	      document.readyState = "complete";
  	    }, false);
  	  }

  	  if (XMLHttpRequest == null && ActiveXObject != null) { // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest_in_IE6
  	    XMLHttpRequest = function () {
  	      return new ActiveXObject("Microsoft.XMLHTTP");
  	    };
  	  }

  	  if (Object.create == undefined) {
  	    Object.create = function (C) {
  	      function F(){}
  	      F.prototype = C;
  	      return new F();
  	    };
  	  }

  	  if (!Date.now) {
  	    Date.now = function now() {
  	      return new Date().getTime();
  	    };
  	  }

  	  // see #118 (Promise#finally with polyfilled Promise)
  	  // see #123 (data URLs crash Edge)
  	  // see #125 (CSP violations)
  	  // see pull/#138
  	  // => No way to polyfill Promise#finally

  	  if (AbortController == undefined) {
  	    var originalFetch2 = fetch;
  	    fetch = function (url, options) {
  	      var signal = options.signal;
  	      return originalFetch2(url, {headers: options.headers, credentials: options.credentials, cache: options.cache}).then(function (response) {
  	        var reader = response.body.getReader();
  	        signal._reader = reader;
  	        if (signal._aborted) {
  	          signal._reader.cancel();
  	        }
  	        return {
  	          status: response.status,
  	          statusText: response.statusText,
  	          headers: response.headers,
  	          body: {
  	            getReader: function () {
  	              return reader;
  	            }
  	          }
  	        };
  	      });
  	    };
  	    AbortController = function () {
  	      this.signal = {
  	        _reader: null,
  	        _aborted: false
  	      };
  	      this.abort = function () {
  	        if (this.signal._reader != null) {
  	          this.signal._reader.cancel();
  	        }
  	        this.signal._aborted = true;
  	      };
  	    };
  	  }

  	  function TextDecoderPolyfill() {
  	    this.bitsNeeded = 0;
  	    this.codePoint = 0;
  	  }

  	  TextDecoderPolyfill.prototype.decode = function (octets) {
  	    function valid(codePoint, shift, octetsCount) {
  	      if (octetsCount === 1) {
  	        return codePoint >= 0x0080 >> shift && codePoint << shift <= 0x07FF;
  	      }
  	      if (octetsCount === 2) {
  	        return codePoint >= 0x0800 >> shift && codePoint << shift <= 0xD7FF || codePoint >= 0xE000 >> shift && codePoint << shift <= 0xFFFF;
  	      }
  	      if (octetsCount === 3) {
  	        return codePoint >= 0x010000 >> shift && codePoint << shift <= 0x10FFFF;
  	      }
  	      throw new Error();
  	    }
  	    function octetsCount(bitsNeeded, codePoint) {
  	      if (bitsNeeded === 6 * 1) {
  	        return codePoint >> 6 > 15 ? 3 : codePoint > 31 ? 2 : 1;
  	      }
  	      if (bitsNeeded === 6 * 2) {
  	        return codePoint > 15 ? 3 : 2;
  	      }
  	      if (bitsNeeded === 6 * 3) {
  	        return 3;
  	      }
  	      throw new Error();
  	    }
  	    var REPLACER = 0xFFFD;
  	    var string = "";
  	    var bitsNeeded = this.bitsNeeded;
  	    var codePoint = this.codePoint;
  	    for (var i = 0; i < octets.length; i += 1) {
  	      var octet = octets[i];
  	      if (bitsNeeded !== 0) {
  	        if (octet < 128 || octet > 191 || !valid(codePoint << 6 | octet & 63, bitsNeeded - 6, octetsCount(bitsNeeded, codePoint))) {
  	          bitsNeeded = 0;
  	          codePoint = REPLACER;
  	          string += String.fromCharCode(codePoint);
  	        }
  	      }
  	      if (bitsNeeded === 0) {
  	        if (octet >= 0 && octet <= 127) {
  	          bitsNeeded = 0;
  	          codePoint = octet;
  	        } else if (octet >= 192 && octet <= 223) {
  	          bitsNeeded = 6 * 1;
  	          codePoint = octet & 31;
  	        } else if (octet >= 224 && octet <= 239) {
  	          bitsNeeded = 6 * 2;
  	          codePoint = octet & 15;
  	        } else if (octet >= 240 && octet <= 247) {
  	          bitsNeeded = 6 * 3;
  	          codePoint = octet & 7;
  	        } else {
  	          bitsNeeded = 0;
  	          codePoint = REPLACER;
  	        }
  	        if (bitsNeeded !== 0 && !valid(codePoint, bitsNeeded, octetsCount(bitsNeeded, codePoint))) {
  	          bitsNeeded = 0;
  	          codePoint = REPLACER;
  	        }
  	      } else {
  	        bitsNeeded -= 6;
  	        codePoint = codePoint << 6 | octet & 63;
  	      }
  	      if (bitsNeeded === 0) {
  	        if (codePoint <= 0xFFFF) {
  	          string += String.fromCharCode(codePoint);
  	        } else {
  	          string += String.fromCharCode(0xD800 + (codePoint - 0xFFFF - 1 >> 10));
  	          string += String.fromCharCode(0xDC00 + (codePoint - 0xFFFF - 1 & 0x3FF));
  	        }
  	      }
  	    }
  	    this.bitsNeeded = bitsNeeded;
  	    this.codePoint = codePoint;
  	    return string;
  	  };

  	  // Firefox < 38 throws an error with stream option
  	  var supportsStreamOption = function () {
  	    try {
  	      return new TextDecoder().decode(new TextEncoder().encode("test"), {stream: true}) === "test";
  	    } catch (error) {
  	      console.debug("TextDecoder does not support streaming option. Using polyfill instead: " + error);
  	    }
  	    return false;
  	  };

  	  // IE, Edge
  	  if (TextDecoder == undefined || TextEncoder == undefined || !supportsStreamOption()) {
  	    TextDecoder = TextDecoderPolyfill;
  	  }

  	  var k = function () {
  	  };

  	  function XHRWrapper(xhr) {
  	    this.withCredentials = false;
  	    this.readyState = 0;
  	    this.status = 0;
  	    this.statusText = "";
  	    this.responseText = "";
  	    this.onprogress = k;
  	    this.onload = k;
  	    this.onerror = k;
  	    this.onreadystatechange = k;
  	    this._contentType = "";
  	    this._xhr = xhr;
  	    this._sendTimeout = 0;
  	    this._abort = k;
  	  }

  	  XHRWrapper.prototype.open = function (method, url) {
  	    this._abort(true);

  	    var that = this;
  	    var xhr = this._xhr;
  	    var state = 1;
  	    var timeout = 0;

  	    this._abort = function (silent) {
  	      if (that._sendTimeout !== 0) {
  	        clearTimeout(that._sendTimeout);
  	        that._sendTimeout = 0;
  	      }
  	      if (state === 1 || state === 2 || state === 3) {
  	        state = 4;
  	        xhr.onload = k;
  	        xhr.onerror = k;
  	        xhr.onabort = k;
  	        xhr.onprogress = k;
  	        xhr.onreadystatechange = k;
  	        // IE 8 - 9: XDomainRequest#abort() does not fire any event
  	        // Opera < 10: XMLHttpRequest#abort() does not fire any event
  	        xhr.abort();
  	        if (timeout !== 0) {
  	          clearTimeout(timeout);
  	          timeout = 0;
  	        }
  	        if (!silent) {
  	          that.readyState = 4;
  	          that.onabort(null);
  	          that.onreadystatechange();
  	        }
  	      }
  	      state = 0;
  	    };

  	    var onStart = function () {
  	      if (state === 1) {
  	        //state = 2;
  	        var status = 0;
  	        var statusText = "";
  	        var contentType = undefined;
  	        if (!("contentType" in xhr)) {
  	          try {
  	            status = xhr.status;
  	            statusText = xhr.statusText;
  	            contentType = xhr.getResponseHeader("Content-Type");
  	          } catch (error) {
  	            // IE < 10 throws exception for `xhr.status` when xhr.readyState === 2 || xhr.readyState === 3
  	            // Opera < 11 throws exception for `xhr.status` when xhr.readyState === 2
  	            // https://bugs.webkit.org/show_bug.cgi?id=29121
  	            status = 0;
  	            statusText = "";
  	            contentType = undefined;
  	            // Firefox < 14, Chrome ?, Safari ?
  	            // https://bugs.webkit.org/show_bug.cgi?id=29658
  	            // https://bugs.webkit.org/show_bug.cgi?id=77854
  	          }
  	        } else {
  	          status = 200;
  	          statusText = "OK";
  	          contentType = xhr.contentType;
  	        }
  	        if (status !== 0) {
  	          state = 2;
  	          that.readyState = 2;
  	          that.status = status;
  	          that.statusText = statusText;
  	          that._contentType = contentType;
  	          that.onreadystatechange();
  	        }
  	      }
  	    };
  	    var onProgress = function () {
  	      onStart();
  	      if (state === 2 || state === 3) {
  	        state = 3;
  	        var responseText = "";
  	        try {
  	          responseText = xhr.responseText;
  	        } catch (error) {
  	          // IE 8 - 9 with XMLHttpRequest
  	        }
  	        that.readyState = 3;
  	        that.responseText = responseText;
  	        that.onprogress();
  	      }
  	    };
  	    var onFinish = function (type, event) {
  	      if (event == null || event.preventDefault == null) {
  	        event = {
  	          preventDefault: k
  	        };
  	      }
  	      // Firefox 52 fires "readystatechange" (xhr.readyState === 4) without final "readystatechange" (xhr.readyState === 3)
  	      // IE 8 fires "onload" without "onprogress"
  	      onProgress();
  	      if (state === 1 || state === 2 || state === 3) {
  	        state = 4;
  	        if (timeout !== 0) {
  	          clearTimeout(timeout);
  	          timeout = 0;
  	        }
  	        that.readyState = 4;
  	        if (type === "load") {
  	          that.onload(event);
  	        } else if (type === "error") {
  	          that.onerror(event);
  	        } else if (type === "abort") {
  	          that.onabort(event);
  	        } else {
  	          throw new TypeError();
  	        }
  	        that.onreadystatechange();
  	      }
  	    };
  	    var onReadyStateChange = function (event) {
  	      if (xhr != undefined) { // Opera 12
  	        if (xhr.readyState === 4) {
  	          if (!("onload" in xhr) || !("onerror" in xhr) || !("onabort" in xhr)) {
  	            onFinish(xhr.responseText === "" ? "error" : "load", event);
  	          }
  	        } else if (xhr.readyState === 3) {
  	          if (!("onprogress" in xhr)) { // testing XMLHttpRequest#responseText too many times is too slow in IE 11
  	            // and in Firefox 3.6
  	            onProgress();
  	          }
  	        } else if (xhr.readyState === 2) {
  	          onStart();
  	        }
  	      }
  	    };
  	    var onTimeout = function () {
  	      timeout = setTimeout(function () {
  	        onTimeout();
  	      }, 500);
  	      if (xhr.readyState === 3) {
  	        onProgress();
  	      }
  	    };

  	    // XDomainRequest#abort removes onprogress, onerror, onload
  	    if ("onload" in xhr) {
  	      xhr.onload = function (event) {
  	        onFinish("load", event);
  	      };
  	    }
  	    if ("onerror" in xhr) {
  	      xhr.onerror = function (event) {
  	        onFinish("error", event);
  	      };
  	    }
  	    // improper fix to match Firefox behaviour, but it is better than just ignore abort
  	    // see https://bugzilla.mozilla.org/show_bug.cgi?id=768596
  	    // https://bugzilla.mozilla.org/show_bug.cgi?id=880200
  	    // https://code.google.com/p/chromium/issues/detail?id=153570
  	    // IE 8 fires "onload" without "onprogress
  	    if ("onabort" in xhr) {
  	      xhr.onabort = function (event) {
  	        onFinish("abort", event);
  	      };
  	    }

  	    if ("onprogress" in xhr) {
  	      xhr.onprogress = onProgress;
  	    }

  	    // IE 8 - 9 (XMLHTTPRequest)
  	    // Opera < 12
  	    // Firefox < 3.5
  	    // Firefox 3.5 - 3.6 - ? < 9.0
  	    // onprogress is not fired sometimes or delayed
  	    // see also #64 (significant lag in IE 11)
  	    if ("onreadystatechange" in xhr) {
  	      xhr.onreadystatechange = function (event) {
  	        onReadyStateChange(event);
  	      };
  	    }

  	    if ("contentType" in xhr || !("ontimeout" in XMLHttpRequest.prototype)) {
  	      url += (url.indexOf("?") === -1 ? "?" : "&") + "padding=true";
  	    }
  	    xhr.open(method, url, true);

  	    if ("readyState" in xhr) {
  	      // workaround for Opera 12 issue with "progress" events
  	      // #91 (XMLHttpRequest onprogress not fired for streaming response in Edge 14-15-?)
  	      timeout = setTimeout(function () {
  	        onTimeout();
  	      }, 0);
  	    }
  	  };
  	  XHRWrapper.prototype.abort = function () {
  	    this._abort(false);
  	  };
  	  XHRWrapper.prototype.getResponseHeader = function (name) {
  	    return this._contentType;
  	  };
  	  XHRWrapper.prototype.setRequestHeader = function (name, value) {
  	    var xhr = this._xhr;
  	    if ("setRequestHeader" in xhr) {
  	      xhr.setRequestHeader(name, value);
  	    }
  	  };
  	  XHRWrapper.prototype.getAllResponseHeaders = function () {
  	    // XMLHttpRequest#getAllResponseHeaders returns null for CORS requests in Firefox 3.6.28
  	    return this._xhr.getAllResponseHeaders != undefined ? this._xhr.getAllResponseHeaders() || "" : "";
  	  };
  	  XHRWrapper.prototype.send = function () {
  	    // loading indicator in Safari < ? (6), Chrome < 14, Firefox
  	    // https://bugzilla.mozilla.org/show_bug.cgi?id=736723
  	    if ((!("ontimeout" in XMLHttpRequest.prototype) || (!("sendAsBinary" in XMLHttpRequest.prototype) && !("mozAnon" in XMLHttpRequest.prototype))) &&
  	        document != undefined &&
  	        document.readyState != undefined &&
  	        document.readyState !== "complete") {
  	      var that = this;
  	      that._sendTimeout = setTimeout(function () {
  	        that._sendTimeout = 0;
  	        that.send();
  	      }, 4);
  	      return;
  	    }

  	    var xhr = this._xhr;
  	    // withCredentials should be set after "open" for Safari and Chrome (< 19 ?)
  	    if ("withCredentials" in xhr) {
  	      xhr.withCredentials = this.withCredentials;
  	    }
  	    try {
  	      // xhr.send(); throws "Not enough arguments" in Firefox 3.0
  	      xhr.send(undefined);
  	    } catch (error1) {
  	      // Safari 5.1.7, Opera 12
  	      throw error1;
  	    }
  	  };

  	  function toLowerCase(name) {
  	    return name.replace(/[A-Z]/g, function (c) {
  	      return String.fromCharCode(c.charCodeAt(0) + 0x20);
  	    });
  	  }

  	  function HeadersPolyfill(all) {
  	    // Get headers: implemented according to mozilla's example code: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders#Example
  	    var map = Object.create(null);
  	    var array = all.split("\r\n");
  	    for (var i = 0; i < array.length; i += 1) {
  	      var line = array[i];
  	      var parts = line.split(": ");
  	      var name = parts.shift();
  	      var value = parts.join(": ");
  	      map[toLowerCase(name)] = value;
  	    }
  	    this._map = map;
  	  }
  	  HeadersPolyfill.prototype.get = function (name) {
  	    return this._map[toLowerCase(name)];
  	  };

  	  if (XMLHttpRequest != null && XMLHttpRequest.HEADERS_RECEIVED == null) { // IE < 9, Firefox 3.6
  	    XMLHttpRequest.HEADERS_RECEIVED = 2;
  	  }

  	  function XHRTransport() {
  	  }

  	  XHRTransport.prototype.open = function (xhr, onStartCallback, onProgressCallback, onFinishCallback, url, withCredentials, headers) {
  	    xhr.open("GET", url);
  	    var offset = 0;
  	    xhr.onprogress = function () {
  	      var responseText = xhr.responseText;
  	      var chunk = responseText.slice(offset);
  	      offset += chunk.length;
  	      onProgressCallback(chunk);
  	    };
  	    xhr.onerror = function (event) {
  	      event.preventDefault();
  	      onFinishCallback(new Error("NetworkError"));
  	    };
  	    xhr.onload = function () {
  	      onFinishCallback(null);
  	    };
  	    xhr.onabort = function () {
  	      onFinishCallback(null);
  	    };
  	    xhr.onreadystatechange = function () {
  	      if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {
  	        var status = xhr.status;
  	        var statusText = xhr.statusText;
  	        var contentType = xhr.getResponseHeader("Content-Type");
  	        var headers = xhr.getAllResponseHeaders();
  	        onStartCallback(status, statusText, contentType, new HeadersPolyfill(headers));
  	      }
  	    };
  	    xhr.withCredentials = withCredentials;
  	    for (var name in headers) {
  	      if (Object.prototype.hasOwnProperty.call(headers, name)) {
  	        xhr.setRequestHeader(name, headers[name]);
  	      }
  	    }
  	    xhr.send();
  	    return xhr;
  	  };

  	  function HeadersWrapper(headers) {
  	    this._headers = headers;
  	  }
  	  HeadersWrapper.prototype.get = function (name) {
  	    return this._headers.get(name);
  	  };

  	  function FetchTransport() {
  	  }

  	  FetchTransport.prototype.open = function (xhr, onStartCallback, onProgressCallback, onFinishCallback, url, withCredentials, headers) {
  	    var reader = null;
  	    var controller = new AbortController();
  	    var signal = controller.signal;
  	    var textDecoder = new TextDecoder();
  	    fetch(url, {
  	      headers: headers,
  	      credentials: withCredentials ? "include" : "same-origin",
  	      signal: signal,
  	      cache: "no-store"
  	    }).then(function (response) {
  	      reader = response.body.getReader();
  	      onStartCallback(response.status, response.statusText, response.headers.get("Content-Type"), new HeadersWrapper(response.headers));
  	      // see https://github.com/promises-aplus/promises-spec/issues/179
  	      return new Promise(function (resolve, reject) {
  	        var readNextChunk = function () {
  	          reader.read().then(function (result) {
  	            if (result.done) {
  	              //Note: bytes in textDecoder are ignored
  	              resolve(undefined);
  	            } else {
  	              var chunk = textDecoder.decode(result.value, {stream: true});
  	              onProgressCallback(chunk);
  	              readNextChunk();
  	            }
  	          })["catch"](function (error) {
  	            reject(error);
  	          });
  	        };
  	        readNextChunk();
  	      });
  	    })["catch"](function (error) {
  	      if (error.name === "AbortError") {
  	        return undefined;
  	      } else {
  	        return error;
  	      }
  	    }).then(function (error) {
  	      onFinishCallback(error);
  	    });
  	    return {
  	      abort: function () {
  	        if (reader != null) {
  	          reader.cancel(); // https://bugzilla.mozilla.org/show_bug.cgi?id=1583815
  	        }
  	        controller.abort();
  	      }
  	    };
  	  };

  	  function EventTarget() {
  	    this._listeners = Object.create(null);
  	  }

  	  function throwError(e) {
  	    setTimeout(function () {
  	      throw e;
  	    }, 0);
  	  }

  	  EventTarget.prototype.dispatchEvent = function (event) {
  	    event.target = this;
  	    var typeListeners = this._listeners[event.type];
  	    if (typeListeners != undefined) {
  	      var length = typeListeners.length;
  	      for (var i = 0; i < length; i += 1) {
  	        var listener = typeListeners[i];
  	        try {
  	          if (typeof listener.handleEvent === "function") {
  	            listener.handleEvent(event);
  	          } else {
  	            listener.call(this, event);
  	          }
  	        } catch (e) {
  	          throwError(e);
  	        }
  	      }
  	    }
  	  };
  	  EventTarget.prototype.addEventListener = function (type, listener) {
  	    type = String(type);
  	    var listeners = this._listeners;
  	    var typeListeners = listeners[type];
  	    if (typeListeners == undefined) {
  	      typeListeners = [];
  	      listeners[type] = typeListeners;
  	    }
  	    var found = false;
  	    for (var i = 0; i < typeListeners.length; i += 1) {
  	      if (typeListeners[i] === listener) {
  	        found = true;
  	      }
  	    }
  	    if (!found) {
  	      typeListeners.push(listener);
  	    }
  	  };
  	  EventTarget.prototype.removeEventListener = function (type, listener) {
  	    type = String(type);
  	    var listeners = this._listeners;
  	    var typeListeners = listeners[type];
  	    if (typeListeners != undefined) {
  	      var filtered = [];
  	      for (var i = 0; i < typeListeners.length; i += 1) {
  	        if (typeListeners[i] !== listener) {
  	          filtered.push(typeListeners[i]);
  	        }
  	      }
  	      if (filtered.length === 0) {
  	        delete listeners[type];
  	      } else {
  	        listeners[type] = filtered;
  	      }
  	    }
  	  };

  	  function Event(type) {
  	    this.type = type;
  	    this.target = undefined;
  	  }

  	  function MessageEvent(type, options) {
  	    Event.call(this, type);
  	    this.data = options.data;
  	    this.lastEventId = options.lastEventId;
  	  }

  	  MessageEvent.prototype = Object.create(Event.prototype);

  	  function ConnectionEvent(type, options) {
  	    Event.call(this, type);
  	    this.status = options.status;
  	    this.statusText = options.statusText;
  	    this.headers = options.headers;
  	  }

  	  ConnectionEvent.prototype = Object.create(Event.prototype);

  	  function ErrorEvent(type, options) {
  	    Event.call(this, type);
  	    this.error = options.error;
  	  }

  	  ErrorEvent.prototype = Object.create(Event.prototype);

  	  var WAITING = -1;
  	  var CONNECTING = 0;
  	  var OPEN = 1;
  	  var CLOSED = 2;

  	  var AFTER_CR = -1;
  	  var FIELD_START = 0;
  	  var FIELD = 1;
  	  var VALUE_START = 2;
  	  var VALUE = 3;

  	  var contentTypeRegExp = /^text\/event\-stream(;.*)?$/i;

  	  var MINIMUM_DURATION = 1000;
  	  var MAXIMUM_DURATION = 18000000;

  	  var parseDuration = function (value, def) {
  	    var n = value == null ? def : parseInt(value, 10);
  	    if (n !== n) {
  	      n = def;
  	    }
  	    return clampDuration(n);
  	  };
  	  var clampDuration = function (n) {
  	    return Math.min(Math.max(n, MINIMUM_DURATION), MAXIMUM_DURATION);
  	  };

  	  var fire = function (that, f, event) {
  	    try {
  	      if (typeof f === "function") {
  	        f.call(that, event);
  	      }
  	    } catch (e) {
  	      throwError(e);
  	    }
  	  };

  	  function EventSourcePolyfill(url, options) {
  	    EventTarget.call(this);
  	    options = options || {};

  	    this.onopen = undefined;
  	    this.onmessage = undefined;
  	    this.onerror = undefined;

  	    this.url = undefined;
  	    this.readyState = undefined;
  	    this.withCredentials = undefined;
  	    this.headers = undefined;

  	    this._close = undefined;

  	    start(this, url, options);
  	  }

  	  function getBestXHRTransport() {
  	    return (XMLHttpRequest != undefined && ("withCredentials" in XMLHttpRequest.prototype)) || XDomainRequest == undefined
  	        ? new XMLHttpRequest()
  	        : new XDomainRequest();
  	  }

  	  var isFetchSupported = fetch != undefined && Response != undefined && "body" in Response.prototype;

  	  function start(es, url, options) {
  	    url = String(url);
  	    var withCredentials = Boolean(options.withCredentials);
  	    var lastEventIdQueryParameterName = options.lastEventIdQueryParameterName || "lastEventId";

  	    var initialRetry = clampDuration(1000);
  	    var heartbeatTimeout = parseDuration(options.heartbeatTimeout, 45000);

  	    var lastEventId = "";
  	    var retry = initialRetry;
  	    var wasActivity = false;
  	    var textLength = 0;
  	    var headers = options.headers || {};
  	    var TransportOption = options.Transport;
  	    var xhr = isFetchSupported && TransportOption == undefined ? undefined : new XHRWrapper(TransportOption != undefined ? new TransportOption() : getBestXHRTransport());
  	    var transport = TransportOption != null && typeof TransportOption !== "string" ? new TransportOption() : (xhr == undefined ? new FetchTransport() : new XHRTransport());
  	    var abortController = undefined;
  	    var timeout = 0;
  	    var currentState = WAITING;
  	    var dataBuffer = "";
  	    var lastEventIdBuffer = "";
  	    var eventTypeBuffer = "";

  	    var textBuffer = "";
  	    var state = FIELD_START;
  	    var fieldStart = 0;
  	    var valueStart = 0;

  	    var onStart = function (status, statusText, contentType, headers) {
  	      if (currentState === CONNECTING) {
  	        if (status === 200 && contentType != undefined && contentTypeRegExp.test(contentType)) {
  	          currentState = OPEN;
  	          wasActivity = Date.now();
  	          retry = initialRetry;
  	          es.readyState = OPEN;
  	          var event = new ConnectionEvent("open", {
  	            status: status,
  	            statusText: statusText,
  	            headers: headers
  	          });
  	          es.dispatchEvent(event);
  	          fire(es, es.onopen, event);
  	        } else {
  	          var message = "";
  	          if (status !== 200) {
  	            if (statusText) {
  	              statusText = statusText.replace(/\s+/g, " ");
  	            }
  	            message = "EventSource's response has a status " + status + " " + statusText + " that is not 200. Aborting the connection.";
  	          } else {
  	            message = "EventSource's response has a Content-Type specifying an unsupported type: " + (contentType == undefined ? "-" : contentType.replace(/\s+/g, " ")) + ". Aborting the connection.";
  	          }
  	          close();
  	          var event = new ConnectionEvent("error", {
  	            status: status,
  	            statusText: statusText,
  	            headers: headers
  	          });
  	          es.dispatchEvent(event);
  	          fire(es, es.onerror, event);
  	          console.error(message);
  	        }
  	      }
  	    };

  	    var onProgress = function (textChunk) {
  	      if (currentState === OPEN) {
  	        var n = -1;
  	        for (var i = 0; i < textChunk.length; i += 1) {
  	          var c = textChunk.charCodeAt(i);
  	          if (c === "\n".charCodeAt(0) || c === "\r".charCodeAt(0)) {
  	            n = i;
  	          }
  	        }
  	        var chunk = (n !== -1 ? textBuffer : "") + textChunk.slice(0, n + 1);
  	        textBuffer = (n === -1 ? textBuffer : "") + textChunk.slice(n + 1);
  	        if (textChunk !== "") {
  	          wasActivity = Date.now();
  	          textLength += textChunk.length;
  	        }
  	        for (var position = 0; position < chunk.length; position += 1) {
  	          var c = chunk.charCodeAt(position);
  	          if (state === AFTER_CR && c === "\n".charCodeAt(0)) {
  	            state = FIELD_START;
  	          } else {
  	            if (state === AFTER_CR) {
  	              state = FIELD_START;
  	            }
  	            if (c === "\r".charCodeAt(0) || c === "\n".charCodeAt(0)) {
  	              if (state !== FIELD_START) {
  	                if (state === FIELD) {
  	                  valueStart = position + 1;
  	                }
  	                var field = chunk.slice(fieldStart, valueStart - 1);
  	                var value = chunk.slice(valueStart + (valueStart < position && chunk.charCodeAt(valueStart) === " ".charCodeAt(0) ? 1 : 0), position);
  	                if (field === "data") {
  	                  dataBuffer += "\n";
  	                  dataBuffer += value;
  	                } else if (field === "id") {
  	                  lastEventIdBuffer = value;
  	                } else if (field === "event") {
  	                  eventTypeBuffer = value;
  	                } else if (field === "retry") {
  	                  initialRetry = parseDuration(value, initialRetry);
  	                  retry = initialRetry;
  	                } else if (field === "heartbeatTimeout") {
  	                  heartbeatTimeout = parseDuration(value, heartbeatTimeout);
  	                  if (timeout !== 0) {
  	                    clearTimeout(timeout);
  	                    timeout = setTimeout(function () {
  	                      onTimeout();
  	                    }, heartbeatTimeout);
  	                  }
  	                }
  	              }
  	              if (state === FIELD_START) {
  	                if (dataBuffer !== "") {
  	                  lastEventId = lastEventIdBuffer;
  	                  if (eventTypeBuffer === "") {
  	                    eventTypeBuffer = "message";
  	                  }
  	                  var event = new MessageEvent(eventTypeBuffer, {
  	                    data: dataBuffer.slice(1),
  	                    lastEventId: lastEventIdBuffer
  	                  });
  	                  es.dispatchEvent(event);
  	                  if (eventTypeBuffer === "open") {
  	                    fire(es, es.onopen, event);
  	                  } else if (eventTypeBuffer === "message") {
  	                    fire(es, es.onmessage, event);
  	                  } else if (eventTypeBuffer === "error") {
  	                    fire(es, es.onerror, event);
  	                  }
  	                  if (currentState === CLOSED) {
  	                    return;
  	                  }
  	                }
  	                dataBuffer = "";
  	                eventTypeBuffer = "";
  	              }
  	              state = c === "\r".charCodeAt(0) ? AFTER_CR : FIELD_START;
  	            } else {
  	              if (state === FIELD_START) {
  	                fieldStart = position;
  	                state = FIELD;
  	              }
  	              if (state === FIELD) {
  	                if (c === ":".charCodeAt(0)) {
  	                  valueStart = position + 1;
  	                  state = VALUE_START;
  	                }
  	              } else if (state === VALUE_START) {
  	                state = VALUE;
  	              }
  	            }
  	          }
  	        }
  	      }
  	    };

  	    var onFinish = function (error) {
  	      if (currentState === OPEN || currentState === CONNECTING) {
  	        currentState = WAITING;
  	        if (timeout !== 0) {
  	          clearTimeout(timeout);
  	          timeout = 0;
  	        }
  	        timeout = setTimeout(function () {
  	          onTimeout();
  	        }, retry);
  	        retry = clampDuration(Math.min(initialRetry * 16, retry * 2));

  	        es.readyState = CONNECTING;
  	        var event = new ErrorEvent("error", {error: error});
  	        es.dispatchEvent(event);
  	        fire(es, es.onerror, event);
  	        if (error != undefined) {
  	          console.error(error);
  	        }
  	      }
  	    };

  	    var close = function () {
  	      currentState = CLOSED;
  	      if (abortController != undefined) {
  	        abortController.abort();
  	        abortController = undefined;
  	      }
  	      if (timeout !== 0) {
  	        clearTimeout(timeout);
  	        timeout = 0;
  	      }
  	      es.readyState = CLOSED;
  	    };

  	    var onTimeout = function () {
  	      timeout = 0;

  	      if (currentState !== WAITING) {
  	        if (!wasActivity && abortController != undefined) {
  	          onFinish(new Error("No activity within " + heartbeatTimeout + " milliseconds." + " " + (currentState === CONNECTING ? "No response received." : textLength + " chars received.") + " " + "Reconnecting."));
  	          if (abortController != undefined) {
  	            abortController.abort();
  	            abortController = undefined;
  	          }
  	        } else {
  	          var nextHeartbeat = Math.max((wasActivity || Date.now()) + heartbeatTimeout - Date.now(), 1);
  	          wasActivity = false;
  	          timeout = setTimeout(function () {
  	            onTimeout();
  	          }, nextHeartbeat);
  	        }
  	        return;
  	      }

  	      wasActivity = false;
  	      textLength = 0;
  	      timeout = setTimeout(function () {
  	        onTimeout();
  	      }, heartbeatTimeout);

  	      currentState = CONNECTING;
  	      dataBuffer = "";
  	      eventTypeBuffer = "";
  	      lastEventIdBuffer = lastEventId;
  	      textBuffer = "";
  	      fieldStart = 0;
  	      valueStart = 0;
  	      state = FIELD_START;

  	      // https://bugzilla.mozilla.org/show_bug.cgi?id=428916
  	      // Request header field Last-Event-ID is not allowed by Access-Control-Allow-Headers.
  	      var requestURL = url;
  	      if (url.slice(0, 5) !== "data:" && url.slice(0, 5) !== "blob:") {
  	        if (lastEventId !== "") {
  	          // Remove the lastEventId parameter if it's already part of the request URL.
  	          var i = url.indexOf("?");
  	          requestURL = i === -1 ? url : url.slice(0, i + 1) + url.slice(i + 1).replace(/(?:^|&)([^=&]*)(?:=[^&]*)?/g, function (p, paramName) {
  	            return paramName === lastEventIdQueryParameterName ? '' : p;
  	          });
  	          // Append the current lastEventId to the request URL.
  	          requestURL += (url.indexOf("?") === -1 ? "?" : "&") + lastEventIdQueryParameterName +"=" + encodeURIComponent(lastEventId);
  	        }
  	      }
  	      var withCredentials = es.withCredentials;
  	      var requestHeaders = {};
  	      requestHeaders["Accept"] = "text/event-stream";
  	      var headers = es.headers;
  	      if (headers != undefined) {
  	        for (var name in headers) {
  	          if (Object.prototype.hasOwnProperty.call(headers, name)) {
  	            requestHeaders[name] = headers[name];
  	          }
  	        }
  	      }
  	      try {
  	        abortController = transport.open(xhr, onStart, onProgress, onFinish, requestURL, withCredentials, requestHeaders);
  	      } catch (error) {
  	        close();
  	        throw error;
  	      }
  	    };

  	    es.url = url;
  	    es.readyState = CONNECTING;
  	    es.withCredentials = withCredentials;
  	    es.headers = headers;
  	    es._close = close;

  	    onTimeout();
  	  }

  	  EventSourcePolyfill.prototype = Object.create(EventTarget.prototype);
  	  EventSourcePolyfill.prototype.CONNECTING = CONNECTING;
  	  EventSourcePolyfill.prototype.OPEN = OPEN;
  	  EventSourcePolyfill.prototype.CLOSED = CLOSED;
  	  EventSourcePolyfill.prototype.close = function () {
  	    this._close();
  	  };

  	  EventSourcePolyfill.CONNECTING = CONNECTING;
  	  EventSourcePolyfill.OPEN = OPEN;
  	  EventSourcePolyfill.CLOSED = CLOSED;
  	  EventSourcePolyfill.prototype.withCredentials = undefined;

  	  var R = NativeEventSource;
  	  if (XMLHttpRequest != undefined && (NativeEventSource == undefined || !("withCredentials" in NativeEventSource.prototype))) {
  	    // Why replace a native EventSource ?
  	    // https://bugzilla.mozilla.org/show_bug.cgi?id=444328
  	    // https://bugzilla.mozilla.org/show_bug.cgi?id=831392
  	    // https://code.google.com/p/chromium/issues/detail?id=260144
  	    // https://code.google.com/p/chromium/issues/detail?id=225654
  	    // ...
  	    R = EventSourcePolyfill;
  	  }

  	  (function (factory) {
  	    {
  	      var v = factory(exports);
  	      if (v !== undefined) module.exports = v;
  	    }
  	  })(function (exports) {
  	    exports.EventSourcePolyfill = EventSourcePolyfill;
  	    exports.NativeEventSource = NativeEventSource;
  	    exports.EventSource = R;
  	  });
  	}(typeof globalThis === 'undefined' ? (typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : commonjsGlobal) : globalThis));
  } (eventsource, eventsourceExports));

  /* eslint-disable no-var */

  var evs = eventsourceExports;

  var browser = evs.EventSourcePolyfill;

  var pick = (obj, props) =>
    props.reduce((selection, prop) => {
      if (typeof obj[prop] === 'undefined') {
        return selection
      }

      selection[prop] = obj[prop];
      return selection
    }, {});

  var defaults = (obj, defaults) =>
    Object.keys(defaults)
      .concat(Object.keys(obj))
      .reduce((target, prop) => {
        target[prop] = typeof obj[prop] === 'undefined' ? defaults[prop] : obj[prop];

        return target
      }, {});

  /******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  /* global Reflect, Promise */

  var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
      return extendStatics(d, b);
  };

  function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  function __values(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
          next: function () {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
          }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }

  function __read(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      }
      catch (error) { e = { error: error }; }
      finally {
          try {
              if (r && !r.done && (m = i["return"])) m.call(i);
          }
          finally { if (e) throw e.error; }
      }
      return ar;
  }

  function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
          }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
  }

  function isFunction(value) {
      return typeof value === 'function';
  }

  function createErrorClass(createImpl) {
      var _super = function (instance) {
          Error.call(instance);
          instance.stack = new Error().stack;
      };
      var ctorFunc = createImpl(_super);
      ctorFunc.prototype = Object.create(Error.prototype);
      ctorFunc.prototype.constructor = ctorFunc;
      return ctorFunc;
  }

  var UnsubscriptionError = createErrorClass(function (_super) {
      return function UnsubscriptionErrorImpl(errors) {
          _super(this);
          this.message = errors
              ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ')
              : '';
          this.name = 'UnsubscriptionError';
          this.errors = errors;
      };
  });

  function arrRemove(arr, item) {
      if (arr) {
          var index = arr.indexOf(item);
          0 <= index && arr.splice(index, 1);
      }
  }

  var Subscription = (function () {
      function Subscription(initialTeardown) {
          this.initialTeardown = initialTeardown;
          this.closed = false;
          this._parentage = null;
          this._finalizers = null;
      }
      Subscription.prototype.unsubscribe = function () {
          var e_1, _a, e_2, _b;
          var errors;
          if (!this.closed) {
              this.closed = true;
              var _parentage = this._parentage;
              if (_parentage) {
                  this._parentage = null;
                  if (Array.isArray(_parentage)) {
                      try {
                          for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                              var parent_1 = _parentage_1_1.value;
                              parent_1.remove(this);
                          }
                      }
                      catch (e_1_1) { e_1 = { error: e_1_1 }; }
                      finally {
                          try {
                              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
                          }
                          finally { if (e_1) throw e_1.error; }
                      }
                  }
                  else {
                      _parentage.remove(this);
                  }
              }
              var initialFinalizer = this.initialTeardown;
              if (isFunction(initialFinalizer)) {
                  try {
                      initialFinalizer();
                  }
                  catch (e) {
                      errors = e instanceof UnsubscriptionError ? e.errors : [e];
                  }
              }
              var _finalizers = this._finalizers;
              if (_finalizers) {
                  this._finalizers = null;
                  try {
                      for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                          var finalizer = _finalizers_1_1.value;
                          try {
                              execFinalizer(finalizer);
                          }
                          catch (err) {
                              errors = errors !== null && errors !== void 0 ? errors : [];
                              if (err instanceof UnsubscriptionError) {
                                  errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                              }
                              else {
                                  errors.push(err);
                              }
                          }
                      }
                  }
                  catch (e_2_1) { e_2 = { error: e_2_1 }; }
                  finally {
                      try {
                          if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
                      }
                      finally { if (e_2) throw e_2.error; }
                  }
              }
              if (errors) {
                  throw new UnsubscriptionError(errors);
              }
          }
      };
      Subscription.prototype.add = function (teardown) {
          var _a;
          if (teardown && teardown !== this) {
              if (this.closed) {
                  execFinalizer(teardown);
              }
              else {
                  if (teardown instanceof Subscription) {
                      if (teardown.closed || teardown._hasParent(this)) {
                          return;
                      }
                      teardown._addParent(this);
                  }
                  (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
              }
          }
      };
      Subscription.prototype._hasParent = function (parent) {
          var _parentage = this._parentage;
          return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));
      };
      Subscription.prototype._addParent = function (parent) {
          var _parentage = this._parentage;
          this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
      };
      Subscription.prototype._removeParent = function (parent) {
          var _parentage = this._parentage;
          if (_parentage === parent) {
              this._parentage = null;
          }
          else if (Array.isArray(_parentage)) {
              arrRemove(_parentage, parent);
          }
      };
      Subscription.prototype.remove = function (teardown) {
          var _finalizers = this._finalizers;
          _finalizers && arrRemove(_finalizers, teardown);
          if (teardown instanceof Subscription) {
              teardown._removeParent(this);
          }
      };
      Subscription.EMPTY = (function () {
          var empty = new Subscription();
          empty.closed = true;
          return empty;
      })();
      return Subscription;
  }());
  Subscription.EMPTY;
  function isSubscription(value) {
      return (value instanceof Subscription ||
          (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe)));
  }
  function execFinalizer(finalizer) {
      if (isFunction(finalizer)) {
          finalizer();
      }
      else {
          finalizer.unsubscribe();
      }
  }

  var config = {
      onUnhandledError: null,
      onStoppedNotification: null,
      Promise: undefined,
      useDeprecatedSynchronousErrorHandling: false,
      useDeprecatedNextContext: false,
  };

  var timeoutProvider = {
      setTimeout: function (handler, timeout) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
              args[_i - 2] = arguments[_i];
          }
          var delegate = timeoutProvider.delegate;
          if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
              return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
          }
          return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
      },
      clearTimeout: function (handle) {
          var delegate = timeoutProvider.delegate;
          return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
      },
      delegate: undefined,
  };

  function reportUnhandledError(err) {
      timeoutProvider.setTimeout(function () {
          {
              throw err;
          }
      });
  }

  function noop() { }

  var context = null;
  function errorContext(cb) {
      if (config.useDeprecatedSynchronousErrorHandling) {
          var isRoot = !context;
          if (isRoot) {
              context = { errorThrown: false, error: null };
          }
          cb();
          if (isRoot) {
              var _a = context, errorThrown = _a.errorThrown, error = _a.error;
              context = null;
              if (errorThrown) {
                  throw error;
              }
          }
      }
      else {
          cb();
      }
  }

  var Subscriber = (function (_super) {
      __extends(Subscriber, _super);
      function Subscriber(destination) {
          var _this = _super.call(this) || this;
          _this.isStopped = false;
          if (destination) {
              _this.destination = destination;
              if (isSubscription(destination)) {
                  destination.add(_this);
              }
          }
          else {
              _this.destination = EMPTY_OBSERVER;
          }
          return _this;
      }
      Subscriber.create = function (next, error, complete) {
          return new SafeSubscriber(next, error, complete);
      };
      Subscriber.prototype.next = function (value) {
          if (this.isStopped) ;
          else {
              this._next(value);
          }
      };
      Subscriber.prototype.error = function (err) {
          if (this.isStopped) ;
          else {
              this.isStopped = true;
              this._error(err);
          }
      };
      Subscriber.prototype.complete = function () {
          if (this.isStopped) ;
          else {
              this.isStopped = true;
              this._complete();
          }
      };
      Subscriber.prototype.unsubscribe = function () {
          if (!this.closed) {
              this.isStopped = true;
              _super.prototype.unsubscribe.call(this);
              this.destination = null;
          }
      };
      Subscriber.prototype._next = function (value) {
          this.destination.next(value);
      };
      Subscriber.prototype._error = function (err) {
          try {
              this.destination.error(err);
          }
          finally {
              this.unsubscribe();
          }
      };
      Subscriber.prototype._complete = function () {
          try {
              this.destination.complete();
          }
          finally {
              this.unsubscribe();
          }
      };
      return Subscriber;
  }(Subscription));
  var _bind = Function.prototype.bind;
  function bind(fn, thisArg) {
      return _bind.call(fn, thisArg);
  }
  var ConsumerObserver = (function () {
      function ConsumerObserver(partialObserver) {
          this.partialObserver = partialObserver;
      }
      ConsumerObserver.prototype.next = function (value) {
          var partialObserver = this.partialObserver;
          if (partialObserver.next) {
              try {
                  partialObserver.next(value);
              }
              catch (error) {
                  handleUnhandledError(error);
              }
          }
      };
      ConsumerObserver.prototype.error = function (err) {
          var partialObserver = this.partialObserver;
          if (partialObserver.error) {
              try {
                  partialObserver.error(err);
              }
              catch (error) {
                  handleUnhandledError(error);
              }
          }
          else {
              handleUnhandledError(err);
          }
      };
      ConsumerObserver.prototype.complete = function () {
          var partialObserver = this.partialObserver;
          if (partialObserver.complete) {
              try {
                  partialObserver.complete();
              }
              catch (error) {
                  handleUnhandledError(error);
              }
          }
      };
      return ConsumerObserver;
  }());
  var SafeSubscriber = (function (_super) {
      __extends(SafeSubscriber, _super);
      function SafeSubscriber(observerOrNext, error, complete) {
          var _this = _super.call(this) || this;
          var partialObserver;
          if (isFunction(observerOrNext) || !observerOrNext) {
              partialObserver = {
                  next: (observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined),
                  error: error !== null && error !== void 0 ? error : undefined,
                  complete: complete !== null && complete !== void 0 ? complete : undefined,
              };
          }
          else {
              var context_1;
              if (_this && config.useDeprecatedNextContext) {
                  context_1 = Object.create(observerOrNext);
                  context_1.unsubscribe = function () { return _this.unsubscribe(); };
                  partialObserver = {
                      next: observerOrNext.next && bind(observerOrNext.next, context_1),
                      error: observerOrNext.error && bind(observerOrNext.error, context_1),
                      complete: observerOrNext.complete && bind(observerOrNext.complete, context_1),
                  };
              }
              else {
                  partialObserver = observerOrNext;
              }
          }
          _this.destination = new ConsumerObserver(partialObserver);
          return _this;
      }
      return SafeSubscriber;
  }(Subscriber));
  function handleUnhandledError(error) {
      {
          reportUnhandledError(error);
      }
  }
  function defaultErrorHandler(err) {
      throw err;
  }
  var EMPTY_OBSERVER = {
      closed: true,
      next: noop,
      error: defaultErrorHandler,
      complete: noop,
  };

  var observable = (function () { return (typeof Symbol === 'function' && Symbol.observable) || '@@observable'; })();

  function identity(x) {
      return x;
  }

  function pipeFromArray(fns) {
      if (fns.length === 0) {
          return identity;
      }
      if (fns.length === 1) {
          return fns[0];
      }
      return function piped(input) {
          return fns.reduce(function (prev, fn) { return fn(prev); }, input);
      };
  }

  var Observable = (function () {
      function Observable(subscribe) {
          if (subscribe) {
              this._subscribe = subscribe;
          }
      }
      Observable.prototype.lift = function (operator) {
          var observable = new Observable();
          observable.source = this;
          observable.operator = operator;
          return observable;
      };
      Observable.prototype.subscribe = function (observerOrNext, error, complete) {
          var _this = this;
          var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
          errorContext(function () {
              var _a = _this, operator = _a.operator, source = _a.source;
              subscriber.add(operator
                  ?
                      operator.call(subscriber, source)
                  : source
                      ?
                          _this._subscribe(subscriber)
                      :
                          _this._trySubscribe(subscriber));
          });
          return subscriber;
      };
      Observable.prototype._trySubscribe = function (sink) {
          try {
              return this._subscribe(sink);
          }
          catch (err) {
              sink.error(err);
          }
      };
      Observable.prototype.forEach = function (next, promiseCtor) {
          var _this = this;
          promiseCtor = getPromiseCtor(promiseCtor);
          return new promiseCtor(function (resolve, reject) {
              var subscriber = new SafeSubscriber({
                  next: function (value) {
                      try {
                          next(value);
                      }
                      catch (err) {
                          reject(err);
                          subscriber.unsubscribe();
                      }
                  },
                  error: reject,
                  complete: resolve,
              });
              _this.subscribe(subscriber);
          });
      };
      Observable.prototype._subscribe = function (subscriber) {
          var _a;
          return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
      };
      Observable.prototype[observable] = function () {
          return this;
      };
      Observable.prototype.pipe = function () {
          var operations = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              operations[_i] = arguments[_i];
          }
          return pipeFromArray(operations)(this);
      };
      Observable.prototype.toPromise = function (promiseCtor) {
          var _this = this;
          promiseCtor = getPromiseCtor(promiseCtor);
          return new promiseCtor(function (resolve, reject) {
              var value;
              _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });
          });
      };
      Observable.create = function (subscribe) {
          return new Observable(subscribe);
      };
      return Observable;
  }());
  function getPromiseCtor(promiseCtor) {
      var _a;
      return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
  }
  function isObserver(value) {
      return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
  }
  function isSubscriber(value) {
      return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));
  }

  function hasLift(source) {
      return isFunction(source === null || source === void 0 ? void 0 : source.lift);
  }
  function operate(init) {
      return function (source) {
          if (hasLift(source)) {
              return source.lift(function (liftedSource) {
                  try {
                      return init(liftedSource, this);
                  }
                  catch (err) {
                      this.error(err);
                  }
              });
          }
          throw new TypeError('Unable to lift unknown Observable type');
      };
  }

  function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
      return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
  }
  var OperatorSubscriber = (function (_super) {
      __extends(OperatorSubscriber, _super);
      function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
          var _this = _super.call(this, destination) || this;
          _this.onFinalize = onFinalize;
          _this.shouldUnsubscribe = shouldUnsubscribe;
          _this._next = onNext
              ? function (value) {
                  try {
                      onNext(value);
                  }
                  catch (err) {
                      destination.error(err);
                  }
              }
              : _super.prototype._next;
          _this._error = onError
              ? function (err) {
                  try {
                      onError(err);
                  }
                  catch (err) {
                      destination.error(err);
                  }
                  finally {
                      this.unsubscribe();
                  }
              }
              : _super.prototype._error;
          _this._complete = onComplete
              ? function () {
                  try {
                      onComplete();
                  }
                  catch (err) {
                      destination.error(err);
                  }
                  finally {
                      this.unsubscribe();
                  }
              }
              : _super.prototype._complete;
          return _this;
      }
      OperatorSubscriber.prototype.unsubscribe = function () {
          var _a;
          if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
              var closed_1 = this.closed;
              _super.prototype.unsubscribe.call(this);
              !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
          }
      };
      return OperatorSubscriber;
  }(Subscriber));

  var EmptyError = createErrorClass(function (_super) { return function EmptyErrorImpl() {
      _super(this);
      this.name = 'EmptyError';
      this.message = 'no elements in sequence';
  }; });

  function lastValueFrom(source, config) {
      var hasConfig = typeof config === 'object';
      return new Promise(function (resolve, reject) {
          var _hasValue = false;
          var _value;
          source.subscribe({
              next: function (value) {
                  _value = value;
                  _hasValue = true;
              },
              error: reject,
              complete: function () {
                  if (_hasValue) {
                      resolve(_value);
                  }
                  else if (hasConfig) {
                      resolve(config.defaultValue);
                  }
                  else {
                      reject(new EmptyError());
                  }
              },
          });
      });
  }

  function map(project, thisArg) {
      return operate(function (source, subscriber) {
          var index = 0;
          source.subscribe(createOperatorSubscriber(subscriber, function (value) {
              subscriber.next(project.call(thisArg, value, index++));
          }));
      });
  }

  function filter(predicate, thisArg) {
      return operate(function (source, subscriber) {
          var index = 0;
          source.subscribe(createOperatorSubscriber(subscriber, function (value) { return predicate.call(thisArg, value, index++) && subscriber.next(value); }));
      });
  }

  // Limit is 16K for a _request_, eg including headers. Have to account for an
  // unknown range of headers, but an average EventSource request from Chrome seems
  // to have around 700 bytes of cruft, so let us account for 1.2K to be "safe"
  const MAX_URL_LENGTH = 16000 - 1200;
  const EventSource = browser;

  const possibleOptions = [
    'includePreviousRevision',
    'includeResult',
    'visibility',
    'effectFormat',
    'tag',
  ];

  const defaultOptions = {
    includeResult: true,
  };

  function listen(query, params, opts = {}) {
    const {url, token, withCredentials, requestTagPrefix} = this.clientConfig;
    const tag = opts.tag && requestTagPrefix ? [requestTagPrefix, opts.tag].join('.') : opts.tag;
    const options = {...defaults(opts, defaultOptions), tag};
    const listenOpts = pick(options, possibleOptions);
    const qs = encodeQueryString({query, params, options: listenOpts, tag});

    const uri = `${url}${this.getDataUrl('listen', qs)}`;
    if (uri.length > MAX_URL_LENGTH) {
      return new Observable((observer) => observer.error(new Error('Query too large for listener')))
    }

    const listenFor = options.events ? options.events : ['mutation'];
    const shouldEmitReconnect = listenFor.indexOf('reconnect') !== -1;

    const esOptions = {};
    if (token || withCredentials) {
      esOptions.withCredentials = true;
    }

    if (token) {
      esOptions.headers = {
        Authorization: `Bearer ${token}`,
      };
    }

    return new Observable((observer) => {
      let es = getEventSource();
      let reconnectTimer;
      let stopped = false;

      function onError() {
        if (stopped) {
          return
        }

        emitReconnect();

        // Allow event handlers of `emitReconnect` to cancel/close the reconnect attempt
        if (stopped) {
          return
        }

        // Unless we've explicitly stopped the ES (in which case `stopped` should be true),
        // we should never be in a disconnected state. By default, EventSource will reconnect
        // automatically, in which case it sets readyState to `CONNECTING`, but in some cases
        // (like when a laptop lid is closed), it closes the connection. In these cases we need
        // to explicitly reconnect.
        if (es.readyState === EventSource.CLOSED) {
          unsubscribe();
          clearTimeout(reconnectTimer);
          reconnectTimer = setTimeout(open, 100);
        }
      }

      function onChannelError(err) {
        observer.error(cooerceError(err));
      }

      function onMessage(evt) {
        const event = parseEvent(evt);
        return event instanceof Error ? observer.error(event) : observer.next(event)
      }

      function onDisconnect(evt) {
        stopped = true;
        unsubscribe();
        observer.complete();
      }

      function unsubscribe() {
        es.removeEventListener('error', onError, false);
        es.removeEventListener('channelError', onChannelError, false);
        es.removeEventListener('disconnect', onDisconnect, false);
        listenFor.forEach((type) => es.removeEventListener(type, onMessage, false));
        es.close();
      }

      function emitReconnect() {
        if (shouldEmitReconnect) {
          observer.next({type: 'reconnect'});
        }
      }

      function getEventSource() {
        const evs = new EventSource(uri, esOptions);
        evs.addEventListener('error', onError, false);
        evs.addEventListener('channelError', onChannelError, false);
        evs.addEventListener('disconnect', onDisconnect, false);
        listenFor.forEach((type) => evs.addEventListener(type, onMessage, false));
        return evs
      }

      function open() {
        es = getEventSource();
      }

      function stop() {
        stopped = true;
        unsubscribe();
      }

      return stop
    })
  }

  function parseEvent(event) {
    try {
      const data = (event.data && JSON.parse(event.data)) || {};
      return Object.assign({type: event.type}, data)
    } catch (err) {
      return err
    }
  }

  function cooerceError(err) {
    if (err instanceof Error) {
      return err
    }

    const evt = parseEvent(err);
    return evt instanceof Error ? evt : new Error(extractErrorMessage(evt))
  }

  function extractErrorMessage(err) {
    if (!err.error) {
      return err.message || 'Unknown listener error'
    }

    if (err.error.description) {
      return err.error.description
    }

    return typeof err.error === 'string' ? err.error : JSON.stringify(err.error, null, 2)
  }

  const excludeFalsey = (param, defValue) => {
    const value = typeof param === 'undefined' ? defValue : param;
    return param === false ? undefined : value
  };

  const getMutationQuery = (options = {}) => {
    return {
      dryRun: options.dryRun,
      returnIds: true,
      returnDocuments: excludeFalsey(options.returnDocuments, true),
      visibility: options.visibility || 'sync',
      autoGenerateArrayKeys: options.autoGenerateArrayKeys,
      skipCrossDatasetReferenceValidation: options.skipCrossDatasetReferenceValidation,
    }
  };

  const isResponse = (event) => event.type === 'response';
  const getBody = (event) => event.body;

  const indexBy = (docs, attr) =>
    docs.reduce((indexed, doc) => {
      indexed[attr(doc)] = doc;
      return indexed
    }, Object.create(null));

  const getQuerySizeLimit = 11264;

  var dataMethods = {
    listen: listen,

    getDataUrl(operation, path) {
      const config = this.clientConfig;
      const catalog = hasDataset(config);
      const baseUri = `/${operation}/${catalog}`;
      const uri = path ? `${baseUri}/${path}` : baseUri;
      return `/data${uri}`.replace(/\/($|\?)/, '$1')
    },

    fetch(query, params, options = {}) {
      const mapResponse = options.filterResponse === false ? (res) => res : (res) => res.result;

      const observable = this._dataRequest('query', {query, params}, options).pipe(map(mapResponse));
      return this.isPromiseAPI() ? lastValueFrom(observable) : observable
    },

    getDocument(id, opts = {}) {
      const options = {uri: this.getDataUrl('doc', id), json: true, tag: opts.tag};
      const observable = this._requestObservable(options).pipe(
        filter(isResponse),
        map((event) => event.body.documents && event.body.documents[0])
      );

      return this.isPromiseAPI() ? lastValueFrom(observable) : observable
    },

    getDocuments(ids, opts = {}) {
      const options = {uri: this.getDataUrl('doc', ids.join(',')), json: true, tag: opts.tag};
      const observable = this._requestObservable(options).pipe(
        filter(isResponse),
        map((event) => {
          const indexed = indexBy(event.body.documents || [], (doc) => doc._id);
          return ids.map((id) => indexed[id] || null)
        })
      );

      return this.isPromiseAPI() ? lastValueFrom(observable) : observable
    },

    create(doc, options) {
      return this._create(doc, 'create', options)
    },

    createIfNotExists(doc, options) {
      requireDocumentId('createIfNotExists', doc);
      return this._create(doc, 'createIfNotExists', options)
    },

    createOrReplace(doc, options) {
      requireDocumentId('createOrReplace', doc);
      return this._create(doc, 'createOrReplace', options)
    },

    patch(selector, operations) {
      return new Patch(selector, operations, this)
    },

    delete(selection, options) {
      return this.dataRequest('mutate', {mutations: [{delete: getSelection(selection)}]}, options)
    },

    mutate(mutations, options) {
      const mut =
        mutations instanceof Patch || mutations instanceof Transaction
          ? mutations.serialize()
          : mutations;

      const muts = Array.isArray(mut) ? mut : [mut];
      const transactionId = options && options.transactionId;
      return this.dataRequest('mutate', {mutations: muts, transactionId}, options)
    },

    transaction(operations) {
      return new Transaction(operations, this)
    },

    dataRequest(endpoint, body, options = {}) {
      const request = this._dataRequest(endpoint, body, options);

      return this.isPromiseAPI() ? lastValueFrom(request) : request
    },

    _dataRequest(endpoint, body, options = {}) {
      const isMutation = endpoint === 'mutate';
      const isQuery = endpoint === 'query';

      // Check if the query string is within a configured threshold,
      // in which case we can use GET. Otherwise, use POST.
      const strQuery = !isMutation && encodeQueryString(body);
      const useGet = !isMutation && strQuery.length < getQuerySizeLimit;
      const stringQuery = useGet ? strQuery : '';
      const returnFirst = options.returnFirst;
      const {timeout, token, tag, headers} = options;

      const uri = this.getDataUrl(endpoint, stringQuery);

      const reqOptions = {
        method: useGet ? 'GET' : 'POST',
        uri: uri,
        json: true,
        body: useGet ? undefined : body,
        query: isMutation && getMutationQuery(options),
        timeout,
        headers,
        token,
        tag,
        canUseCdn: isQuery,
      };

      return this._requestObservable(reqOptions).pipe(
        filter(isResponse),
        map(getBody),
        map((res) => {
          if (!isMutation) {
            return res
          }

          // Should we return documents?
          const results = res.results || [];
          if (options.returnDocuments) {
            return returnFirst
              ? results[0] && results[0].document
              : results.map((mut) => mut.document)
          }

          // Return a reduced subset
          const key = returnFirst ? 'documentId' : 'documentIds';
          const ids = returnFirst ? results[0] && results[0].id : results.map((mut) => mut.id);
          return {
            transactionId: res.transactionId,
            results: results,
            [key]: ids,
          }
        })
      )
    },

    _create(doc, op, options = {}) {
      const mutation = {[op]: doc};
      const opts = Object.assign({returnFirst: true, returnDocuments: true}, options);
      return this.dataRequest('mutate', {mutations: [mutation]}, opts)
    },
  };

  function DatasetsClient(client) {
    this.request = client.request.bind(client);
  }

  Object.assign(DatasetsClient.prototype, {
    create(name, options) {
      return this._modify('PUT', name, options)
    },

    edit(name, options) {
      return this._modify('PATCH', name, options)
    },

    delete(name) {
      return this._modify('DELETE', name)
    },

    list() {
      return this.request({uri: '/datasets'})
    },

    _modify(method, name, body) {
      dataset(name);
      return this.request({method, uri: `/datasets/${name}`, body})
    },
  });

  function ProjectsClient(client) {
    this.client = client;
  }

  Object.assign(ProjectsClient.prototype, {
    list() {
      return this.client.request({uri: '/projects'})
    },

    getById(id) {
      return this.client.request({uri: `/projects/${id}`})
    },
  });

  var queryString = (params) => {
    const qs = [];
    for (const key in params) {
      if (params.hasOwnProperty(key)) {
        qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`);
      }
    }

    return qs.length > 0 ? `?${qs.join('&')}` : ''
  };

  function AssetsClient(client) {
    this.client = client;
  }

  function optionsFromFile(opts, file) {
    if (typeof window === 'undefined' || !(file instanceof window.File)) {
      return opts
    }

    return Object.assign(
      {
        filename: opts.preserveFilename === false ? undefined : file.name,
        contentType: file.type,
      },
      opts
    )
  }

  Object.assign(AssetsClient.prototype, {
    /**
     * Upload an asset
     *
     * @param  {String} assetType `image` or `file`
     * @param  {File|Blob|Buffer|ReadableStream} body File to upload
     * @param  {Object}  opts Options for the upload
     * @param  {Boolean} opts.preserveFilename Whether or not to preserve the original filename (default: true)
     * @param  {String}  opts.filename Filename for this file (optional)
     * @param  {Number}  opts.timeout  Milliseconds to wait before timing the request out (default: 0)
     * @param  {String}  opts.contentType Mime type of the file
     * @param  {Array}   opts.extract Array of metadata parts to extract from image.
     *                                 Possible values: `location`, `exif`, `image`, `palette`
     * @param  {String}  opts.label Label
     * @param  {String}  opts.title Title
     * @param  {String}  opts.description Description
     * @param  {String}  opts.creditLine The credit to person(s) and/or organization(s) required by the supplier of the image to be used when published
     * @param  {Object}  opts.source Source data (when the asset is from an external service)
     * @param  {String}  opts.source.id The (u)id of the asset within the source, i.e. 'i-f323r1E'
     *                                  Required if source is defined
     * @param  {String}  opts.source.name The name of the source, i.e. 'unsplash'
     *                                  Required if source is defined
     * @param  {String}  opts.source.url A url to where to find the asset, or get more info about it in the source
     *                                  Optional
     * @return {Promise} Resolves with the created asset document
     */
    upload(assetType, body, opts = {}) {
      validateAssetType(assetType);

      // If an empty array is given, explicitly set `none` to override API defaults
      let meta = opts.extract || undefined;
      if (meta && !meta.length) {
        meta = ['none'];
      }

      const dataset = hasDataset(this.client.clientConfig);
      const assetEndpoint = assetType === 'image' ? 'images' : 'files';
      const options = optionsFromFile(opts, body);
      const {tag, label, title, description, creditLine, filename, source} = options;
      const query = {
        label,
        title,
        description,
        filename,
        meta,
        creditLine,
      };
      if (source) {
        query.sourceId = source.id;
        query.sourceName = source.name;
        query.sourceUrl = source.url;
      }
      const observable = this.client._requestObservable({
        tag,
        method: 'POST',
        timeout: options.timeout || 0,
        uri: `/assets/${assetEndpoint}/${dataset}`,
        headers: options.contentType ? {'Content-Type': options.contentType} : {},
        query,
        body,
      });

      return this.client.isPromiseAPI()
        ? lastValueFrom(
            observable.pipe(
              filter((event) => event.type === 'response'),
              map((event) => event.body.document)
            )
          )
        : observable
    },

    delete(type, id) {
      // eslint-disable-next-line no-console
      console.warn('client.assets.delete() is deprecated, please use client.delete(<document-id>)');

      let docId = id || '';
      if (!/^(image|file)-/.test(docId)) {
        docId = `${type}-${docId}`;
      } else if (type._id) {
        // We could be passing an entire asset document instead of an ID
        docId = type._id;
      }

      hasDataset(this.client.clientConfig);
      return this.client.delete(docId)
    },

    getImageUrl(ref, query) {
      const id = ref._ref || ref;
      if (typeof id !== 'string') {
        throw new Error(
          'getImageUrl() needs either an object with a _ref, or a string with an asset document ID'
        )
      }

      if (!/^image-[A-Za-z0-9_]+-\d+x\d+-[a-z]{1,5}$/.test(id)) {
        throw new Error(
          `Unsupported asset ID "${id}". URL generation only works for auto-generated IDs.`
        )
      }

      const [, assetId, size, format] = id.split('-');

      hasDataset(this.client.clientConfig);
      const {projectId, dataset} = this.client.clientConfig;
      const qs = query ? queryString(query) : '';
      return `https://cdn.sanity.io/images/${projectId}/${dataset}/${assetId}-${size}.${format}${qs}`
    },
  });

  function UsersClient(client) {
    this.client = client;
  }

  Object.assign(UsersClient.prototype, {
    getById(id) {
      return this.client.request({uri: `/users/${id}`})
    },
  });

  function AuthClient(client) {
    this.client = client;
  }

  Object.assign(AuthClient.prototype, {
    getLoginProviders() {
      return this.client.request({uri: '/auth/providers'})
    },

    logout() {
      return this.client.request({uri: '/auth/logout', method: 'POST'})
    },
  });

  var libExports = {};
  var lib = {
    get exports(){ return libExports; },
    set exports(v){ libExports = v; },
  };

  function createPubSub() {
      var subscribers = Object.create(null);
      var nextId = 0;
      function subscribe(subscriber) {
          var id = nextId++;
          subscribers[id] = subscriber;
          return function unsubscribe() {
              delete subscribers[id];
          };
      }
      function publish(event) {
          for (var id in subscribers) {
              subscribers[id](event);
          }
      }
      return {
          publish: publish,
          subscribe: subscribe,
      };
  }

  var esm = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: createPubSub
  });

  var require$$0 = /*@__PURE__*/getAugmentedNamespace(esm);

  var middlewareReducerExports = {};
  var middlewareReducer = {
    get exports(){ return middlewareReducerExports; },
    set exports(v){ middlewareReducerExports = v; },
  };

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = void 0;

  	var _default = function _default(middleware) {
  	  var applyMiddleware = function applyMiddleware(hook, defaultValue) {
  	    var bailEarly = hook === 'onError';
  	    var value = defaultValue;

  	    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
  	      args[_key - 2] = arguments[_key];
  	    }

  	    for (var i = 0; i < middleware[hook].length; i++) {
  	      var handler = middleware[hook][i];
  	      value = handler.apply(void 0, [value].concat(args));

  	      if (bailEarly && !value) {
  	        break;
  	      }
  	    }

  	    return value;
  	  };

  	  return applyMiddleware;
  	};

  	exports.default = _default;
  	module.exports = exports.default;
  	
  } (middlewareReducer, middlewareReducerExports));

  var defaultOptionsProcessorExports = {};
  var defaultOptionsProcessor = {
    get exports(){ return defaultOptionsProcessorExports; },
    set exports(v){ defaultOptionsProcessorExports = v; },
  };

  /**
   * Check if we're required to add a port number.
   *
   * @see https://url.spec.whatwg.org/#default-port
   * @param {Number|String} port Port number we need to check
   * @param {String} protocol Protocol we need to check against.
   * @returns {Boolean} Is it a default port for the given protocol
   * @api private
   */
  var requiresPort = function required(port, protocol) {
    protocol = protocol.split(':')[0];
    port = +port;

    if (!port) return false;

    switch (protocol) {
      case 'http':
      case 'ws':
      return port !== 80;

      case 'https':
      case 'wss':
      return port !== 443;

      case 'ftp':
      return port !== 21;

      case 'gopher':
      return port !== 70;

      case 'file':
      return false;
    }

    return port !== 0;
  };

  var querystringify$1 = {};

  var has = Object.prototype.hasOwnProperty
    , undef;

  /**
   * Decode a URI encoded string.
   *
   * @param {String} input The URI encoded string.
   * @returns {String|Null} The decoded string.
   * @api private
   */
  function decode(input) {
    try {
      return decodeURIComponent(input.replace(/\+/g, ' '));
    } catch (e) {
      return null;
    }
  }

  /**
   * Attempts to encode a given input.
   *
   * @param {String} input The string that needs to be encoded.
   * @returns {String|Null} The encoded string.
   * @api private
   */
  function encode(input) {
    try {
      return encodeURIComponent(input);
    } catch (e) {
      return null;
    }
  }

  /**
   * Simple query string parser.
   *
   * @param {String} query The query string that needs to be parsed.
   * @returns {Object}
   * @api public
   */
  function querystring(query) {
    var parser = /([^=?#&]+)=?([^&]*)/g
      , result = {}
      , part;

    while (part = parser.exec(query)) {
      var key = decode(part[1])
        , value = decode(part[2]);

      //
      // Prevent overriding of existing properties. This ensures that build-in
      // methods like `toString` or __proto__ are not overriden by malicious
      // querystrings.
      //
      // In the case if failed decoding, we want to omit the key/value pairs
      // from the result.
      //
      if (key === null || value === null || key in result) continue;
      result[key] = value;
    }

    return result;
  }

  /**
   * Transform a query string to an object.
   *
   * @param {Object} obj Object that should be transformed.
   * @param {String} prefix Optional prefix.
   * @returns {String}
   * @api public
   */
  function querystringify(obj, prefix) {
    prefix = prefix || '';

    var pairs = []
      , value
      , key;

    //
    // Optionally prefix with a '?' if needed
    //
    if ('string' !== typeof prefix) prefix = '?';

    for (key in obj) {
      if (has.call(obj, key)) {
        value = obj[key];

        //
        // Edge cases where we actually want to encode the value to an empty
        // string instead of the stringified value.
        //
        if (!value && (value === null || value === undef || isNaN(value))) {
          value = '';
        }

        key = encode(key);
        value = encode(value);

        //
        // If we failed to encode the strings, we should bail out as we don't
        // want to add invalid strings to the query.
        //
        if (key === null || value === null) continue;
        pairs.push(key +'='+ value);
      }
    }

    return pairs.length ? prefix + pairs.join('&') : '';
  }

  //
  // Expose the module.
  //
  querystringify$1.stringify = querystringify;
  querystringify$1.parse = querystring;

  var required = requiresPort
    , qs = querystringify$1
    , controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/
    , CRHTLF = /[\n\r\t]/g
    , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
    , port = /:\d+$/
    , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i
    , windowsDriveLetter = /^[a-zA-Z]:/;

  /**
   * Remove control characters and whitespace from the beginning of a string.
   *
   * @param {Object|String} str String to trim.
   * @returns {String} A new string representing `str` stripped of control
   *     characters and whitespace from its beginning.
   * @public
   */
  function trimLeft(str) {
    return (str ? str : '').toString().replace(controlOrWhitespace, '');
  }

  /**
   * These are the parse rules for the URL parser, it informs the parser
   * about:
   *
   * 0. The char it Needs to parse, if it's a string it should be done using
   *    indexOf, RegExp using exec and NaN means set as current value.
   * 1. The property we should set when parsing this value.
   * 2. Indication if it's backwards or forward parsing, when set as number it's
   *    the value of extra chars that should be split off.
   * 3. Inherit from location if non existing in the parser.
   * 4. `toLowerCase` the resulting value.
   */
  var rules = [
    ['#', 'hash'],                        // Extract from the back.
    ['?', 'query'],                       // Extract from the back.
    function sanitize(address, url) {     // Sanitize what is left of the address
      return isSpecial(url.protocol) ? address.replace(/\\/g, '/') : address;
    },
    ['/', 'pathname'],                    // Extract from the back.
    ['@', 'auth', 1],                     // Extract from the front.
    [NaN, 'host', undefined, 1, 1],       // Set left over value.
    [/:(\d*)$/, 'port', undefined, 1],    // RegExp the back.
    [NaN, 'hostname', undefined, 1, 1]    // Set left over.
  ];

  /**
   * These properties should not be copied or inherited from. This is only needed
   * for all non blob URL's as a blob URL does not include a hash, only the
   * origin.
   *
   * @type {Object}
   * @private
   */
  var ignore = { hash: 1, query: 1 };

  /**
   * The location object differs when your code is loaded through a normal page,
   * Worker or through a worker using a blob. And with the blobble begins the
   * trouble as the location object will contain the URL of the blob, not the
   * location of the page where our code is loaded in. The actual origin is
   * encoded in the `pathname` so we can thankfully generate a good "default"
   * location from it so we can generate proper relative URL's again.
   *
   * @param {Object|String} loc Optional default location object.
   * @returns {Object} lolcation object.
   * @public
   */
  function lolcation(loc) {
    var globalVar;

    if (typeof window !== 'undefined') globalVar = window;
    else if (typeof commonjsGlobal !== 'undefined') globalVar = commonjsGlobal;
    else if (typeof self !== 'undefined') globalVar = self;
    else globalVar = {};

    var location = globalVar.location || {};
    loc = loc || location;

    var finaldestination = {}
      , type = typeof loc
      , key;

    if ('blob:' === loc.protocol) {
      finaldestination = new Url(unescape(loc.pathname), {});
    } else if ('string' === type) {
      finaldestination = new Url(loc, {});
      for (key in ignore) delete finaldestination[key];
    } else if ('object' === type) {
      for (key in loc) {
        if (key in ignore) continue;
        finaldestination[key] = loc[key];
      }

      if (finaldestination.slashes === undefined) {
        finaldestination.slashes = slashes.test(loc.href);
      }
    }

    return finaldestination;
  }

  /**
   * Check whether a protocol scheme is special.
   *
   * @param {String} The protocol scheme of the URL
   * @return {Boolean} `true` if the protocol scheme is special, else `false`
   * @private
   */
  function isSpecial(scheme) {
    return (
      scheme === 'file:' ||
      scheme === 'ftp:' ||
      scheme === 'http:' ||
      scheme === 'https:' ||
      scheme === 'ws:' ||
      scheme === 'wss:'
    );
  }

  /**
   * @typedef ProtocolExtract
   * @type Object
   * @property {String} protocol Protocol matched in the URL, in lowercase.
   * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
   * @property {String} rest Rest of the URL that is not part of the protocol.
   */

  /**
   * Extract protocol information from a URL with/without double slash ("//").
   *
   * @param {String} address URL we want to extract from.
   * @param {Object} location
   * @return {ProtocolExtract} Extracted information.
   * @private
   */
  function extractProtocol(address, location) {
    address = trimLeft(address);
    address = address.replace(CRHTLF, '');
    location = location || {};

    var match = protocolre.exec(address);
    var protocol = match[1] ? match[1].toLowerCase() : '';
    var forwardSlashes = !!match[2];
    var otherSlashes = !!match[3];
    var slashesCount = 0;
    var rest;

    if (forwardSlashes) {
      if (otherSlashes) {
        rest = match[2] + match[3] + match[4];
        slashesCount = match[2].length + match[3].length;
      } else {
        rest = match[2] + match[4];
        slashesCount = match[2].length;
      }
    } else {
      if (otherSlashes) {
        rest = match[3] + match[4];
        slashesCount = match[3].length;
      } else {
        rest = match[4];
      }
    }

    if (protocol === 'file:') {
      if (slashesCount >= 2) {
        rest = rest.slice(2);
      }
    } else if (isSpecial(protocol)) {
      rest = match[4];
    } else if (protocol) {
      if (forwardSlashes) {
        rest = rest.slice(2);
      }
    } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
      rest = match[4];
    }

    return {
      protocol: protocol,
      slashes: forwardSlashes || isSpecial(protocol),
      slashesCount: slashesCount,
      rest: rest
    };
  }

  /**
   * Resolve a relative URL pathname against a base URL pathname.
   *
   * @param {String} relative Pathname of the relative URL.
   * @param {String} base Pathname of the base URL.
   * @return {String} Resolved pathname.
   * @private
   */
  function resolve(relative, base) {
    if (relative === '') return base;

    var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
      , i = path.length
      , last = path[i - 1]
      , unshift = false
      , up = 0;

    while (i--) {
      if (path[i] === '.') {
        path.splice(i, 1);
      } else if (path[i] === '..') {
        path.splice(i, 1);
        up++;
      } else if (up) {
        if (i === 0) unshift = true;
        path.splice(i, 1);
        up--;
      }
    }

    if (unshift) path.unshift('');
    if (last === '.' || last === '..') path.push('');

    return path.join('/');
  }

  /**
   * The actual URL instance. Instead of returning an object we've opted-in to
   * create an actual constructor as it's much more memory efficient and
   * faster and it pleases my OCD.
   *
   * It is worth noting that we should not use `URL` as class name to prevent
   * clashes with the global URL instance that got introduced in browsers.
   *
   * @constructor
   * @param {String} address URL we want to parse.
   * @param {Object|String} [location] Location defaults for relative paths.
   * @param {Boolean|Function} [parser] Parser for the query string.
   * @private
   */
  function Url(address, location, parser) {
    address = trimLeft(address);
    address = address.replace(CRHTLF, '');

    if (!(this instanceof Url)) {
      return new Url(address, location, parser);
    }

    var relative, extracted, parse, instruction, index, key
      , instructions = rules.slice()
      , type = typeof location
      , url = this
      , i = 0;

    //
    // The following if statements allows this module two have compatibility with
    // 2 different API:
    //
    // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
    //    where the boolean indicates that the query string should also be parsed.
    //
    // 2. The `URL` interface of the browser which accepts a URL, object as
    //    arguments. The supplied object will be used as default values / fall-back
    //    for relative paths.
    //
    if ('object' !== type && 'string' !== type) {
      parser = location;
      location = null;
    }

    if (parser && 'function' !== typeof parser) parser = qs.parse;

    location = lolcation(location);

    //
    // Extract protocol information before running the instructions.
    //
    extracted = extractProtocol(address || '', location);
    relative = !extracted.protocol && !extracted.slashes;
    url.slashes = extracted.slashes || relative && location.slashes;
    url.protocol = extracted.protocol || location.protocol || '';
    address = extracted.rest;

    //
    // When the authority component is absent the URL starts with a path
    // component.
    //
    if (
      extracted.protocol === 'file:' && (
        extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||
      (!extracted.slashes &&
        (extracted.protocol ||
          extracted.slashesCount < 2 ||
          !isSpecial(url.protocol)))
    ) {
      instructions[3] = [/(.*)/, 'pathname'];
    }

    for (; i < instructions.length; i++) {
      instruction = instructions[i];

      if (typeof instruction === 'function') {
        address = instruction(address, url);
        continue;
      }

      parse = instruction[0];
      key = instruction[1];

      if (parse !== parse) {
        url[key] = address;
      } else if ('string' === typeof parse) {
        index = parse === '@'
          ? address.lastIndexOf(parse)
          : address.indexOf(parse);

        if (~index) {
          if ('number' === typeof instruction[2]) {
            url[key] = address.slice(0, index);
            address = address.slice(index + instruction[2]);
          } else {
            url[key] = address.slice(index);
            address = address.slice(0, index);
          }
        }
      } else if ((index = parse.exec(address))) {
        url[key] = index[1];
        address = address.slice(0, index.index);
      }

      url[key] = url[key] || (
        relative && instruction[3] ? location[key] || '' : ''
      );

      //
      // Hostname, host and protocol should be lowercased so they can be used to
      // create a proper `origin`.
      //
      if (instruction[4]) url[key] = url[key].toLowerCase();
    }

    //
    // Also parse the supplied query string in to an object. If we're supplied
    // with a custom parser as function use that instead of the default build-in
    // parser.
    //
    if (parser) url.query = parser(url.query);

    //
    // If the URL is relative, resolve the pathname against the base URL.
    //
    if (
        relative
      && location.slashes
      && url.pathname.charAt(0) !== '/'
      && (url.pathname !== '' || location.pathname !== '')
    ) {
      url.pathname = resolve(url.pathname, location.pathname);
    }

    //
    // Default to a / for pathname if none exists. This normalizes the URL
    // to always have a /
    //
    if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {
      url.pathname = '/' + url.pathname;
    }

    //
    // We should not add port numbers if they are already the default port number
    // for a given protocol. As the host also contains the port number we're going
    // override it with the hostname which contains no port number.
    //
    if (!required(url.port, url.protocol)) {
      url.host = url.hostname;
      url.port = '';
    }

    //
    // Parse down the `auth` for the username and password.
    //
    url.username = url.password = '';

    if (url.auth) {
      index = url.auth.indexOf(':');

      if (~index) {
        url.username = url.auth.slice(0, index);
        url.username = encodeURIComponent(decodeURIComponent(url.username));

        url.password = url.auth.slice(index + 1);
        url.password = encodeURIComponent(decodeURIComponent(url.password));
      } else {
        url.username = encodeURIComponent(decodeURIComponent(url.auth));
      }

      url.auth = url.password ? url.username +':'+ url.password : url.username;
    }

    url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
      ? url.protocol +'//'+ url.host
      : 'null';

    //
    // The href is just the compiled result.
    //
    url.href = url.toString();
  }

  /**
   * This is convenience method for changing properties in the URL instance to
   * insure that they all propagate correctly.
   *
   * @param {String} part          Property we need to adjust.
   * @param {Mixed} value          The newly assigned value.
   * @param {Boolean|Function} fn  When setting the query, it will be the function
   *                               used to parse the query.
   *                               When setting the protocol, double slash will be
   *                               removed from the final url if it is true.
   * @returns {URL} URL instance for chaining.
   * @public
   */
  function set(part, value, fn) {
    var url = this;

    switch (part) {
      case 'query':
        if ('string' === typeof value && value.length) {
          value = (fn || qs.parse)(value);
        }

        url[part] = value;
        break;

      case 'port':
        url[part] = value;

        if (!required(value, url.protocol)) {
          url.host = url.hostname;
          url[part] = '';
        } else if (value) {
          url.host = url.hostname +':'+ value;
        }

        break;

      case 'hostname':
        url[part] = value;

        if (url.port) value += ':'+ url.port;
        url.host = value;
        break;

      case 'host':
        url[part] = value;

        if (port.test(value)) {
          value = value.split(':');
          url.port = value.pop();
          url.hostname = value.join(':');
        } else {
          url.hostname = value;
          url.port = '';
        }

        break;

      case 'protocol':
        url.protocol = value.toLowerCase();
        url.slashes = !fn;
        break;

      case 'pathname':
      case 'hash':
        if (value) {
          var char = part === 'pathname' ? '/' : '#';
          url[part] = value.charAt(0) !== char ? char + value : value;
        } else {
          url[part] = value;
        }
        break;

      case 'username':
      case 'password':
        url[part] = encodeURIComponent(value);
        break;

      case 'auth':
        var index = value.indexOf(':');

        if (~index) {
          url.username = value.slice(0, index);
          url.username = encodeURIComponent(decodeURIComponent(url.username));

          url.password = value.slice(index + 1);
          url.password = encodeURIComponent(decodeURIComponent(url.password));
        } else {
          url.username = encodeURIComponent(decodeURIComponent(value));
        }
    }

    for (var i = 0; i < rules.length; i++) {
      var ins = rules[i];

      if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
    }

    url.auth = url.password ? url.username +':'+ url.password : url.username;

    url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
      ? url.protocol +'//'+ url.host
      : 'null';

    url.href = url.toString();

    return url;
  }

  /**
   * Transform the properties back in to a valid and full URL string.
   *
   * @param {Function} stringify Optional query stringify function.
   * @returns {String} Compiled version of the URL.
   * @public
   */
  function toString(stringify) {
    if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

    var query
      , url = this
      , host = url.host
      , protocol = url.protocol;

    if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

    var result =
      protocol +
      ((url.protocol && url.slashes) || isSpecial(url.protocol) ? '//' : '');

    if (url.username) {
      result += url.username;
      if (url.password) result += ':'+ url.password;
      result += '@';
    } else if (url.password) {
      result += ':'+ url.password;
      result += '@';
    } else if (
      url.protocol !== 'file:' &&
      isSpecial(url.protocol) &&
      !host &&
      url.pathname !== '/'
    ) {
      //
      // Add back the empty userinfo, otherwise the original invalid URL
      // might be transformed into a valid one with `url.pathname` as host.
      //
      result += '@';
    }

    //
    // Trailing colon is removed from `url.host` when it is parsed. If it still
    // ends with a colon, then add back the trailing colon that was removed. This
    // prevents an invalid URL from being transformed into a valid one.
    //
    if (host[host.length - 1] === ':' || (port.test(url.hostname) && !url.port)) {
      host += ':';
    }

    result += host + url.pathname;

    query = 'object' === typeof url.query ? stringify(url.query) : url.query;
    if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

    if (url.hash) result += url.hash;

    return result;
  }

  Url.prototype = { set: set, toString: toString };

  //
  // Expose the URL parser and some additional properties that might be useful for
  // others or testing.
  //
  Url.extractProtocol = extractProtocol;
  Url.location = lolcation;
  Url.trimLeft = trimLeft;
  Url.qs = qs;

  var urlParse = Url;

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = void 0;

  	var _urlParse = _interopRequireDefault(urlParse);

  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  	function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

  	var isReactNative = typeof navigator === 'undefined' ? false : navigator.product === 'ReactNative';
  	var has = Object.prototype.hasOwnProperty;
  	var defaultOptions = {
  	  timeout: isReactNative ? 60000 : 120000
  	};

  	var _default = function _default(opts) {
  	  var options = typeof opts === 'string' ? _extends({
  	    url: opts
  	  }, defaultOptions) : _extends({}, defaultOptions, opts); // Parse URL into parts

  	  var url = (0, _urlParse.default)(options.url, {}, // Don't use current browser location
  	  true // Parse query strings
  	  ); // Normalize timeouts

  	  options.timeout = normalizeTimeout(options.timeout); // Shallow-merge (override) existing query params

  	  if (options.query) {
  	    url.query = _extends({}, url.query, removeUndefined(options.query));
  	  } // Implicit POST if we have not specified a method but have a body


  	  options.method = options.body && !options.method ? 'POST' : (options.method || 'GET').toUpperCase(); // Stringify URL

  	  options.url = url.toString(stringifyQueryString);
  	  return options;
  	};

  	exports.default = _default;

  	function stringifyQueryString(obj) {
  	  var pairs = [];

  	  for (var key in obj) {
  	    if (has.call(obj, key)) {
  	      push(key, obj[key]);
  	    }
  	  }

  	  return pairs.length ? pairs.join('&') : '';

  	  function push(key, val) {
  	    if (Array.isArray(val)) {
  	      val.forEach(function (item) {
  	        return push(key, item);
  	      });
  	    } else {
  	      pairs.push([key, val].map(encodeURIComponent).join('='));
  	    }
  	  }
  	}

  	function normalizeTimeout(time) {
  	  if (time === false || time === 0) {
  	    return false;
  	  }

  	  if (time.connect || time.socket) {
  	    return time;
  	  }

  	  var delay = Number(time);

  	  if (isNaN(delay)) {
  	    return normalizeTimeout(defaultOptions.timeout);
  	  }

  	  return {
  	    connect: delay,
  	    socket: delay
  	  };
  	}

  	function removeUndefined(obj) {
  	  var target = {};

  	  for (var key in obj) {
  	    if (obj[key] !== undefined) {
  	      target[key] = obj[key];
  	    }
  	  }

  	  return target;
  	}

  	module.exports = exports.default;
  	
  } (defaultOptionsProcessor, defaultOptionsProcessorExports));

  var defaultOptionsValidatorExports = {};
  var defaultOptionsValidator = {
    get exports(){ return defaultOptionsValidatorExports; },
    set exports(v){ defaultOptionsValidatorExports = v; },
  };

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = void 0;
  	var validUrl = /^https?:\/\//i;

  	var _default = function _default(options) {
  	  if (!validUrl.test(options.url)) {
  	    throw new Error("\"".concat(options.url, "\" is not a valid URL"));
  	  }
  	};

  	exports.default = _default;
  	module.exports = exports.default;
  	
  } (defaultOptionsValidator, defaultOptionsValidatorExports));

  var requestExports = {};
  var request$1 = {
    get exports(){ return requestExports; },
    set exports(v){ requestExports = v; },
  };

  var browserRequestExports = {};
  var browserRequest = {
    get exports(){ return browserRequestExports; },
    set exports(v){ browserRequestExports = v; },
  };

  /**
   * This file is only used for the browser version of `same-origin`.
   * Used to bring down the size of the browser bundle.
   */

  var regex = /^(?:(?:(?:([^:\/#\?]+:)?(?:(?:\/\/)((?:((?:[^:@\/#\?]+)(?:\:(?:[^:@\/#\?]+))?)@)?(([^:\/#\?\]\[]+|\[[^\/\]@#?]+\])(?:\:([0-9]+))?))?)?)?((?:\/?(?:[^\/\?#]+\/+)*)(?:[^\?#]*)))?(\?[^#]+)?)(#.*)?/;

  var urlParser = {
      regex: regex,
      parse: function(url) {
          var match = regex.exec(url);
          if (!match) {
              return {};
          }

          return {
              protocol: (match[1] || '').toLowerCase() || undefined,
              hostname: (match[5] || '').toLowerCase() || undefined,
              port: match[6] || undefined
          };
      }
  };

  var url = urlParser;

  var sameOrigin = function(uri1, uri2, ieMode) {
      if (uri1 === uri2) {
          return true;
      }

      var url1 = url.parse(uri1, false, true);
      var url2 = url.parse(uri2, false, true);

      var url1Port = url1.port|0 || (url1.protocol === 'https' ? 443 : 80);
      var url2Port = url2.port|0 || (url2.protocol === 'https' ? 443 : 80);

      var match = {
          proto: url1.protocol === url2.protocol,
          hostname: url1.hostname === url2.hostname,
          port: url1Port === url2Port
      };

      return ((match.proto && match.hostname) && (match.port || ieMode));
  };

  var trim = function(string) {
    return string.replace(/^\s+|\s+$/g, '');
  }
    , isArray = function(arg) {
        return Object.prototype.toString.call(arg) === '[object Array]';
      };

  var parseHeaders = function (headers) {
    if (!headers)
      return {}

    var result = {};

    var headersArr = trim(headers).split('\n');

    for (var i = 0; i < headersArr.length; i++) {
      var row = headersArr[i];
      var index = row.indexOf(':')
      , key = trim(row.slice(0, index)).toLowerCase()
      , value = trim(row.slice(index + 1));

      if (typeof(result[key]) === 'undefined') {
        result[key] = value;
      } else if (isArray(result[key])) {
        result[key].push(value);
      } else {
        result[key] = [ result[key], value ];
      }
    }

    return result
  };

  var fetchXhrExports = {};
  var fetchXhr = {
    get exports(){ return fetchXhrExports; },
    set exports(v){ fetchXhrExports = v; },
  };

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = void 0;

  	/**
  	 * Mimicks the XMLHttpRequest API with only the parts needed for get-it's XHR adapter
  	 */
  	function FetchXhr() {
  	  this.readyState = 0; // Unsent
  	}

  	FetchXhr.prototype.open = function (method, url) {
  	  this._method = method;
  	  this._url = url;
  	  this._resHeaders = '';
  	  this.readyState = 1; // Open

  	  this.onreadystatechange();
  	};

  	FetchXhr.prototype.abort = function () {
  	  if (this._controller) {
  	    this._controller.abort();
  	  }
  	};

  	FetchXhr.prototype.getAllResponseHeaders = function () {
  	  return this._resHeaders;
  	};

  	FetchXhr.prototype.setRequestHeader = function (key, value) {
  	  this._headers = this._headers || {};
  	  this._headers[key] = value;
  	};

  	FetchXhr.prototype.send = function (body) {
  	  var _this = this;

  	  // eslint-disable-next-line no-multi-assign
  	  var ctrl = this._controller = typeof AbortController === 'function' && new AbortController();
  	  var textBody = this.responseType !== 'arraybuffer';
  	  var options = {
  	    method: this._method,
  	    headers: this._headers,
  	    signal: ctrl && ctrl.signal || undefined,
  	    body: body
  	  }; // Some environments (like CloudFlare workers) don't support credentials in
  	  // RequestInitDict, and there doesn't seem to be any easy way to check for it,
  	  // so for now let's just make do with a window check :/

  	  if (typeof document !== 'undefined') {
  	    options.credentials = this.withCredentials ? 'include' : 'omit';
  	  }

  	  fetch(this._url, options).then(function (res) {
  	    res.headers.forEach(function (value, key) {
  	      _this._resHeaders += "".concat(key, ": ").concat(value, "\r\n");
  	    });
  	    _this.status = res.status;
  	    _this.statusText = res.statusText;
  	    _this.readyState = 3; // Loading

  	    return textBody ? res.text() : res.arrayBuffer();
  	  }).then(function (resBody) {
  	    if (textBody) {
  	      _this.responseText = resBody;
  	    } else {
  	      _this.response = resBody;
  	    }

  	    _this.readyState = 4; // Done

  	    _this.onreadystatechange();
  	  }).catch(function (err) {
  	    if (err.name === 'AbortError') {
  	      _this.onabort();

  	      return;
  	    }

  	    _this.onerror(err);
  	  });
  	};

  	var _default = FetchXhr;
  	exports.default = _default;
  	module.exports = exports.default;
  	
  } (fetchXhr, fetchXhrExports));

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = void 0;

  	var _sameOrigin = _interopRequireDefault(sameOrigin);

  	var _parseHeaders = _interopRequireDefault(parseHeaders);

  	var _fetchXhr = _interopRequireDefault(fetchXhrExports);

  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  	/* eslint max-depth: ["error", 4] */
  	var noop = function noop() {
  	  /* intentional noop */
  	};

  	var win = typeof document === 'undefined' || typeof window === 'undefined' ? undefined : window;
  	var adapter = win ? 'xhr' : 'fetch';
  	var XmlHttpRequest = typeof XMLHttpRequest === 'function' ? XMLHttpRequest : noop;
  	var hasXhr2 = ('withCredentials' in new XmlHttpRequest()); // eslint-disable-next-line no-undef

  	var XDR = typeof XDomainRequest === 'undefined' ? undefined : XDomainRequest;
  	var CrossDomainRequest = hasXhr2 ? XmlHttpRequest : XDR; // Fallback to fetch-based XHR polyfill for non-browser environments like Workers

  	if (!win) {
  	  XmlHttpRequest = _fetchXhr.default;
  	  CrossDomainRequest = _fetchXhr.default;
  	}

  	var _default = function _default(context, callback) {
  	  var opts = context.options;
  	  var options = context.applyMiddleware('finalizeOptions', opts);
  	  var timers = {}; // Deep-checking window.location because of react native, where `location` doesn't exist

  	  var cors = win && win.location && !(0, _sameOrigin.default)(win.location.href, options.url); // Allow middleware to inject a response, for instance in the case of caching or mocking

  	  var injectedResponse = context.applyMiddleware('interceptRequest', undefined, {
  	    adapter: adapter,
  	    context: context
  	  }); // If middleware injected a response, treat it as we normally would and return it
  	  // Do note that the injected response has to be reduced to a cross-environment friendly response

  	  if (injectedResponse) {
  	    var cbTimer = setTimeout(callback, 0, null, injectedResponse);

  	    var cancel = function cancel() {
  	      return clearTimeout(cbTimer);
  	    };

  	    return {
  	      abort: cancel
  	    };
  	  } // We'll want to null out the request on success/failure


  	  var xhr = cors ? new CrossDomainRequest() : new XmlHttpRequest();
  	  var isXdr = win && win.XDomainRequest && xhr instanceof win.XDomainRequest;
  	  var headers = options.headers;
  	  var delays = options.timeout; // Request state

  	  var aborted = false;
  	  var loaded = false;
  	  var timedOut = false; // Apply event handlers

  	  xhr.onerror = onError;
  	  xhr.ontimeout = onError;

  	  xhr.onabort = function () {
  	    stopTimers(true);
  	    aborted = true;
  	  }; // IE9 must have onprogress be set to a unique function


  	  xhr.onprogress = function () {
  	    /* intentional noop */
  	  };

  	  var loadEvent = isXdr ? 'onload' : 'onreadystatechange';

  	  xhr[loadEvent] = function () {
  	    // Prevent request from timing out
  	    resetTimers();

  	    if (aborted || xhr.readyState !== 4 && !isXdr) {
  	      return;
  	    } // Will be handled by onError


  	    if (xhr.status === 0) {
  	      return;
  	    }

  	    onLoad();
  	  }; // @todo two last options to open() is username/password


  	  xhr.open(options.method, options.url, true // Always async
  	  ); // Some options need to be applied after open

  	  xhr.withCredentials = !!options.withCredentials; // Set headers

  	  if (headers && xhr.setRequestHeader) {
  	    for (var key in headers) {
  	      if (headers.hasOwnProperty(key)) {
  	        xhr.setRequestHeader(key, headers[key]);
  	      }
  	    }
  	  } else if (headers && isXdr) {
  	    throw new Error('Headers cannot be set on an XDomainRequest object');
  	  }

  	  if (options.rawBody) {
  	    xhr.responseType = 'arraybuffer';
  	  } // Let middleware know we're about to do a request


  	  context.applyMiddleware('onRequest', {
  	    options: options,
  	    adapter: adapter,
  	    request: xhr,
  	    context: context
  	  });
  	  xhr.send(options.body || null); // Figure out which timeouts to use (if any)

  	  if (delays) {
  	    timers.connect = setTimeout(function () {
  	      return timeoutRequest('ETIMEDOUT');
  	    }, delays.connect);
  	  }

  	  return {
  	    abort: abort
  	  };

  	  function abort() {
  	    aborted = true;

  	    if (xhr) {
  	      xhr.abort();
  	    }
  	  }

  	  function timeoutRequest(code) {
  	    timedOut = true;
  	    xhr.abort();
  	    var error = new Error(code === 'ESOCKETTIMEDOUT' ? "Socket timed out on request to ".concat(options.url) : "Connection timed out on request to ".concat(options.url));
  	    error.code = code;
  	    context.channels.error.publish(error);
  	  }

  	  function resetTimers() {
  	    if (!delays) {
  	      return;
  	    }

  	    stopTimers();
  	    timers.socket = setTimeout(function () {
  	      return timeoutRequest('ESOCKETTIMEDOUT');
  	    }, delays.socket);
  	  }

  	  function stopTimers(force) {
  	    // Only clear the connect timeout if we've got a connection
  	    if (force || aborted || xhr.readyState >= 2 && timers.connect) {
  	      clearTimeout(timers.connect);
  	    }

  	    if (timers.socket) {
  	      clearTimeout(timers.socket);
  	    }
  	  }

  	  function onError(error) {
  	    if (loaded) {
  	      return;
  	    } // Clean up


  	    stopTimers(true);
  	    loaded = true;
  	    xhr = null; // Annoyingly, details are extremely scarce and hidden from us.
  	    // We only really know that it is a network error

  	    var err = error || new Error("Network error while attempting to reach ".concat(options.url));
  	    err.isNetworkError = true;
  	    err.request = options;
  	    callback(err);
  	  }

  	  function reduceResponse() {
  	    var statusCode = xhr.status;
  	    var statusMessage = xhr.statusText;

  	    if (isXdr && statusCode === undefined) {
  	      // IE8 CORS GET successful response doesn't have a status field, but body is fine
  	      statusCode = 200;
  	    } else if (statusCode > 12000 && statusCode < 12156) {
  	      // Yet another IE quirk where it emits weird status codes on network errors
  	      // https://support.microsoft.com/en-us/kb/193625
  	      return onError();
  	    } else {
  	      // Another IE bug where HTTP 204 somehow ends up as 1223
  	      statusCode = xhr.status === 1223 ? 204 : xhr.status;
  	      statusMessage = xhr.status === 1223 ? 'No Content' : statusMessage;
  	    }

  	    return {
  	      body: xhr.response || xhr.responseText,
  	      url: options.url,
  	      method: options.method,
  	      headers: isXdr ? {} : (0, _parseHeaders.default)(xhr.getAllResponseHeaders()),
  	      statusCode: statusCode,
  	      statusMessage: statusMessage
  	    };
  	  }

  	  function onLoad() {
  	    if (aborted || loaded || timedOut) {
  	      return;
  	    }

  	    if (xhr.status === 0) {
  	      onError(new Error('Unknown XHR error'));
  	      return;
  	    } // Prevent being called twice


  	    stopTimers();
  	    loaded = true;
  	    callback(null, reduceResponse());
  	  }
  	};

  	exports.default = _default;
  	module.exports = exports.default;
  	
  } (browserRequest, browserRequestExports));

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = void 0;

  	var _nodeRequest = _interopRequireDefault(browserRequestExports);

  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  	var _default = _nodeRequest.default;
  	exports.default = _default;
  	module.exports = exports.default;
  	
  } (request$1, requestExports));

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = createRequester;

  	var _nanoPubsub = _interopRequireDefault(require$$0);

  	var _middlewareReducer = _interopRequireDefault(middlewareReducerExports);

  	var _defaultOptionsProcessor = _interopRequireDefault(defaultOptionsProcessorExports);

  	var _defaultOptionsValidator = _interopRequireDefault(defaultOptionsValidatorExports);

  	var _request = _interopRequireDefault(requestExports);

  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  	// node-request in node, browser-request in browsers
  	// Workaround default export weirdness
  	var pubsub = 'default' in _nanoPubsub.default ? _nanoPubsub.default.default : _nanoPubsub.default;
  	var channelNames = ['request', 'response', 'progress', 'error', 'abort'];
  	var middlehooks = ['processOptions', 'validateOptions', 'interceptRequest', 'finalizeOptions', 'onRequest', 'onResponse', 'onError', 'onReturn', 'onHeaders'];

  	function createRequester() {
  	  var initMiddleware = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  	  var httpRequest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _request.default;
  	  var loadedMiddleware = [];
  	  var middleware = middlehooks.reduce(function (ware, name) {
  	    ware[name] = ware[name] || [];
  	    return ware;
  	  }, {
  	    processOptions: [_defaultOptionsProcessor.default],
  	    validateOptions: [_defaultOptionsValidator.default]
  	  });

  	  function request(opts) {
  	    var channels = channelNames.reduce(function (target, name) {
  	      target[name] = pubsub();
  	      return target;
  	    }, {}); // Prepare a middleware reducer that can be reused throughout the lifecycle

  	    var applyMiddleware = (0, _middlewareReducer.default)(middleware); // Parse the passed options

  	    var options = applyMiddleware('processOptions', opts); // Validate the options

  	    applyMiddleware('validateOptions', options); // Build a context object we can pass to child handlers

  	    var context = {
  	      options: options,
  	      channels: channels,
  	      applyMiddleware: applyMiddleware
  	    }; // We need to hold a reference to the current, ongoing request,
  	    // in order to allow cancellation. In the case of the retry middleware,
  	    // a new request might be triggered

  	    var ongoingRequest = null;
  	    var unsubscribe = channels.request.subscribe(function (ctx) {
  	      // Let request adapters (node/browser) perform the actual request
  	      ongoingRequest = httpRequest(ctx, function (err, res) {
  	        return onResponse(err, res, ctx);
  	      });
  	    }); // If we abort the request, prevent further requests from happening,
  	    // and be sure to cancel any ongoing request (obviously)

  	    channels.abort.subscribe(function () {
  	      unsubscribe();

  	      if (ongoingRequest) {
  	        ongoingRequest.abort();
  	      }
  	    }); // See if any middleware wants to modify the return value - for instance
  	    // the promise or observable middlewares

  	    var returnValue = applyMiddleware('onReturn', channels, context); // If return value has been modified by a middleware, we expect the middleware
  	    // to publish on the 'request' channel. If it hasn't been modified, we want to
  	    // trigger it right away

  	    if (returnValue === channels) {
  	      channels.request.publish(context);
  	    }

  	    return returnValue;

  	    function onResponse(reqErr, res, ctx) {
  	      var error = reqErr;
  	      var response = res; // We're processing non-errors first, in case a middleware converts the
  	      // response into an error (for instance, status >= 400 == HttpError)

  	      if (!error) {
  	        try {
  	          response = applyMiddleware('onResponse', res, ctx);
  	        } catch (err) {
  	          response = null;
  	          error = err;
  	        }
  	      } // Apply error middleware - if middleware return the same (or a different) error,
  	      // publish as an error event. If we *don't* return an error, assume it has been handled


  	      error = error && applyMiddleware('onError', error, ctx); // Figure out if we should publish on error/response channels

  	      if (error) {
  	        channels.error.publish(error);
  	      } else if (response) {
  	        channels.response.publish(response);
  	      }
  	    }
  	  }

  	  request.use = function use(newMiddleware) {
  	    if (!newMiddleware) {
  	      throw new Error('Tried to add middleware that resolved to falsey value');
  	    }

  	    if (typeof newMiddleware === 'function') {
  	      throw new Error('Tried to add middleware that was a function. It probably expects you to pass options to it.');
  	    }

  	    if (newMiddleware.onReturn && middleware.onReturn.length > 0) {
  	      throw new Error('Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event');
  	    }

  	    middlehooks.forEach(function (key) {
  	      if (newMiddleware[key]) {
  	        middleware[key].push(newMiddleware[key]);
  	      }
  	    });
  	    loadedMiddleware.push(newMiddleware);
  	    return request;
  	  };

  	  request.clone = function clone() {
  	    return createRequester(loadedMiddleware);
  	  };

  	  initMiddleware.forEach(request.use);
  	  return request;
  	}

  	module.exports = exports.default;
  	
  } (lib, libExports));

  var getIt = /*@__PURE__*/getDefaultExportFromCjs(libExports);

  // node_modules/is-plain-object/dist/is-plain-object.mjs
  function isObject(o) {
    return Object.prototype.toString.call(o) === "[object Object]";
  }
  function isPlainObject(o) {
    var ctor, prot;
    if (isObject(o) === false)
      return false;
    ctor = o.constructor;
    if (ctor === void 0)
      return true;
    prot = ctor.prototype;
    if (isObject(prot) === false)
      return false;
    if (prot.hasOwnProperty("isPrototypeOf") === false) {
      return false;
    }
    return true;
  }
  /*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */

  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/form-urlencoded/dist/form-urlencoded.js
  var require_form_urlencoded = __commonJS({
    "node_modules/form-urlencoded/dist/form-urlencoded.js"(exports, module) {
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      module.exports = function(data) {
        var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var sorted = Boolean(opts.sorted), skipIndex = Boolean(opts.skipIndex), ignorenull = Boolean(opts.ignorenull), encode2 = function encode3(value) {
          return String(value).replace(/(?:[\0-\x1F"-&\+-\}\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, encodeURIComponent).replace(/ /g, "+").replace(/[!'()~\*]/g, function(ch) {
            return "%" + ch.charCodeAt().toString(16).slice(-2).toUpperCase();
          });
        }, keys = function keys2(obj) {
          var keyarr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Object.keys(obj);
          return sorted ? keyarr.sort() : keyarr;
        }, filterjoin = function filterjoin2(arr) {
          return arr.filter(function(e) {
            return e;
          }).join("&");
        }, objnest = function objnest2(name, obj) {
          return filterjoin(keys(obj).map(function(key) {
            return nest(name + "[" + key + "]", obj[key]);
          }));
        }, arrnest = function arrnest2(name, arr) {
          return arr.length ? filterjoin(arr.map(function(elem, index) {
            return skipIndex ? nest(name + "[]", elem) : nest(name + "[" + index + "]", elem);
          })) : encode2(name + "[]");
        }, nest = function nest2(name, value) {
          var type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : typeof value === "undefined" ? "undefined" : _typeof(value);
          var f = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
          if (value === f)
            f = ignorenull ? f : encode2(name) + "=" + f;
          else if (/string|number|boolean/.test(type))
            f = encode2(name) + "=" + encode2(value);
          else if (Array.isArray(value))
            f = arrnest(name, value);
          else if (type === "object")
            f = objnest(name, value);
          return f;
        };
        return data && filterjoin(keys(data).map(function(key) {
          return nest(key, data[key]);
        }));
      };
    }
  });

  // src/middleware/urlEncoded.js
  var import_form_urlencoded = __toESM(require_form_urlencoded());
  import_form_urlencoded.default.default || import_form_urlencoded.default;

  // src/middleware/progress/browser-progress.js
  var browser_progress_default = () => ({
    onRequest: (evt) => {
      if (evt.adapter !== "xhr") {
        return;
      }
      const xhr = evt.request;
      const context = evt.context;
      if ("upload" in xhr && "onprogress" in xhr.upload) {
        xhr.upload.onprogress = handleProgress("upload");
      }
      if ("onprogress" in xhr) {
        xhr.onprogress = handleProgress("download");
      }
      function handleProgress(stage) {
        return (event) => {
          const percent = event.lengthComputable ? event.loaded / event.total * 100 : -1;
          context.channels.progress.publish({
            stage,
            percent,
            total: event.total,
            loaded: event.loaded,
            lengthComputable: event.lengthComputable
          });
        };
      }
    }
  });

  // src/middleware/jsonRequest.js
  var serializeTypes = ["boolean", "string", "number"];
  var isBuffer = (obj) => !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  var jsonRequest_default = () => ({
    processOptions: (options) => {
      const body = options.body;
      if (!body) {
        return options;
      }
      const isStream = typeof body.pipe === "function";
      const shouldSerialize = !isStream && !isBuffer(body) && (serializeTypes.indexOf(typeof body) !== -1 || Array.isArray(body) || isPlainObject(body));
      if (!shouldSerialize) {
        return options;
      }
      return Object.assign({}, options, {
        body: JSON.stringify(options.body),
        headers: Object.assign({}, options.headers, {
          "Content-Type": "application/json"
        })
      });
    }
  });

  // src/middleware/jsonResponse.js
  var jsonResponse_default = (opts) => ({
    onResponse: (response) => {
      const contentType = response.headers["content-type"] || "";
      const shouldDecode = opts && opts.force || contentType.indexOf("application/json") !== -1;
      if (!response.body || !contentType || !shouldDecode) {
        return response;
      }
      return Object.assign({}, response, { body: tryParse(response.body) });
    },
    processOptions: (options) => Object.assign({}, options, {
      headers: Object.assign({ Accept: "application/json" }, options.headers)
    })
  });
  function tryParse(body) {
    try {
      return JSON.parse(body);
    } catch (err) {
      err.message = `Failed to parsed response body as JSON: ${err.message}`;
      throw err;
    }
  }

  // src/util/global.js
  var actualGlobal;
  if (typeof globalThis !== "undefined") {
    actualGlobal = globalThis;
  } else if (typeof window !== "undefined") {
    actualGlobal = window;
  } else if (typeof global !== "undefined") {
    actualGlobal = global;
  } else if (typeof self !== "undefined") {
    actualGlobal = self;
  } else {
    actualGlobal = {};
  }
  var global_default = actualGlobal;

  // src/middleware/observable.js
  var observable_default = (opts = {}) => {
    const Observable = opts.implementation || global_default.Observable;
    if (!Observable) {
      throw new Error(
        "`Observable` is not available in global scope, and no implementation was passed"
      );
    }
    return {
      onReturn: (channels, context) => new Observable((observer) => {
        channels.error.subscribe((err) => observer.error(err));
        channels.progress.subscribe(
          (event) => observer.next(Object.assign({ type: "progress" }, event))
        );
        channels.response.subscribe((response) => {
          observer.next(Object.assign({ type: "response" }, response));
          observer.complete();
        });
        channels.request.publish(context);
        return () => channels.abort.publish();
      })
    };
  };

  // src/middleware/cancel/Cancel.js
  var Cancel_exports = {};
  __export(Cancel_exports, {
    default: () => Cancel_default
  });
  function Cancel(message) {
    this.message = message;
  }
  var Cancel_default;
  var init_Cancel = __esm({
    "src/middleware/cancel/Cancel.js"() {
      Cancel.prototype.toString = function toString() {
        return `Cancel${this.message ? `: ${this.message}` : ""}`;
      };
      Cancel.prototype.__CANCEL__ = true;
      Cancel_default = Cancel;
    }
  });

  // src/middleware/promise.js
  init_Cancel();

  // src/middleware/cancel/CancelToken.js
  var Cancel2 = (init_Cancel(), __toCommonJS(Cancel_exports));
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise = null;
    this.promise = new Promise((resolve) => {
      resolvePromise = resolve;
    });
    executor((message) => {
      if (this.reason) {
        return;
      }
      this.reason = new Cancel2(message);
      resolvePromise(this.reason);
    });
  }
  CancelToken.source = function() {
    let cancel;
    const token = new CancelToken((can) => {
      cancel = can;
    });
    return {
      token,
      cancel
    };
  };

  // node_modules/ms/index.js
  var require_ms = __commonJS({
    "node_modules/ms/index.js"(exports, module) {
      var s = 1e3;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var w = d * 7;
      var y = d * 365.25;
      module.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse(val);
        } else if (type === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + "d";
        }
        if (msAbs >= h) {
          return Math.round(ms / h) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, "day");
        }
        if (msAbs >= h) {
          return plural(ms, msAbs, h, "hour");
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms, msAbs, s, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
      }
    }
  });

  // node_modules/debug/src/common.js
  var require_common = __commonJS({
    "node_modules/debug/src/common.js"(exports, module) {
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug(...args) {
            if (!debug.enabled) {
              return;
            }
            const self = debug;
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
          }
          debug.namespace = namespace;
          debug.useColors = createDebug.useColors();
          debug.color = createDebug.selectColor(namespace);
          debug.extend = extend;
          debug.destroy = createDebug.destroy;
          Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug);
          }
          return debug;
        }
        function extend(namespace, delimiter) {
          const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          let i;
          const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          const len = split.length;
          for (i = 0; i < len; i++) {
            if (!split[i]) {
              continue;
            }
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        function disable() {
          const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          let i;
          let len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module.exports = setup;
    }
  });

  // node_modules/debug/src/browser.js
  var require_browser = __commonJS({
    "node_modules/debug/src/browser.js"(exports, module) {
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.destroy = (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load() {
        let r;
        try {
          r = exports.storage.getItem("debug");
        } catch (error) {
        }
        if (!r && false) {
          r = false;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module.exports = require_common()(exports);
      var { formatters } = module.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    }
  });

  // src/middleware/debug.js
  __toESM(require_browser());

  // node_modules/capture-stack-trace/index.js
  var require_capture_stack_trace = __commonJS({
    "node_modules/capture-stack-trace/index.js"(exports, module) {
      module.exports = Error.captureStackTrace || function(error) {
        var container = new Error();
        Object.defineProperty(error, "stack", {
          configurable: true,
          get: function getStack() {
            var stack = container.stack;
            Object.defineProperty(this, "stack", {
              value: stack
            });
            return stack;
          }
        });
      };
    }
  });

  // node_modules/create-error-class/index.js
  var require_create_error_class = __commonJS({
    "node_modules/create-error-class/index.js"(exports, module) {
      var captureStackTrace = require_capture_stack_trace();
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
      module.exports = function createErrorClass2(className, setup) {
        if (typeof className !== "string") {
          throw new TypeError("Expected className to be a string");
        }
        if (/[^0-9a-zA-Z_$]/.test(className)) {
          throw new Error("className contains invalid characters");
        }
        setup = setup || function(message) {
          this.message = message;
        };
        var ErrorClass = function() {
          Object.defineProperty(this, "name", {
            configurable: true,
            value: className,
            writable: true
          });
          captureStackTrace(this, this.constructor);
          setup.apply(this, arguments);
        };
        inherits(ErrorClass, Error);
        return ErrorClass;
      };
    }
  });

  // src/middleware/httpErrors.js
  var import_create_error_class = __toESM(require_create_error_class());
  (0, import_create_error_class.default)("HttpError", function(res, ctx) {
    const truncatedUrl = res.url.length > 400 ? `${res.url.slice(0, 399)}\u2026` : res.url;
    let msg = `${res.method}-request to ${truncatedUrl} resulted in `;
    msg += `HTTP ${res.statusCode} ${res.statusMessage}`;
    this.message = msg.trim();
    this.response = res;
    this.request = ctx.options;
  });

  var makeErrorExports = {};
  var makeError$1 = {
    get exports(){ return makeErrorExports; },
    set exports(v){ makeErrorExports = v; },
  };

  (function (module, exports) {

  	// ===================================================================

  	var construct = typeof Reflect !== "undefined" ? Reflect.construct : undefined;
  	var defineProperty = Object.defineProperty;

  	// -------------------------------------------------------------------

  	var captureStackTrace = Error.captureStackTrace;
  	if (captureStackTrace === undefined) {
  	  captureStackTrace = function captureStackTrace(error) {
  	    var container = new Error();

  	    defineProperty(error, "stack", {
  	      configurable: true,
  	      get: function getStack() {
  	        var stack = container.stack;

  	        // Replace property with value for faster future accesses.
  	        defineProperty(this, "stack", {
  	          configurable: true,
  	          value: stack,
  	          writable: true,
  	        });

  	        return stack;
  	      },
  	      set: function setStack(stack) {
  	        defineProperty(error, "stack", {
  	          configurable: true,
  	          value: stack,
  	          writable: true,
  	        });
  	      },
  	    });
  	  };
  	}

  	// -------------------------------------------------------------------

  	function BaseError(message) {
  	  if (message !== undefined) {
  	    defineProperty(this, "message", {
  	      configurable: true,
  	      value: message,
  	      writable: true,
  	    });
  	  }

  	  var cname = this.constructor.name;
  	  if (cname !== undefined && cname !== this.name) {
  	    defineProperty(this, "name", {
  	      configurable: true,
  	      value: cname,
  	      writable: true,
  	    });
  	  }

  	  captureStackTrace(this, this.constructor);
  	}

  	BaseError.prototype = Object.create(Error.prototype, {
  	  // See: https://github.com/JsCommunity/make-error/issues/4
  	  constructor: {
  	    configurable: true,
  	    value: BaseError,
  	    writable: true,
  	  },
  	});

  	// -------------------------------------------------------------------

  	// Sets the name of a function if possible (depends of the JS engine).
  	var setFunctionName = (function() {
  	  function setFunctionName(fn, name) {
  	    return defineProperty(fn, "name", {
  	      configurable: true,
  	      value: name,
  	    });
  	  }
  	  try {
  	    var f = function() {};
  	    setFunctionName(f, "foo");
  	    if (f.name === "foo") {
  	      return setFunctionName;
  	    }
  	  } catch (_) {}
  	})();

  	// -------------------------------------------------------------------

  	function makeError(constructor, super_) {
  	  if (super_ == null || super_ === Error) {
  	    super_ = BaseError;
  	  } else if (typeof super_ !== "function") {
  	    throw new TypeError("super_ should be a function");
  	  }

  	  var name;
  	  if (typeof constructor === "string") {
  	    name = constructor;
  	    constructor =
  	      construct !== undefined
  	        ? function() {
  	            return construct(super_, arguments, this.constructor);
  	          }
  	        : function() {
  	            super_.apply(this, arguments);
  	          };

  	    // If the name can be set, do it once and for all.
  	    if (setFunctionName !== undefined) {
  	      setFunctionName(constructor, name);
  	      name = undefined;
  	    }
  	  } else if (typeof constructor !== "function") {
  	    throw new TypeError("constructor should be either a string or a function");
  	  }

  	  // Also register the super constructor also as `constructor.super_` just
  	  // like Node's `util.inherits()`.
  	  //
  	  // eslint-disable-next-line dot-notation
  	  constructor.super_ = constructor["super"] = super_;

  	  var properties = {
  	    constructor: {
  	      configurable: true,
  	      value: constructor,
  	      writable: true,
  	    },
  	  };

  	  // If the name could not be set on the constructor, set it on the
  	  // prototype.
  	  if (name !== undefined) {
  	    properties.name = {
  	      configurable: true,
  	      value: name,
  	      writable: true,
  	    };
  	  }
  	  constructor.prototype = Object.create(super_.prototype, properties);

  	  return constructor;
  	}
  	exports = module.exports = makeError;
  	exports.BaseError = BaseError;
  } (makeError$1, makeErrorExports));

  var makeError = makeErrorExports;

  function ClientError(res) {
    const props = extractErrorProps(res);
    ClientError.super.call(this, props.message);
    Object.assign(this, props);
  }

  function ServerError(res) {
    const props = extractErrorProps(res);
    ServerError.super.call(this, props.message);
    Object.assign(this, props);
  }

  function extractErrorProps(res) {
    const body = res.body;
    const props = {
      response: res,
      statusCode: res.statusCode,
      responseBody: stringifyBody(body, res),
    };

    // API/Boom style errors ({statusCode, error, message})
    if (body.error && body.message) {
      props.message = `${body.error} - ${body.message}`;
      return props
    }

    // Query/database errors ({error: {description, other, arb, props}})
    if (body.error && body.error.description) {
      props.message = body.error.description;
      props.details = body.error;
      return props
    }

    // Other, more arbitrary errors
    props.message = body.error || body.message || httpErrorMessage(res);
    return props
  }

  function httpErrorMessage(res) {
    const statusMessage = res.statusMessage ? ` ${res.statusMessage}` : '';
    return `${res.method}-request to ${res.url} resulted in HTTP ${res.statusCode}${statusMessage}`
  }

  function stringifyBody(body, res) {
    const contentType = (res.headers['content-type'] || '').toLowerCase();
    const isJson = contentType.indexOf('application/json') !== -1;
    return isJson ? JSON.stringify(body, null, 2) : body
  }

  makeError(ClientError);
  makeError(ServerError);

  var envMiddleware = [];

  /* eslint-disable no-empty-function, no-process-env */

  const httpError = {
    onResponse: (res) => {
      if (res.statusCode >= 500) {
        throw new ServerError(res)
      } else if (res.statusCode >= 400) {
        throw new ClientError(res)
      }

      return res
    },
  };

  const printWarnings = {
    onResponse: (res) => {
      const warn = res.headers['x-sanity-warning'];
      const warnings = Array.isArray(warn) ? warn : [warn];
      warnings.filter(Boolean).forEach((msg) => console.warn(msg)); // eslint-disable-line no-console
      return res
    },
  };

  // Environment-specific middleware.
  const envSpecific = envMiddleware;

  const middleware = envSpecific.concat([
    printWarnings,
    jsonRequest_default(),
    jsonResponse_default(),
    browser_progress_default(),
    httpError,
    observable_default({implementation: Observable}),
  ]);

  const request = getIt(middleware);

  function httpRequest(options, requester = request) {
    return requester(Object.assign({maxRedirects: 0}, options))
  }

  httpRequest.defaultRequester = request;
  httpRequest.ClientError = ClientError;
  httpRequest.ServerError = ServerError;

  const projectHeader = 'X-Sanity-Project-ID';

  var getRequestOptions = (config, overrides = {}) => {
    const headers = {};

    const token = overrides.token || config.token;
    if (token) {
      headers.Authorization = `Bearer ${token}`;
    }

    if (!overrides.useGlobalApi && !config.useProjectHostname && config.projectId) {
      headers[projectHeader] = config.projectId;
    }

    const withCredentials = Boolean(
      typeof overrides.withCredentials === 'undefined'
        ? config.token || config.withCredentials
        : overrides.withCredentials
    );

    const timeout = typeof overrides.timeout === 'undefined' ? config.timeout : overrides.timeout;
    return Object.assign({}, overrides, {
      headers: Object.assign({}, headers, overrides.headers || {}),
      timeout: typeof timeout === 'undefined' ? 5 * 60 * 1000 : timeout,
      proxy: overrides.proxy || config.proxy,
      json: true,
      withCredentials,
    })
  };

  const BASE_URL = 'https://docs.sanity.io/help/';

  function generateHelpUrl(slug) {
    return BASE_URL + slug
  }

  var once = (fn) => {
    let didCall = false;
    let returnValue;
    return (...args) => {
      if (didCall) {
        return returnValue
      }
      returnValue = fn(...args);
      didCall = true;
      return returnValue
    }
  };

  const createWarningPrinter = (message) =>
    // eslint-disable-next-line no-console
    once((...args) => console.warn(message.join(' '), ...args));

  const printCdnWarning = createWarningPrinter([
    'You are not using the Sanity CDN. That means your data is always fresh, but the CDN is faster and',
    `cheaper. Think about it! For more info, see ${generateHelpUrl('js-client-cdn-configuration')}.`,
    'To hide this warning, please set the `useCdn` option to either `true` or `false` when creating',
    'the client.',
  ]);

  const printBrowserTokenWarning = createWarningPrinter([
    'You have configured Sanity client to use a token in the browser. This may cause unintentional security issues.',
    `See ${generateHelpUrl(
    'js-client-browser-token'
  )} for more information and how to hide this warning.`,
  ]);

  const printNoApiVersionSpecifiedWarning = createWarningPrinter([
    'Using the Sanity client without specifying an API version is deprecated.',
    `See ${generateHelpUrl('js-client-api-version')}`,
  ]);

  const defaultCdnHost = 'apicdn.sanity.io';
  const defaultConfig = {
    apiHost: 'https://api.sanity.io',
    apiVersion: '1',
    useProjectHostname: true,
    isPromiseAPI: true,
  };

  const LOCALHOSTS = ['localhost', '127.0.0.1', '0.0.0.0'];
  const isLocal = (host) => LOCALHOSTS.indexOf(host) !== -1;

  const validateApiVersion = function validateApiVersion(apiVersion) {
    if (apiVersion === '1' || apiVersion === 'X') {
      return
    }

    const apiDate = new Date(apiVersion);
    const apiVersionValid =
      /^\d{4}-\d{2}-\d{2}$/.test(apiVersion) && apiDate instanceof Date && apiDate.getTime() > 0;

    if (!apiVersionValid) {
      throw new Error('Invalid API version string, expected `1` or date in format `YYYY-MM-DD`')
    }
  };

  // eslint-disable-next-line complexity
  const initConfig = (config, prevConfig) => {
    const specifiedConfig = Object.assign({}, prevConfig, config);
    if (!specifiedConfig.apiVersion) {
      printNoApiVersionSpecifiedWarning();
    }

    const newConfig = Object.assign({}, defaultConfig, specifiedConfig);
    const projectBased = newConfig.useProjectHostname;

    if (typeof Promise === 'undefined') {
      const helpUrl = generateHelpUrl('js-client-promise-polyfill');
      throw new Error(`No native Promise-implementation found, polyfill needed - see ${helpUrl}`)
    }

    if (projectBased && !newConfig.projectId) {
      throw new Error('Configuration must contain `projectId`')
    }

    const isBrowser = typeof window !== 'undefined' && window.location && window.location.hostname;
    const isLocalhost = isBrowser && isLocal(window.location.hostname);

    if (isBrowser && isLocalhost && newConfig.token && newConfig.ignoreBrowserTokenWarning !== true) {
      printBrowserTokenWarning();
    } else if (typeof newConfig.useCdn === 'undefined') {
      printCdnWarning();
    }

    if (projectBased) {
      projectId(newConfig.projectId);
    }

    if (newConfig.dataset) {
      dataset(newConfig.dataset);
    }

    if ('requestTagPrefix' in newConfig) {
      // Allow setting and unsetting request tag prefix
      newConfig.requestTagPrefix = newConfig.requestTagPrefix
        ? requestTag(newConfig.requestTagPrefix).replace(/\.+$/, '')
        : undefined;
    }

    newConfig.apiVersion = `${newConfig.apiVersion}`.replace(/^v/, '');
    newConfig.isDefaultApi = newConfig.apiHost === defaultConfig.apiHost;
    newConfig.useCdn = Boolean(newConfig.useCdn) && !newConfig.withCredentials;

    validateApiVersion(newConfig.apiVersion);

    const hostParts = newConfig.apiHost.split('://', 2);
    const protocol = hostParts[0];
    const host = hostParts[1];
    const cdnHost = newConfig.isDefaultApi ? defaultCdnHost : host;

    if (newConfig.useProjectHostname) {
      newConfig.url = `${protocol}://${newConfig.projectId}.${host}/v${newConfig.apiVersion}`;
      newConfig.cdnUrl = `${protocol}://${newConfig.projectId}.${cdnHost}/v${newConfig.apiVersion}`;
    } else {
      newConfig.url = `${newConfig.apiHost}/v${newConfig.apiVersion}`;
      newConfig.cdnUrl = newConfig.url;
    }

    return newConfig
  };

  function SanityClient(config = defaultConfig) {
    if (!(this instanceof SanityClient)) {
      return new SanityClient(config)
    }

    this.config(config);

    this.assets = new AssetsClient(this);
    this.datasets = new DatasetsClient(this);
    this.projects = new ProjectsClient(this);
    this.users = new UsersClient(this);
    this.auth = new AuthClient(this);

    if (this.clientConfig.isPromiseAPI) {
      const observableConfig = Object.assign({}, this.clientConfig, {isPromiseAPI: false});
      this.observable = new SanityClient(observableConfig);
    }
  }

  Object.assign(SanityClient.prototype, dataMethods);
  Object.assign(SanityClient.prototype, {
    clone() {
      return new SanityClient(this.config())
    },

    config(newConfig) {
      if (typeof newConfig === 'undefined') {
        return Object.assign({}, this.clientConfig)
      }

      if (this.clientConfig && this.clientConfig.allowReconfigure === false) {
        throw new Error(
          'Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client'
        )
      }

      if (this.observable) {
        const observableConfig = Object.assign({}, newConfig, {isPromiseAPI: false});
        this.observable.config(observableConfig);
      }

      this.clientConfig = initConfig(newConfig, this.clientConfig || {});
      return this
    },

    withConfig(newConfig) {
      return new SanityClient({...this.config(), ...newConfig})
    },

    getUrl(uri, useCdn = false) {
      const base = useCdn ? this.clientConfig.cdnUrl : this.clientConfig.url;
      return `${base}/${uri.replace(/^\//, '')}`
    },

    isPromiseAPI() {
      return this.clientConfig.isPromiseAPI
    },

    _requestObservable(options) {
      const uri = options.url || options.uri;

      // If the `canUseCdn`-option is not set we detect it automatically based on the method + URL.
      // Only the /data endpoint is currently available through API-CDN.
      const canUseCdn =
        typeof options.canUseCdn === 'undefined'
          ? ['GET', 'HEAD'].indexOf(options.method || 'GET') >= 0 && uri.indexOf('/data/') === 0
          : options.canUseCdn;

      const useCdn = this.clientConfig.useCdn && canUseCdn;

      const tag =
        options.tag && this.clientConfig.requestTagPrefix
          ? [this.clientConfig.requestTagPrefix, options.tag].join('.')
          : options.tag || this.clientConfig.requestTagPrefix;

      if (tag) {
        options.query = {tag: requestTag(tag), ...options.query};
      }

      const reqOptions = getRequestOptions(
        this.clientConfig,
        Object.assign({}, options, {
          url: this.getUrl(uri, useCdn),
        })
      );

      return new Observable((subscriber) =>
        httpRequest(reqOptions, this.clientConfig.requester).subscribe(subscriber)
      )
    },

    request(options) {
      const observable = this._requestObservable(options).pipe(
        filter((event) => event.type === 'response'),
        map((event) => event.body)
      );

      return this.isPromiseAPI() ? lastValueFrom(observable) : observable
    },
  });

  SanityClient.Patch = Patch;
  SanityClient.Transaction = Transaction;
  SanityClient.ClientError = httpRequest.ClientError;
  SanityClient.ServerError = httpRequest.ServerError;
  SanityClient.requester = httpRequest.defaultRequester;

  return SanityClient;

}));
