"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _nodeShouldRetry = _interopRequireDefault(require("../util/node-shouldRetry"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const isStream = stream => stream !== null && typeof stream === 'object' && typeof stream.pipe === 'function';

const retry = (opts = {}) => {
  const maxRetries = opts.maxRetries || 5;
  const retryDelay = opts.retryDelay || getRetryDelay;
  const allowRetry = opts.shouldRetry || _nodeShouldRetry.default;
  return {
    onError: (err, context) => {
      const options = context.options;
      const max = options.maxRetries || maxRetries;
      const shouldRetry = options.shouldRetry || allowRetry;
      const attemptNumber = options.attemptNumber || 0; // We can't retry if body is a stream, since it'll be drained

      if (isStream(options.body)) {
        return err;
      } // Give up?


      if (!shouldRetry(err, attemptNumber, options) || attemptNumber >= max) {
        return err;
      } // Create a new context with an increased attempt number, so we can exit if we reach a limit


      const newContext = Object.assign({}, context, {
        options: Object.assign({}, options, {
          attemptNumber: attemptNumber + 1
        })
      }); // Wait a given amount of time before doing the request again

      setTimeout(() => context.channels.request.publish(newContext), retryDelay(attemptNumber)); // Signal that we've handled the error and that it should not propagate further

      return null;
    }
  };
};

retry.shouldRetry = _nodeShouldRetry.default;
var _default = retry;
exports.default = _default;

function getRetryDelay(attemptNum) {
  return 100 * Math.pow(2, attemptNum) + Math.random() * 100;
}

module.exports = exports.default;
//# sourceMappingURL=retry.js.map