"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _urlParse = _interopRequireDefault(require("url-parse"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var isReactNative = typeof navigator === 'undefined' ? false : navigator.product === 'ReactNative';
var has = Object.prototype.hasOwnProperty;
var defaultOptions = {
  timeout: isReactNative ? 60000 : 120000
};

var _default = function _default(opts) {
  var options = typeof opts === 'string' ? _extends({
    url: opts
  }, defaultOptions) : _extends({}, defaultOptions, opts); // Parse URL into parts

  var url = (0, _urlParse.default)(options.url, {}, // Don't use current browser location
  true // Parse query strings
  ); // Normalize timeouts

  options.timeout = normalizeTimeout(options.timeout); // Shallow-merge (override) existing query params

  if (options.query) {
    url.query = _extends({}, url.query, removeUndefined(options.query));
  } // Implicit POST if we have not specified a method but have a body


  options.method = options.body && !options.method ? 'POST' : (options.method || 'GET').toUpperCase(); // Stringify URL

  options.url = url.toString(stringifyQueryString);
  return options;
};

exports.default = _default;

function stringifyQueryString(obj) {
  var pairs = [];

  for (var key in obj) {
    if (has.call(obj, key)) {
      push(key, obj[key]);
    }
  }

  return pairs.length ? pairs.join('&') : '';

  function push(key, val) {
    if (Array.isArray(val)) {
      val.forEach(function (item) {
        return push(key, item);
      });
    } else {
      pairs.push([key, val].map(encodeURIComponent).join('='));
    }
  }
}

function normalizeTimeout(time) {
  if (time === false || time === 0) {
    return false;
  }

  if (time.connect || time.socket) {
    return time;
  }

  var delay = Number(time);

  if (isNaN(delay)) {
    return normalizeTimeout(defaultOptions.timeout);
  }

  return {
    connect: delay,
    socket: delay
  };
}

function removeUndefined(obj) {
  var target = {};

  for (var key in obj) {
    if (obj[key] !== undefined) {
      target[key] = obj[key];
    }
  }

  return target;
}

module.exports = exports.default;
//# sourceMappingURL=defaultOptionsProcessor.js.map