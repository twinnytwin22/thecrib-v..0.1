"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _nodeShouldRetry = _interopRequireDefault(require("../util/node-shouldRetry"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var isStream = function isStream(stream) {
  return stream !== null && _typeof(stream) === 'object' && typeof stream.pipe === 'function';
};

var retry = function retry() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var maxRetries = opts.maxRetries || 5;
  var retryDelay = opts.retryDelay || getRetryDelay;
  var allowRetry = opts.shouldRetry || _nodeShouldRetry.default;
  return {
    onError: function onError(err, context) {
      var options = context.options;
      var max = options.maxRetries || maxRetries;
      var shouldRetry = options.shouldRetry || allowRetry;
      var attemptNumber = options.attemptNumber || 0; // We can't retry if body is a stream, since it'll be drained

      if (isStream(options.body)) {
        return err;
      } // Give up?


      if (!shouldRetry(err, attemptNumber, options) || attemptNumber >= max) {
        return err;
      } // Create a new context with an increased attempt number, so we can exit if we reach a limit


      var newContext = _extends({}, context, {
        options: _extends({}, options, {
          attemptNumber: attemptNumber + 1
        })
      }); // Wait a given amount of time before doing the request again


      setTimeout(function () {
        return context.channels.request.publish(newContext);
      }, retryDelay(attemptNumber)); // Signal that we've handled the error and that it should not propagate further

      return null;
    }
  };
};

retry.shouldRetry = _nodeShouldRetry.default;
var _default = retry;
exports.default = _default;

function getRetryDelay(attemptNum) {
  return 100 * Math.pow(2, attemptNum) + Math.random() * 100;
}

module.exports = exports.default;
//# sourceMappingURL=retry.js.map