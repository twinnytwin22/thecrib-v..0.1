import {
  __esm,
  __export,
  __toCommonJS
} from "./chunk-U7HSCTZN.mjs";

// src/middleware/cancel/Cancel.js
var Cancel_exports = {};
__export(Cancel_exports, {
  default: () => Cancel_default
});
function Cancel(message) {
  this.message = message;
}
var Cancel_default;
var init_Cancel = __esm({
  "src/middleware/cancel/Cancel.js"() {
    Cancel.prototype.toString = function toString() {
      return `Cancel${this.message ? `: ${this.message}` : ""}`;
    };
    Cancel.prototype.__CANCEL__ = true;
    Cancel_default = Cancel;
  }
});

// src/middleware/promise.js
init_Cancel();

// src/middleware/cancel/CancelToken.js
var Cancel2 = (init_Cancel(), __toCommonJS(Cancel_exports));
function CancelToken(executor) {
  if (typeof executor !== "function") {
    throw new TypeError("executor must be a function.");
  }
  let resolvePromise = null;
  this.promise = new Promise((resolve) => {
    resolvePromise = resolve;
  });
  executor((message) => {
    if (this.reason) {
      return;
    }
    this.reason = new Cancel2(message);
    resolvePromise(this.reason);
  });
}
CancelToken.source = function() {
  let cancel;
  const token = new CancelToken((can) => {
    cancel = can;
  });
  return {
    token,
    cancel
  };
};
var CancelToken_default = CancelToken;

// src/middleware/cancel/isCancel.js
var isCancel_default = (value) => !!(value && value.__CANCEL__);

// src/middleware/promise.js
var globalPromise = typeof Promise === "function" && Promise;
var promise = (options = {}) => {
  const Promise2 = options.implementation || globalPromise;
  if (!Promise2) {
    throw new Error("`Promise` is not available in global scope, and no implementation was passed");
  }
  return {
    onReturn: (channels, context) => new Promise2((resolve, reject) => {
      const cancel = context.options.cancelToken;
      if (cancel) {
        cancel.promise.then((reason) => {
          channels.abort.publish(reason);
          reject(reason);
        });
      }
      channels.error.subscribe(reject);
      channels.response.subscribe((response) => {
        resolve(options.onlyBody ? response.body : response);
      });
      setTimeout(() => {
        try {
          channels.request.publish(context);
        } catch (err) {
          reject(err);
        }
      }, 0);
    })
  };
};
promise.Cancel = Cancel_default;
promise.CancelToken = CancelToken_default;
promise.isCancel = isCancel_default;
var promise_default = promise;

export {
  promise_default
};
//# sourceMappingURL=chunk-O346EM5K.mjs.map
