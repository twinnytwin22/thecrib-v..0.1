{
  "version": 3,
  "sources": ["../../src/middleware/cancel/Cancel.js", "../../src/middleware/promise.js", "../../src/middleware/cancel/CancelToken.js", "../../src/middleware/cancel/isCancel.js"],
  "sourcesContent": ["function Cancel(message) {\n  this.message = message\n}\n\nCancel.prototype.toString = function toString() {\n  return `Cancel${this.message ? `: ${this.message}` : ''}`\n}\n\nCancel.prototype.__CANCEL__ = true\n\nexport default Cancel\n", "import Cancel from './cancel/Cancel'\nimport CancelToken from './cancel/CancelToken'\nimport isCancel from './cancel/isCancel'\n\nconst globalPromise = typeof Promise === 'function' && Promise\n\nconst promise = (options = {}) => {\n  const Promise = options.implementation || globalPromise\n  if (!Promise) {\n    throw new Error('`Promise` is not available in global scope, and no implementation was passed')\n  }\n\n  return {\n    onReturn: (channels, context) =>\n      new Promise((resolve, reject) => {\n        const cancel = context.options.cancelToken\n        if (cancel) {\n          cancel.promise.then(reason => {\n            channels.abort.publish(reason)\n            reject(reason)\n          })\n        }\n\n        channels.error.subscribe(reject)\n        channels.response.subscribe(response => {\n          resolve(options.onlyBody ? response.body : response)\n        })\n\n        // Wait until next tick in case cancel has been performed\n        setTimeout(() => {\n          try {\n            channels.request.publish(context)\n          } catch (err) {\n            reject(err)\n          }\n        }, 0)\n      })\n  }\n}\n\npromise.Cancel = Cancel\npromise.CancelToken = CancelToken\npromise.isCancel = isCancel\n\nexport default promise\n", "const Cancel = require('./Cancel')\n\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.')\n  }\n\n  let resolvePromise = null\n  this.promise = new Promise(resolve => {\n    resolvePromise = resolve\n  })\n\n  executor(message => {\n    if (this.reason) {\n      // Cancellation has already been requested\n      return\n    }\n\n    this.reason = new Cancel(message)\n    resolvePromise(this.reason)\n  })\n}\n\nCancelToken.source = function() {\n  let cancel\n  const token = new CancelToken(can => {\n    cancel = can\n  })\n\n  return {\n    token: token,\n    cancel: cancel\n  }\n}\n\nexport default CancelToken\n", "export default value => !!(value && value.__CANCEL__)\n"],
  "mappings": ";;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA,SAAS,OAAO,SAAS;AACvB,OAAK,UAAU;AACjB;AAFA,IAUO;AAVP;AAAA;AAIA,WAAO,UAAU,WAAW,SAAS,WAAW;AAC9C,aAAO,SAAS,KAAK,UAAU,KAAK,KAAK,YAAY;AAAA,IACvD;AAEA,WAAO,UAAU,aAAa;AAE9B,IAAO,iBAAQ;AAAA;AAAA;;;ACVf;;;ACAA,IAAMA,UAAS;AAEf,SAAS,YAAY,UAAU;AAC7B,MAAI,OAAO,aAAa,YAAY;AAClC,UAAM,IAAI,UAAU,8BAA8B;AAAA,EACpD;AAEA,MAAI,iBAAiB;AACrB,OAAK,UAAU,IAAI,QAAQ,aAAW;AACpC,qBAAiB;AAAA,EACnB,CAAC;AAED,WAAS,aAAW;AAClB,QAAI,KAAK,QAAQ;AAEf;AAAA,IACF;AAEA,SAAK,SAAS,IAAIA,QAAO,OAAO;AAChC,mBAAe,KAAK,MAAM;AAAA,EAC5B,CAAC;AACH;AAEA,YAAY,SAAS,WAAW;AAC9B,MAAI;AACJ,QAAM,QAAQ,IAAI,YAAY,SAAO;AACnC,aAAS;AAAA,EACX,CAAC;AAED,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;AAEA,IAAO,sBAAQ;;;ACnCf,IAAO,mBAAQ,WAAS,CAAC,EAAE,SAAS,MAAM;;;AFI1C,IAAM,gBAAgB,OAAO,YAAY,cAAc;AAEvD,IAAM,UAAU,CAAC,UAAU,CAAC,MAAM;AAChC,QAAMC,WAAU,QAAQ,kBAAkB;AAC1C,MAAI,CAACA,UAAS;AACZ,UAAM,IAAI,MAAM,8EAA8E;AAAA,EAChG;AAEA,SAAO;AAAA,IACL,UAAU,CAAC,UAAU,YACnB,IAAIA,SAAQ,CAAC,SAAS,WAAW;AAC/B,YAAM,SAAS,QAAQ,QAAQ;AAC/B,UAAI,QAAQ;AACV,eAAO,QAAQ,KAAK,YAAU;AAC5B,mBAAS,MAAM,QAAQ,MAAM;AAC7B,iBAAO,MAAM;AAAA,QACf,CAAC;AAAA,MACH;AAEA,eAAS,MAAM,UAAU,MAAM;AAC/B,eAAS,SAAS,UAAU,cAAY;AACtC,gBAAQ,QAAQ,WAAW,SAAS,OAAO,QAAQ;AAAA,MACrD,CAAC;AAGD,iBAAW,MAAM;AACf,YAAI;AACF,mBAAS,QAAQ,QAAQ,OAAO;AAAA,QAClC,SAAS,KAAP;AACA,iBAAO,GAAG;AAAA,QACZ;AAAA,MACF,GAAG,CAAC;AAAA,IACN,CAAC;AAAA,EACL;AACF;AAEA,QAAQ,SAAS;AACjB,QAAQ,cAAc;AACtB,QAAQ,WAAW;AAEnB,IAAO,kBAAQ;",
  "names": ["Cancel", "Promise"]
}
