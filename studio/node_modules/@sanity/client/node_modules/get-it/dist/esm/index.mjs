import {
  defaultOptionsProcessor_default
} from "./chunk-UNUOMRCS.mjs";
import {
  defaultOptionsValidator_default
} from "./chunk-OZ7A3Q6G.mjs";
import {
  __commonJS,
  __toESM
} from "./chunk-U7HSCTZN.mjs";

// node_modules/same-origin/url-parser.js
var require_url_parser = __commonJS({
  "node_modules/same-origin/url-parser.js"(exports, module) {
    "use strict";
    var regex = /^(?:(?:(?:([^:\/#\?]+:)?(?:(?:\/\/)((?:((?:[^:@\/#\?]+)(?:\:(?:[^:@\/#\?]+))?)@)?(([^:\/#\?\]\[]+|\[[^\/\]@#?]+\])(?:\:([0-9]+))?))?)?)?((?:\/?(?:[^\/\?#]+\/+)*)(?:[^\?#]*)))?(\?[^#]+)?)(#.*)?/;
    module.exports = {
      regex,
      parse: function(url) {
        var match = regex.exec(url);
        if (!match) {
          return {};
        }
        return {
          protocol: (match[1] || "").toLowerCase() || void 0,
          hostname: (match[5] || "").toLowerCase() || void 0,
          port: match[6] || void 0
        };
      }
    };
  }
});

// node_modules/same-origin/index.js
var require_same_origin = __commonJS({
  "node_modules/same-origin/index.js"(exports, module) {
    "use strict";
    var url = require_url_parser();
    module.exports = function(uri1, uri2, ieMode) {
      if (uri1 === uri2) {
        return true;
      }
      var url1 = url.parse(uri1, false, true);
      var url2 = url.parse(uri2, false, true);
      var url1Port = url1.port | 0 || (url1.protocol === "https" ? 443 : 80);
      var url2Port = url2.port | 0 || (url2.protocol === "https" ? 443 : 80);
      var match = {
        proto: url1.protocol === url2.protocol,
        hostname: url1.hostname === url2.hostname,
        port: url1Port === url2Port
      };
      return match.proto && match.hostname && (match.port || ieMode);
    };
  }
});

// node_modules/parse-headers/parse-headers.js
var require_parse_headers = __commonJS({
  "node_modules/parse-headers/parse-headers.js"(exports, module) {
    var trim = function(string) {
      return string.replace(/^\s+|\s+$/g, "");
    };
    var isArray = function(arg) {
      return Object.prototype.toString.call(arg) === "[object Array]";
    };
    module.exports = function(headers) {
      if (!headers)
        return {};
      var result = {};
      var headersArr = trim(headers).split("\n");
      for (var i = 0; i < headersArr.length; i++) {
        var row = headersArr[i];
        var index = row.indexOf(":"), key = trim(row.slice(0, index)).toLowerCase(), value = trim(row.slice(index + 1));
        if (typeof result[key] === "undefined") {
          result[key] = value;
        } else if (isArray(result[key])) {
          result[key].push(value);
        } else {
          result[key] = [result[key], value];
        }
      }
      return result;
    };
  }
});

// node_modules/nano-pubsub/dist/esm/index.js
function createPubSub() {
  var subscribers = /* @__PURE__ */ Object.create(null);
  var nextId = 0;
  function subscribe(subscriber) {
    var id = nextId++;
    subscribers[id] = subscriber;
    return function unsubscribe() {
      delete subscribers[id];
    };
  }
  function publish(event) {
    for (var id in subscribers) {
      subscribers[id](event);
    }
  }
  return {
    publish,
    subscribe
  };
}

// src/util/middlewareReducer.js
var middlewareReducer_default = (middleware) => {
  const applyMiddleware = (hook, defaultValue, ...args) => {
    const bailEarly = hook === "onError";
    let value = defaultValue;
    for (let i = 0; i < middleware[hook].length; i++) {
      const handler = middleware[hook][i];
      value = handler(value, ...args);
      if (bailEarly && !value) {
        break;
      }
    }
    return value;
  };
  return applyMiddleware;
};

// src/request/browser-request.js
var import_same_origin = __toESM(require_same_origin());
var import_parse_headers = __toESM(require_parse_headers());

// src/request/browser/fetchXhr.js
function FetchXhr() {
  this.readyState = 0;
}
FetchXhr.prototype.open = function(method, url) {
  this._method = method;
  this._url = url;
  this._resHeaders = "";
  this.readyState = 1;
  this.onreadystatechange();
};
FetchXhr.prototype.abort = function() {
  if (this._controller) {
    this._controller.abort();
  }
};
FetchXhr.prototype.getAllResponseHeaders = function() {
  return this._resHeaders;
};
FetchXhr.prototype.setRequestHeader = function(key, value) {
  this._headers = this._headers || {};
  this._headers[key] = value;
};
FetchXhr.prototype.send = function(body) {
  const ctrl = this._controller = typeof AbortController === "function" && new AbortController();
  const textBody = this.responseType !== "arraybuffer";
  const options = {
    method: this._method,
    headers: this._headers,
    signal: ctrl && ctrl.signal || void 0,
    body
  };
  if (typeof document !== "undefined") {
    options.credentials = this.withCredentials ? "include" : "omit";
  }
  fetch(this._url, options).then((res) => {
    res.headers.forEach((value, key) => {
      this._resHeaders += `${key}: ${value}\r
`;
    });
    this.status = res.status;
    this.statusText = res.statusText;
    this.readyState = 3;
    return textBody ? res.text() : res.arrayBuffer();
  }).then((resBody) => {
    if (textBody) {
      this.responseText = resBody;
    } else {
      this.response = resBody;
    }
    this.readyState = 4;
    this.onreadystatechange();
  }).catch((err) => {
    if (err.name === "AbortError") {
      this.onabort();
      return;
    }
    this.onerror(err);
  });
};
var fetchXhr_default = FetchXhr;

// src/request/browser-request.js
var noop = function() {
};
var win = typeof document === "undefined" || typeof window === "undefined" ? void 0 : window;
var adapter = win ? "xhr" : "fetch";
var XmlHttpRequest = typeof XMLHttpRequest === "function" ? XMLHttpRequest : noop;
var hasXhr2 = "withCredentials" in new XmlHttpRequest();
var XDR = typeof XDomainRequest === "undefined" ? void 0 : XDomainRequest;
var CrossDomainRequest = hasXhr2 ? XmlHttpRequest : XDR;
if (!win) {
  XmlHttpRequest = fetchXhr_default;
  CrossDomainRequest = fetchXhr_default;
}
var browser_request_default = (context, callback) => {
  const opts = context.options;
  const options = context.applyMiddleware("finalizeOptions", opts);
  const timers = {};
  const cors = win && win.location && !(0, import_same_origin.default)(win.location.href, options.url);
  const injectedResponse = context.applyMiddleware("interceptRequest", void 0, {
    adapter,
    context
  });
  if (injectedResponse) {
    const cbTimer = setTimeout(callback, 0, null, injectedResponse);
    const cancel = () => clearTimeout(cbTimer);
    return { abort: cancel };
  }
  let xhr = cors ? new CrossDomainRequest() : new XmlHttpRequest();
  const isXdr = win && win.XDomainRequest && xhr instanceof win.XDomainRequest;
  const headers = options.headers;
  const delays = options.timeout;
  let aborted = false;
  let loaded = false;
  let timedOut = false;
  xhr.onerror = onError;
  xhr.ontimeout = onError;
  xhr.onabort = () => {
    stopTimers(true);
    aborted = true;
  };
  xhr.onprogress = () => {
  };
  const loadEvent = isXdr ? "onload" : "onreadystatechange";
  xhr[loadEvent] = () => {
    resetTimers();
    if (aborted || xhr.readyState !== 4 && !isXdr) {
      return;
    }
    if (xhr.status === 0) {
      return;
    }
    onLoad();
  };
  xhr.open(
    options.method,
    options.url,
    true
  );
  xhr.withCredentials = !!options.withCredentials;
  if (headers && xhr.setRequestHeader) {
    for (const key in headers) {
      if (headers.hasOwnProperty(key)) {
        xhr.setRequestHeader(key, headers[key]);
      }
    }
  } else if (headers && isXdr) {
    throw new Error("Headers cannot be set on an XDomainRequest object");
  }
  if (options.rawBody) {
    xhr.responseType = "arraybuffer";
  }
  context.applyMiddleware("onRequest", { options, adapter, request: xhr, context });
  xhr.send(options.body || null);
  if (delays) {
    timers.connect = setTimeout(() => timeoutRequest("ETIMEDOUT"), delays.connect);
  }
  return { abort };
  function abort() {
    aborted = true;
    if (xhr) {
      xhr.abort();
    }
  }
  function timeoutRequest(code) {
    timedOut = true;
    xhr.abort();
    const error = new Error(
      code === "ESOCKETTIMEDOUT" ? `Socket timed out on request to ${options.url}` : `Connection timed out on request to ${options.url}`
    );
    error.code = code;
    context.channels.error.publish(error);
  }
  function resetTimers() {
    if (!delays) {
      return;
    }
    stopTimers();
    timers.socket = setTimeout(() => timeoutRequest("ESOCKETTIMEDOUT"), delays.socket);
  }
  function stopTimers(force) {
    if (force || aborted || xhr.readyState >= 2 && timers.connect) {
      clearTimeout(timers.connect);
    }
    if (timers.socket) {
      clearTimeout(timers.socket);
    }
  }
  function onError(error) {
    if (loaded) {
      return;
    }
    stopTimers(true);
    loaded = true;
    xhr = null;
    const err = error || new Error(`Network error while attempting to reach ${options.url}`);
    err.isNetworkError = true;
    err.request = options;
    callback(err);
  }
  function reduceResponse() {
    let statusCode = xhr.status;
    let statusMessage = xhr.statusText;
    if (isXdr && statusCode === void 0) {
      statusCode = 200;
    } else if (statusCode > 12e3 && statusCode < 12156) {
      return onError();
    } else {
      statusCode = xhr.status === 1223 ? 204 : xhr.status;
      statusMessage = xhr.status === 1223 ? "No Content" : statusMessage;
    }
    return {
      body: xhr.response || xhr.responseText,
      url: options.url,
      method: options.method,
      headers: isXdr ? {} : (0, import_parse_headers.default)(xhr.getAllResponseHeaders()),
      statusCode,
      statusMessage
    };
  }
  function onLoad() {
    if (aborted || loaded || timedOut) {
      return;
    }
    if (xhr.status === 0) {
      onError(new Error("Unknown XHR error"));
      return;
    }
    stopTimers();
    loaded = true;
    callback(null, reduceResponse());
  }
};

// src/request/index.js
var request_default = browser_request_default;

// src/index.js
var pubsub = "default" in createPubSub ? createPubSub.default : createPubSub;
var channelNames = ["request", "response", "progress", "error", "abort"];
var middlehooks = [
  "processOptions",
  "validateOptions",
  "interceptRequest",
  "finalizeOptions",
  "onRequest",
  "onResponse",
  "onError",
  "onReturn",
  "onHeaders"
];
function createRequester(initMiddleware = [], httpRequest = request_default) {
  const loadedMiddleware = [];
  const middleware = middlehooks.reduce(
    (ware, name) => {
      ware[name] = ware[name] || [];
      return ware;
    },
    {
      processOptions: [defaultOptionsProcessor_default],
      validateOptions: [defaultOptionsValidator_default]
    }
  );
  function request(opts) {
    const channels = channelNames.reduce((target, name) => {
      target[name] = pubsub();
      return target;
    }, {});
    const applyMiddleware = middlewareReducer_default(middleware);
    const options = applyMiddleware("processOptions", opts);
    applyMiddleware("validateOptions", options);
    const context = { options, channels, applyMiddleware };
    let ongoingRequest = null;
    const unsubscribe = channels.request.subscribe((ctx) => {
      ongoingRequest = httpRequest(ctx, (err, res) => onResponse(err, res, ctx));
    });
    channels.abort.subscribe(() => {
      unsubscribe();
      if (ongoingRequest) {
        ongoingRequest.abort();
      }
    });
    const returnValue = applyMiddleware("onReturn", channels, context);
    if (returnValue === channels) {
      channels.request.publish(context);
    }
    return returnValue;
    function onResponse(reqErr, res, ctx) {
      let error = reqErr;
      let response = res;
      if (!error) {
        try {
          response = applyMiddleware("onResponse", res, ctx);
        } catch (err) {
          response = null;
          error = err;
        }
      }
      error = error && applyMiddleware("onError", error, ctx);
      if (error) {
        channels.error.publish(error);
      } else if (response) {
        channels.response.publish(response);
      }
    }
  }
  request.use = function use(newMiddleware) {
    if (!newMiddleware) {
      throw new Error("Tried to add middleware that resolved to falsey value");
    }
    if (typeof newMiddleware === "function") {
      throw new Error(
        "Tried to add middleware that was a function. It probably expects you to pass options to it."
      );
    }
    if (newMiddleware.onReturn && middleware.onReturn.length > 0) {
      throw new Error(
        "Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event"
      );
    }
    middlehooks.forEach((key) => {
      if (newMiddleware[key]) {
        middleware[key].push(newMiddleware[key]);
      }
    });
    loadedMiddleware.push(newMiddleware);
    return request;
  };
  request.clone = function clone() {
    return createRequester(loadedMiddleware);
  };
  initMiddleware.forEach(request.use);
  return request;
}
export {
  createRequester as default
};
//# sourceMappingURL=index.mjs.map
