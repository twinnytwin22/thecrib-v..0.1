{"version":3,"file":"index.production.js","sources":["../../../virtual-core/build/lib/utils.mjs","../../../virtual-core/build/lib/index.mjs","../../src/index.tsx"],"sourcesContent":["/**\n * virtual-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction memo(getDeps, fn, opts) {\n  let deps = [];\n  let result;\n  return () => {\n    let depTime;\n    if (opts.key && opts.debug != null && opts.debug()) depTime = Date.now();\n    const newDeps = getDeps();\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);\n    if (!depsChanged) {\n      return result;\n    }\n    deps = newDeps;\n    let resultTime;\n    if (opts.key && opts.debug != null && opts.debug()) resultTime = Date.now();\n    result = fn(...newDeps);\n    opts == null ? void 0 : opts.onChange == null ? void 0 : opts.onChange(result);\n    if (opts.key && opts.debug != null && opts.debug()) {\n      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n      const resultFpsPercentage = resultEndTime / 16;\n      const pad = (str, num) => {\n        str = String(str);\n        while (str.length < num) {\n          str = ' ' + str;\n        }\n        return str;\n      };\n      console.info(`%câ± ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);\n    }\n    return result;\n  };\n}\n\nexport { memo };\n//# sourceMappingURL=utils.mjs.map\n","/**\n * virtual-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { memo } from './utils.mjs';\nexport { memo } from './utils.mjs';\n\n//\n\n//\n\nconst defaultKeyExtractor = index => index;\nconst defaultRangeExtractor = range => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n  return arr;\n};\nconst memoRectCallback = (instance, cb) => {\n  let prev = {\n    height: -1,\n    width: -1\n  };\n  return rect => {\n    if (instance.options.horizontal ? rect.width !== prev.width : rect.height !== prev.height) {\n      cb(rect);\n    }\n    prev = rect;\n  };\n};\nconst observeElementRect = (instance, cb) => {\n  const observer = new ResizeObserver(entries => {\n    var _entries$, _entries$2;\n    cb({\n      width: (_entries$ = entries[0]) == null ? void 0 : _entries$.contentRect.width,\n      height: (_entries$2 = entries[0]) == null ? void 0 : _entries$2.contentRect.height\n    });\n  });\n  if (!instance.scrollElement) {\n    return;\n  }\n  cb(instance.scrollElement.getBoundingClientRect());\n  observer.observe(instance.scrollElement);\n  return () => {\n    observer.unobserve(instance.scrollElement);\n  };\n};\nconst observeWindowRect = (instance, cb) => {\n  const memoizedCallback = memoRectCallback(instance, cb);\n  const onResize = () => memoizedCallback({\n    width: instance.scrollElement.innerWidth,\n    height: instance.scrollElement.innerHeight\n  });\n  if (!instance.scrollElement) {\n    return;\n  }\n  onResize();\n  instance.scrollElement.addEventListener('resize', onResize, {\n    capture: false,\n    passive: true\n  });\n  return () => {\n    instance.scrollElement.removeEventListener('resize', onResize);\n  };\n};\nconst scrollProps = {\n  element: ['scrollLeft', 'scrollTop'],\n  window: ['scrollX', 'scrollY']\n};\nconst createOffsetObserver = mode => {\n  return (instance, cb) => {\n    if (!instance.scrollElement) {\n      return;\n    }\n    const propX = scrollProps[mode][0];\n    const propY = scrollProps[mode][1];\n    let prevX = instance.scrollElement[propX];\n    let prevY = instance.scrollElement[propY];\n    const scroll = () => {\n      const offset = instance.scrollElement[instance.options.horizontal ? propX : propY];\n      cb(Math.max(0, offset - instance.options.scrollMargin));\n    };\n    scroll();\n    const onScroll = e => {\n      const target = e.currentTarget;\n      const scrollX = target[propX];\n      const scrollY = target[propY];\n      if (instance.options.horizontal ? prevX - scrollX : prevY - scrollY) {\n        scroll();\n      }\n      prevX = scrollX;\n      prevY = scrollY;\n    };\n    instance.scrollElement.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true\n    });\n    return () => {\n      instance.scrollElement.removeEventListener('scroll', onScroll);\n    };\n  };\n};\nconst observeElementOffset = createOffsetObserver('element');\nconst observeWindowOffset = createOffsetObserver('window');\nconst measureElement = (element, instance) => {\n  return Math.round(element.getBoundingClientRect()[instance.options.horizontal ? 'width' : 'height']);\n};\nconst windowScroll = (offset, _ref, instance) => {\n  var _instance$scrollEleme;\n  let {\n    adjustments,\n    behavior,\n    sync\n  } = _ref;\n  const toOffset = (sync ? offset : offset + instance.options.scrollMargin) + (adjustments ?? 0);\n  (_instance$scrollEleme = instance.scrollElement) == null ? void 0 : _instance$scrollEleme.scrollTo == null ? void 0 : _instance$scrollEleme.scrollTo({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior\n  });\n};\nconst elementScroll = (offset, _ref2, instance) => {\n  var _instance$scrollEleme2;\n  let {\n    adjustments,\n    behavior,\n    sync\n  } = _ref2;\n  const toOffset = (sync ? offset : offset + instance.options.scrollMargin) + (adjustments ?? 0);\n  (_instance$scrollEleme2 = instance.scrollElement) == null ? void 0 : _instance$scrollEleme2.scrollTo == null ? void 0 : _instance$scrollEleme2.scrollTo({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior\n  });\n};\nclass Virtualizer {\n  constructor(_opts) {\n    var _this = this;\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.isScrolling = false;\n    this.isScrollingTimeoutId = null;\n    this.measurementsCache = [];\n    this.itemMeasurementsCache = {};\n    this.pendingMeasuredCacheIndexes = [];\n    this.scrollAdjustments = 0;\n    this.measureElementCache = {};\n    this.pendingScrollToIndexCallback = null;\n    this.getResizeObserver = (() => {\n      let _ro = null;\n      return () => {\n        if (_ro) {\n          return _ro;\n        } else if (typeof ResizeObserver !== 'undefined') {\n          return _ro = new ResizeObserver(entries => {\n            entries.forEach(entry => {\n              this._measureElement(entry.target, false);\n            });\n          });\n        } else {\n          return null;\n        }\n      };\n    })();\n    this.range = {\n      startIndex: 0,\n      endIndex: 0\n    };\n    this.setOptions = opts => {\n      Object.entries(opts).forEach(_ref3 => {\n        let [key, value] = _ref3;\n        if (typeof value === 'undefined') delete opts[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        onChange: () => {},\n        measureElement,\n        initialRect: {\n          width: 0,\n          height: 0\n        },\n        scrollMargin: 0,\n        scrollingDelay: 150,\n        indexAttribute: 'data-index',\n        ...opts\n      };\n    };\n    this.notify = () => {\n      var _this$options$onChang, _this$options;\n      (_this$options$onChang = (_this$options = this.options).onChange) == null ? void 0 : _this$options$onChang.call(_this$options, this);\n    };\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach(d => d());\n      this.unsubs = [];\n      this.scrollElement = null;\n    };\n    this._didMount = () => {\n      const ro = this.getResizeObserver();\n      Object.values(this.measureElementCache).forEach(node => ro == null ? void 0 : ro.observe(node));\n      return () => {\n        ro == null ? void 0 : ro.disconnect();\n        this.cleanup();\n      };\n    };\n    this._willUpdate = () => {\n      var _this$pendingScrollTo;\n      (_this$pendingScrollTo = this.pendingScrollToIndexCallback) == null ? void 0 : _this$pendingScrollTo.call(this);\n      const scrollElement = this.options.getScrollElement();\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n        this.scrollElement = scrollElement;\n        this._scrollToOffset(this.scrollOffset, {\n          adjustments: undefined,\n          behavior: undefined,\n          sync: true\n        });\n        this.unsubs.push(this.options.observeElementRect(this, rect => {\n          this.scrollRect = rect;\n          this.calculateRange();\n        }));\n        this.unsubs.push(this.options.observeElementOffset(this, offset => {\n          if (this.isScrollingTimeoutId !== null) {\n            clearTimeout(this.isScrollingTimeoutId);\n            this.isScrollingTimeoutId = null;\n          }\n          if (this.scrollOffset !== offset) {\n            this.scrollOffset = offset;\n            this.isScrolling = true;\n            this.scrollAdjustments = 0;\n            this.isScrollingTimeoutId = setTimeout(() => {\n              this.isScrollingTimeoutId = null;\n              this.isScrolling = false;\n              this.notify();\n            }, this.options.scrollingDelay);\n          } else {\n            this.isScrolling = false;\n            this.scrollAdjustments = 0;\n          }\n          this.calculateRange();\n        }));\n      } else if (!this.isScrolling) {\n        this.calculateRange();\n      }\n    };\n    this.getSize = () => {\n      return this.scrollRect[this.options.horizontal ? 'width' : 'height'];\n    };\n    this.getMeasurements = memo(() => [this.options.count, this.options.paddingStart, this.options.getItemKey, this.itemMeasurementsCache], (count, paddingStart, getItemKey, measurementsCache) => {\n      const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n      this.pendingMeasuredCacheIndexes = [];\n      const measurements = this.measurementsCache.slice(0, min);\n      for (let i = min; i < count; i++) {\n        const key = getItemKey(i);\n        const measuredSize = measurementsCache[key];\n        const start = measurements[i - 1] ? measurements[i - 1].end : paddingStart;\n        const size = typeof measuredSize === 'number' ? measuredSize : this.options.estimateSize(i);\n        const end = start + size;\n        measurements[i] = {\n          index: i,\n          start,\n          size,\n          end,\n          key\n        };\n      }\n      this.measurementsCache = measurements;\n      return measurements;\n    }, {\n      key: process.env.NODE_ENV !== 'production' && 'getMeasurements',\n      debug: () => this.options.debug\n    });\n    this.calculateRange = memo(() => [this.getMeasurements(), this.getSize(), this.scrollOffset], (measurements, outerSize, scrollOffset) => {\n      const range = calculateRange({\n        measurements,\n        outerSize,\n        scrollOffset\n      });\n      if (range.startIndex !== this.range.startIndex || range.endIndex !== this.range.endIndex) {\n        this.range = range;\n        this.notify();\n      }\n      return this.range;\n    }, {\n      key: process.env.NODE_ENV !== 'production' && 'calculateRange',\n      debug: () => this.options.debug\n    });\n    this.getIndexes = memo(() => [this.options.rangeExtractor, this.range, this.options.overscan, this.options.count], (rangeExtractor, range, overscan, count) => {\n      return rangeExtractor({\n        ...range,\n        overscan,\n        count: count\n      });\n    }, {\n      key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n      debug: () => this.options.debug\n    });\n    this.indexFromElement = node => {\n      const attributeName = this.options.indexAttribute;\n      const indexStr = node.getAttribute(attributeName);\n      if (!indexStr) {\n        console.warn(`Missing attribute name '${attributeName}={index}' on measured element.`);\n        return -1;\n      }\n      return parseInt(indexStr, 10);\n    };\n    this._measureElement = (node, _sync) => {\n      const index = this.indexFromElement(node);\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return;\n      }\n      const prevNode = this.measureElementCache[item.key];\n      const ro = this.getResizeObserver();\n      if (!node.isConnected) {\n        if (prevNode) {\n          ro == null ? void 0 : ro.unobserve(prevNode);\n          delete this.measureElementCache[item.key];\n        }\n        return;\n      }\n      if (!prevNode || prevNode !== node) {\n        if (prevNode) {\n          ro == null ? void 0 : ro.unobserve(prevNode);\n        }\n        this.measureElementCache[item.key] = node;\n        ro == null ? void 0 : ro.observe(node);\n      }\n      const measuredItemSize = this.options.measureElement(node, this);\n      const itemSize = this.itemMeasurementsCache[item.key] ?? item.size;\n      const delta = measuredItemSize - itemSize;\n      if (delta !== 0) {\n        if (item.start < this.scrollOffset && this.isScrolling) {\n          if (process.env.NODE_ENV !== 'production' && this.options.debug) {\n            console.info('correction', delta);\n          }\n          this._scrollToOffset(this.scrollOffset, {\n            adjustments: this.scrollAdjustments += delta,\n            behavior: undefined,\n            sync: false\n          });\n        }\n        this.pendingMeasuredCacheIndexes.push(index);\n        this.itemMeasurementsCache = {\n          ...this.itemMeasurementsCache,\n          [item.key]: measuredItemSize\n        };\n        this.notify();\n      }\n    };\n    this.measureElement = node => {\n      if (!node) {\n        return;\n      }\n      this._measureElement(node, true);\n    };\n    this.getVirtualItems = memo(() => [this.getIndexes(), this.getMeasurements()], (indexes, measurements) => {\n      const virtualItems = [];\n      for (let k = 0, len = indexes.length; k < len; k++) {\n        const i = indexes[k];\n        const measurement = measurements[i];\n        virtualItems.push(measurement);\n      }\n      return virtualItems;\n    }, {\n      key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n      debug: () => this.options.debug\n    });\n    this.scrollToOffset = function (toOffset, _temp) {\n      let {\n        align = 'start',\n        behavior\n      } = _temp === void 0 ? {} : _temp;\n      const offset = _this.scrollOffset;\n      const size = _this.getSize();\n      if (align === 'auto') {\n        if (toOffset <= offset) {\n          align = 'start';\n        } else if (toOffset >= offset + size) {\n          align = 'end';\n        } else {\n          align = 'start';\n        }\n      }\n      const options = {\n        adjustments: undefined,\n        behavior,\n        sync: false\n      };\n      if (align === 'start') {\n        _this._scrollToOffset(toOffset, options);\n      } else if (align === 'end') {\n        _this._scrollToOffset(toOffset - size, options);\n      } else if (align === 'center') {\n        _this._scrollToOffset(toOffset - size / 2, options);\n      }\n    };\n    this.scrollToIndex = function (index, _temp2) {\n      let {\n        align = 'auto',\n        ...rest\n      } = _temp2 === void 0 ? {} : _temp2;\n      _this.pendingScrollToIndexCallback = null;\n      const measurements = _this.getMeasurements();\n      const offset = _this.scrollOffset;\n      const size = _this.getSize();\n      const {\n        count\n      } = _this.options;\n      const measurement = measurements[Math.max(0, Math.min(index, count - 1))];\n      if (!measurement) {\n        return;\n      }\n      if (align === 'auto') {\n        if (measurement.end >= offset + size - _this.options.scrollPaddingEnd) {\n          align = 'end';\n        } else if (measurement.start <= offset + _this.options.scrollPaddingStart) {\n          align = 'start';\n        } else {\n          return;\n        }\n      }\n      const toOffset = align === 'end' ? measurement.end + _this.options.scrollPaddingEnd : measurement.start - _this.options.scrollPaddingStart;\n      _this.scrollToOffset(toOffset, {\n        align,\n        ...rest\n      });\n      const isDynamic = Object.keys(_this.measureElementCache).length > 0;\n      if (isDynamic) {\n        const didSeen = () => typeof _this.itemMeasurementsCache[_this.options.getItemKey(index)] === 'number';\n        if (!didSeen()) {\n          _this.pendingScrollToIndexCallback = () => {\n            if (didSeen()) {\n              _this.pendingScrollToIndexCallback = null;\n              _this.scrollToIndex(index, {\n                align,\n                ...rest\n              });\n            }\n          };\n        }\n      }\n    };\n    this.getTotalSize = () => {\n      var _this$getMeasurements;\n      return (((_this$getMeasurements = this.getMeasurements()[this.options.count - 1]) == null ? void 0 : _this$getMeasurements.end) || this.options.paddingStart) + this.options.paddingEnd;\n    };\n    this._scrollToOffset = (offset, _ref4) => {\n      let {\n        adjustments,\n        behavior,\n        sync\n      } = _ref4;\n      this.options.scrollToFn(offset, {\n        behavior,\n        sync,\n        adjustments\n      }, this);\n    };\n    this.measure = () => {\n      this.itemMeasurementsCache = {};\n      this.notify();\n    };\n    this.setOptions(_opts);\n    this.scrollRect = this.options.initialRect;\n    this.scrollOffset = this.options.initialOffset;\n    this.calculateRange();\n  }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange(_ref5) {\n  let {\n    measurements,\n    outerSize,\n    scrollOffset\n  } = _ref5;\n  const count = measurements.length - 1;\n  const getOffset = index => measurements[index].start;\n  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\n  let endIndex = startIndex;\n  while (endIndex < count && measurements[endIndex].end < scrollOffset + outerSize) {\n    endIndex++;\n  }\n  return {\n    startIndex,\n    endIndex\n  };\n}\n\nexport { Virtualizer, defaultKeyExtractor, defaultRangeExtractor, elementScroll, measureElement, observeElementOffset, observeElementRect, observeWindowOffset, observeWindowRect, windowScroll };\n//# sourceMappingURL=index.mjs.map\n","import * as React from 'react'\nimport {\n  elementScroll,\n  observeElementOffset,\n  observeElementRect,\n  observeWindowOffset,\n  observeWindowRect,\n  PartialKeys,\n  Virtualizer,\n  VirtualizerOptions,\n  windowScroll,\n} from '@tanstack/virtual-core'\nexport * from '@tanstack/virtual-core'\n\n//\n\nconst useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nfunction useVirtualizerBase<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n>(\n  options: VirtualizerOptions<TScrollElement, TItemElement>,\n): Virtualizer<TScrollElement, TItemElement> {\n  const rerender = React.useReducer(() => ({}), {})[1]\n\n  const resolvedOptions: VirtualizerOptions<TScrollElement, TItemElement> = {\n    ...options,\n    onChange: (instance) => {\n      rerender()\n      options.onChange?.(instance)\n    },\n  }\n\n  const [instance] = React.useState(\n    () => new Virtualizer<TScrollElement, TItemElement>(resolvedOptions),\n  )\n\n  instance.setOptions(resolvedOptions)\n\n  React.useEffect(() => {\n    return instance._didMount()\n  }, [])\n\n  useIsomorphicLayoutEffect(() => {\n    return instance._willUpdate()\n  })\n\n  return instance\n}\n\nexport function useVirtualizer<\n  TScrollElement extends Element,\n  TItemElement extends Element,\n>(\n  options: PartialKeys<\n    VirtualizerOptions<TScrollElement, TItemElement>,\n    'observeElementRect' | 'observeElementOffset' | 'scrollToFn'\n  >,\n): Virtualizer<TScrollElement, TItemElement> {\n  return useVirtualizerBase<TScrollElement, TItemElement>({\n    observeElementRect: observeElementRect,\n    observeElementOffset: observeElementOffset,\n    scrollToFn: elementScroll,\n    ...options,\n  })\n}\n\nexport function useWindowVirtualizer<TItemElement extends Element>(\n  options: PartialKeys<\n    VirtualizerOptions<Window, TItemElement>,\n    | 'getScrollElement'\n    | 'observeElementRect'\n    | 'observeElementOffset'\n    | 'scrollToFn'\n  >,\n): Virtualizer<Window, TItemElement> {\n  return useVirtualizerBase<Window, TItemElement>({\n    getScrollElement: () => (typeof window !== 'undefined' ? window : null!),\n    observeElementRect: observeWindowRect,\n    observeElementOffset: observeWindowOffset,\n    scrollToFn: windowScroll,\n    ...options,\n  })\n}\n"],"names":["memo","getDeps","fn","opts","result","deps","depTime","key","debug","Date","now","newDeps","length","some","dep","index","resultTime","onChange","depEndTime","Math","round","resultEndTime","resultFpsPercentage","pad","str","num","String","console","info","max","min","defaultKeyExtractor","defaultRangeExtractor","range","start","startIndex","overscan","end","endIndex","count","arr","i","push","observeElementRect","instance","cb","observer","ResizeObserver","entries","_entries$","_entries$2","width","contentRect","height","scrollElement","getBoundingClientRect","observe","unobserve","observeWindowRect","memoizedCallback","prev","rect","options","horizontal","memoRectCallback","onResize","innerWidth","innerHeight","addEventListener","capture","passive","removeEventListener","scrollProps","element","window","createOffsetObserver","mode","propX","propY","prevX","prevY","scroll","offset","scrollMargin","onScroll","e","target","currentTarget","scrollX","scrollY","observeElementOffset","observeWindowOffset","measureElement","windowScroll","_ref","_instance$scrollEleme","adjustments","behavior","sync","toOffset","scrollTo","elementScroll","_ref2","_instance$scrollEleme2","Virtualizer","constructor","_opts","_this","this","unsubs","isScrolling","isScrollingTimeoutId","measurementsCache","itemMeasurementsCache","pendingMeasuredCacheIndexes","scrollAdjustments","measureElementCache","pendingScrollToIndexCallback","getResizeObserver","_ro","forEach","entry","_measureElement","setOptions","Object","_ref3","value","initialOffset","paddingStart","paddingEnd","scrollPaddingStart","scrollPaddingEnd","getItemKey","rangeExtractor","initialRect","scrollingDelay","indexAttribute","notify","_this$options$onChang","_this$options","call","cleanup","filter","Boolean","d","_didMount","ro","values","node","disconnect","_willUpdate","_this$pendingScrollTo","getScrollElement","_scrollToOffset","scrollOffset","undefined","scrollRect","calculateRange","clearTimeout","setTimeout","getSize","getMeasurements","measurements","slice","measuredSize","size","estimateSize","outerSize","_ref5","low","high","getCurrentValue","middle","currentValue","findNearestBinarySearch","getIndexes","indexFromElement","attributeName","indexStr","getAttribute","parseInt","warn","_sync","item","prevNode","isConnected","measuredItemSize","delta","getVirtualItems","indexes","virtualItems","k","len","measurement","scrollToOffset","_temp","align","scrollToIndex","_temp2","rest","keys","didSeen","getTotalSize","_this$getMeasurements","_ref4","scrollToFn","measure","useIsomorphicLayoutEffect","React","useLayoutEffect","useEffect","useVirtualizerBase","rerender","useReducer","resolvedOptions","useState"],"mappings":"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"}