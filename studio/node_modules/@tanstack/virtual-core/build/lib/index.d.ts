export * from './utils';
type ScrollAlignment = 'start' | 'center' | 'end' | 'auto';
type ScrollBehavior = 'auto' | 'smooth';
export interface ScrollToOptions {
    align?: ScrollAlignment;
    behavior?: ScrollBehavior;
}
type ScrollToOffsetOptions = ScrollToOptions;
type ScrollToIndexOptions = ScrollToOptions;
export interface Range {
    startIndex: number;
    endIndex: number;
    overscan: number;
    count: number;
}
type Key = number | string;
export interface VirtualItem {
    key: Key;
    index: number;
    start: number;
    end: number;
    size: number;
}
interface Rect {
    width: number;
    height: number;
}
export declare const defaultKeyExtractor: (index: number) => number;
export declare const defaultRangeExtractor: (range: Range) => number[];
export declare const observeElementRect: (instance: Virtualizer<any, any>, cb: (rect: Rect) => void) => (() => void) | undefined;
export declare const observeWindowRect: (instance: Virtualizer<any, any>, cb: (rect: Rect) => void) => (() => void) | undefined;
export declare const observeElementOffset: (instance: Virtualizer<any, any>, cb: (offset: number) => void) => (() => void) | undefined;
export declare const observeWindowOffset: (instance: Virtualizer<any, any>, cb: (offset: number) => void) => (() => void) | undefined;
export declare const measureElement: <TItemElement extends Element>(element: TItemElement, instance: Virtualizer<any, TItemElement>) => number;
export declare const windowScroll: <T extends Window>(offset: number, { adjustments, behavior, sync, }: {
    adjustments?: number | undefined;
    behavior?: ScrollBehavior | undefined;
    sync: boolean;
}, instance: Virtualizer<T, any>) => void;
export declare const elementScroll: <T extends Element>(offset: number, { adjustments, behavior, sync, }: {
    adjustments?: number | undefined;
    behavior?: ScrollBehavior | undefined;
    sync: boolean;
}, instance: Virtualizer<T, any>) => void;
export interface VirtualizerOptions<TScrollElement extends Element | Window, TItemElement extends Element> {
    count: number;
    getScrollElement: () => TScrollElement | null;
    estimateSize: (index: number) => number;
    scrollToFn: (offset: number, options: {
        adjustments?: number;
        behavior?: ScrollBehavior;
        sync: boolean;
    }, instance: Virtualizer<TScrollElement, TItemElement>) => void;
    observeElementRect: (instance: Virtualizer<TScrollElement, TItemElement>, cb: (rect: Rect) => void) => void | (() => void);
    observeElementOffset: (instance: Virtualizer<TScrollElement, TItemElement>, cb: (offset: number) => void) => void | (() => void);
    debug?: any;
    initialRect?: Rect;
    onChange?: (instance: Virtualizer<TScrollElement, TItemElement>) => void;
    measureElement?: (el: TItemElement, instance: Virtualizer<TScrollElement, TItemElement>) => number;
    overscan?: number;
    horizontal?: boolean;
    paddingStart?: number;
    paddingEnd?: number;
    scrollPaddingStart?: number;
    scrollPaddingEnd?: number;
    initialOffset?: number;
    getItemKey?: (index: number) => Key;
    rangeExtractor?: (range: Range) => number[];
    scrollMargin?: number;
    scrollingDelay?: number;
    indexAttribute?: string;
}
export declare class Virtualizer<TScrollElement extends Element | Window, TItemElement extends Element> {
    private unsubs;
    options: Required<VirtualizerOptions<TScrollElement, TItemElement>>;
    scrollElement: TScrollElement | null;
    isScrolling: boolean;
    private isScrollingTimeoutId;
    measurementsCache: VirtualItem[];
    private itemMeasurementsCache;
    private pendingMeasuredCacheIndexes;
    private scrollRect;
    private scrollOffset;
    private scrollAdjustments;
    private measureElementCache;
    private pendingScrollToIndexCallback;
    private getResizeObserver;
    range: {
        startIndex: number;
        endIndex: number;
    };
    constructor(opts: VirtualizerOptions<TScrollElement, TItemElement>);
    setOptions: (opts: VirtualizerOptions<TScrollElement, TItemElement>) => void;
    private notify;
    private cleanup;
    _didMount: () => () => void;
    _willUpdate: () => void;
    private getSize;
    private getMeasurements;
    calculateRange: () => {
        startIndex: number;
        endIndex: number;
    };
    private getIndexes;
    indexFromElement: (node: TItemElement) => number;
    private _measureElement;
    measureElement: (node: TItemElement | null) => void;
    getVirtualItems: () => VirtualItem[];
    scrollToOffset: (toOffset: number, { align, behavior }?: ScrollToOffsetOptions) => void;
    scrollToIndex: (index: number, { align, ...rest }?: ScrollToIndexOptions) => void;
    getTotalSize: () => number;
    private _scrollToOffset;
    measure: () => void;
}
