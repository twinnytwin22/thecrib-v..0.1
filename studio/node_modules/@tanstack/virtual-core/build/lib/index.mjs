/**
 * virtual-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
import { memo } from './utils.mjs';
export { memo } from './utils.mjs';

//

//

const defaultKeyExtractor = index => index;
const defaultRangeExtractor = range => {
  const start = Math.max(range.startIndex - range.overscan, 0);
  const end = Math.min(range.endIndex + range.overscan, range.count - 1);
  const arr = [];
  for (let i = start; i <= end; i++) {
    arr.push(i);
  }
  return arr;
};
const memoRectCallback = (instance, cb) => {
  let prev = {
    height: -1,
    width: -1
  };
  return rect => {
    if (instance.options.horizontal ? rect.width !== prev.width : rect.height !== prev.height) {
      cb(rect);
    }
    prev = rect;
  };
};
const observeElementRect = (instance, cb) => {
  const observer = new ResizeObserver(entries => {
    var _entries$, _entries$2;
    cb({
      width: (_entries$ = entries[0]) == null ? void 0 : _entries$.contentRect.width,
      height: (_entries$2 = entries[0]) == null ? void 0 : _entries$2.contentRect.height
    });
  });
  if (!instance.scrollElement) {
    return;
  }
  cb(instance.scrollElement.getBoundingClientRect());
  observer.observe(instance.scrollElement);
  return () => {
    observer.unobserve(instance.scrollElement);
  };
};
const observeWindowRect = (instance, cb) => {
  const memoizedCallback = memoRectCallback(instance, cb);
  const onResize = () => memoizedCallback({
    width: instance.scrollElement.innerWidth,
    height: instance.scrollElement.innerHeight
  });
  if (!instance.scrollElement) {
    return;
  }
  onResize();
  instance.scrollElement.addEventListener('resize', onResize, {
    capture: false,
    passive: true
  });
  return () => {
    instance.scrollElement.removeEventListener('resize', onResize);
  };
};
const scrollProps = {
  element: ['scrollLeft', 'scrollTop'],
  window: ['scrollX', 'scrollY']
};
const createOffsetObserver = mode => {
  return (instance, cb) => {
    if (!instance.scrollElement) {
      return;
    }
    const propX = scrollProps[mode][0];
    const propY = scrollProps[mode][1];
    let prevX = instance.scrollElement[propX];
    let prevY = instance.scrollElement[propY];
    const scroll = () => {
      const offset = instance.scrollElement[instance.options.horizontal ? propX : propY];
      cb(Math.max(0, offset - instance.options.scrollMargin));
    };
    scroll();
    const onScroll = e => {
      const target = e.currentTarget;
      const scrollX = target[propX];
      const scrollY = target[propY];
      if (instance.options.horizontal ? prevX - scrollX : prevY - scrollY) {
        scroll();
      }
      prevX = scrollX;
      prevY = scrollY;
    };
    instance.scrollElement.addEventListener('scroll', onScroll, {
      capture: false,
      passive: true
    });
    return () => {
      instance.scrollElement.removeEventListener('scroll', onScroll);
    };
  };
};
const observeElementOffset = createOffsetObserver('element');
const observeWindowOffset = createOffsetObserver('window');
const measureElement = (element, instance) => {
  return Math.round(element.getBoundingClientRect()[instance.options.horizontal ? 'width' : 'height']);
};
const windowScroll = (offset, _ref, instance) => {
  var _instance$scrollEleme;
  let {
    adjustments,
    behavior,
    sync
  } = _ref;
  const toOffset = (sync ? offset : offset + instance.options.scrollMargin) + (adjustments ?? 0);
  (_instance$scrollEleme = instance.scrollElement) == null ? void 0 : _instance$scrollEleme.scrollTo == null ? void 0 : _instance$scrollEleme.scrollTo({
    [instance.options.horizontal ? 'left' : 'top']: toOffset,
    behavior
  });
};
const elementScroll = (offset, _ref2, instance) => {
  var _instance$scrollEleme2;
  let {
    adjustments,
    behavior,
    sync
  } = _ref2;
  const toOffset = (sync ? offset : offset + instance.options.scrollMargin) + (adjustments ?? 0);
  (_instance$scrollEleme2 = instance.scrollElement) == null ? void 0 : _instance$scrollEleme2.scrollTo == null ? void 0 : _instance$scrollEleme2.scrollTo({
    [instance.options.horizontal ? 'left' : 'top']: toOffset,
    behavior
  });
};
class Virtualizer {
  constructor(_opts) {
    var _this = this;
    this.unsubs = [];
    this.scrollElement = null;
    this.isScrolling = false;
    this.isScrollingTimeoutId = null;
    this.measurementsCache = [];
    this.itemMeasurementsCache = {};
    this.pendingMeasuredCacheIndexes = [];
    this.scrollAdjustments = 0;
    this.measureElementCache = {};
    this.pendingScrollToIndexCallback = null;
    this.getResizeObserver = (() => {
      let _ro = null;
      return () => {
        if (_ro) {
          return _ro;
        } else if (typeof ResizeObserver !== 'undefined') {
          return _ro = new ResizeObserver(entries => {
            entries.forEach(entry => {
              this._measureElement(entry.target, false);
            });
          });
        } else {
          return null;
        }
      };
    })();
    this.range = {
      startIndex: 0,
      endIndex: 0
    };
    this.setOptions = opts => {
      Object.entries(opts).forEach(_ref3 => {
        let [key, value] = _ref3;
        if (typeof value === 'undefined') delete opts[key];
      });
      this.options = {
        debug: false,
        initialOffset: 0,
        overscan: 1,
        paddingStart: 0,
        paddingEnd: 0,
        scrollPaddingStart: 0,
        scrollPaddingEnd: 0,
        horizontal: false,
        getItemKey: defaultKeyExtractor,
        rangeExtractor: defaultRangeExtractor,
        onChange: () => {},
        measureElement,
        initialRect: {
          width: 0,
          height: 0
        },
        scrollMargin: 0,
        scrollingDelay: 150,
        indexAttribute: 'data-index',
        ...opts
      };
    };
    this.notify = () => {
      var _this$options$onChang, _this$options;
      (_this$options$onChang = (_this$options = this.options).onChange) == null ? void 0 : _this$options$onChang.call(_this$options, this);
    };
    this.cleanup = () => {
      this.unsubs.filter(Boolean).forEach(d => d());
      this.unsubs = [];
      this.scrollElement = null;
    };
    this._didMount = () => {
      const ro = this.getResizeObserver();
      Object.values(this.measureElementCache).forEach(node => ro == null ? void 0 : ro.observe(node));
      return () => {
        ro == null ? void 0 : ro.disconnect();
        this.cleanup();
      };
    };
    this._willUpdate = () => {
      var _this$pendingScrollTo;
      (_this$pendingScrollTo = this.pendingScrollToIndexCallback) == null ? void 0 : _this$pendingScrollTo.call(this);
      const scrollElement = this.options.getScrollElement();
      if (this.scrollElement !== scrollElement) {
        this.cleanup();
        this.scrollElement = scrollElement;
        this._scrollToOffset(this.scrollOffset, {
          adjustments: undefined,
          behavior: undefined,
          sync: true
        });
        this.unsubs.push(this.options.observeElementRect(this, rect => {
          this.scrollRect = rect;
          this.calculateRange();
        }));
        this.unsubs.push(this.options.observeElementOffset(this, offset => {
          if (this.isScrollingTimeoutId !== null) {
            clearTimeout(this.isScrollingTimeoutId);
            this.isScrollingTimeoutId = null;
          }
          if (this.scrollOffset !== offset) {
            this.scrollOffset = offset;
            this.isScrolling = true;
            this.scrollAdjustments = 0;
            this.isScrollingTimeoutId = setTimeout(() => {
              this.isScrollingTimeoutId = null;
              this.isScrolling = false;
              this.notify();
            }, this.options.scrollingDelay);
          } else {
            this.isScrolling = false;
            this.scrollAdjustments = 0;
          }
          this.calculateRange();
        }));
      } else if (!this.isScrolling) {
        this.calculateRange();
      }
    };
    this.getSize = () => {
      return this.scrollRect[this.options.horizontal ? 'width' : 'height'];
    };
    this.getMeasurements = memo(() => [this.options.count, this.options.paddingStart, this.options.getItemKey, this.itemMeasurementsCache], (count, paddingStart, getItemKey, measurementsCache) => {
      const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
      this.pendingMeasuredCacheIndexes = [];
      const measurements = this.measurementsCache.slice(0, min);
      for (let i = min; i < count; i++) {
        const key = getItemKey(i);
        const measuredSize = measurementsCache[key];
        const start = measurements[i - 1] ? measurements[i - 1].end : paddingStart;
        const size = typeof measuredSize === 'number' ? measuredSize : this.options.estimateSize(i);
        const end = start + size;
        measurements[i] = {
          index: i,
          start,
          size,
          end,
          key
        };
      }
      this.measurementsCache = measurements;
      return measurements;
    }, {
      key: process.env.NODE_ENV !== 'production' && 'getMeasurements',
      debug: () => this.options.debug
    });
    this.calculateRange = memo(() => [this.getMeasurements(), this.getSize(), this.scrollOffset], (measurements, outerSize, scrollOffset) => {
      const range = calculateRange({
        measurements,
        outerSize,
        scrollOffset
      });
      if (range.startIndex !== this.range.startIndex || range.endIndex !== this.range.endIndex) {
        this.range = range;
        this.notify();
      }
      return this.range;
    }, {
      key: process.env.NODE_ENV !== 'production' && 'calculateRange',
      debug: () => this.options.debug
    });
    this.getIndexes = memo(() => [this.options.rangeExtractor, this.range, this.options.overscan, this.options.count], (rangeExtractor, range, overscan, count) => {
      return rangeExtractor({
        ...range,
        overscan,
        count: count
      });
    }, {
      key: process.env.NODE_ENV !== 'production' && 'getIndexes',
      debug: () => this.options.debug
    });
    this.indexFromElement = node => {
      const attributeName = this.options.indexAttribute;
      const indexStr = node.getAttribute(attributeName);
      if (!indexStr) {
        console.warn(`Missing attribute name '${attributeName}={index}' on measured element.`);
        return -1;
      }
      return parseInt(indexStr, 10);
    };
    this._measureElement = (node, _sync) => {
      const index = this.indexFromElement(node);
      const item = this.measurementsCache[index];
      if (!item) {
        return;
      }
      const prevNode = this.measureElementCache[item.key];
      const ro = this.getResizeObserver();
      if (!node.isConnected) {
        if (prevNode) {
          ro == null ? void 0 : ro.unobserve(prevNode);
          delete this.measureElementCache[item.key];
        }
        return;
      }
      if (!prevNode || prevNode !== node) {
        if (prevNode) {
          ro == null ? void 0 : ro.unobserve(prevNode);
        }
        this.measureElementCache[item.key] = node;
        ro == null ? void 0 : ro.observe(node);
      }
      const measuredItemSize = this.options.measureElement(node, this);
      const itemSize = this.itemMeasurementsCache[item.key] ?? item.size;
      const delta = measuredItemSize - itemSize;
      if (delta !== 0) {
        if (item.start < this.scrollOffset && this.isScrolling) {
          if (process.env.NODE_ENV !== 'production' && this.options.debug) {
            console.info('correction', delta);
          }
          this._scrollToOffset(this.scrollOffset, {
            adjustments: this.scrollAdjustments += delta,
            behavior: undefined,
            sync: false
          });
        }
        this.pendingMeasuredCacheIndexes.push(index);
        this.itemMeasurementsCache = {
          ...this.itemMeasurementsCache,
          [item.key]: measuredItemSize
        };
        this.notify();
      }
    };
    this.measureElement = node => {
      if (!node) {
        return;
      }
      this._measureElement(node, true);
    };
    this.getVirtualItems = memo(() => [this.getIndexes(), this.getMeasurements()], (indexes, measurements) => {
      const virtualItems = [];
      for (let k = 0, len = indexes.length; k < len; k++) {
        const i = indexes[k];
        const measurement = measurements[i];
        virtualItems.push(measurement);
      }
      return virtualItems;
    }, {
      key: process.env.NODE_ENV !== 'production' && 'getIndexes',
      debug: () => this.options.debug
    });
    this.scrollToOffset = function (toOffset, _temp) {
      let {
        align = 'start',
        behavior
      } = _temp === void 0 ? {} : _temp;
      const offset = _this.scrollOffset;
      const size = _this.getSize();
      if (align === 'auto') {
        if (toOffset <= offset) {
          align = 'start';
        } else if (toOffset >= offset + size) {
          align = 'end';
        } else {
          align = 'start';
        }
      }
      const options = {
        adjustments: undefined,
        behavior,
        sync: false
      };
      if (align === 'start') {
        _this._scrollToOffset(toOffset, options);
      } else if (align === 'end') {
        _this._scrollToOffset(toOffset - size, options);
      } else if (align === 'center') {
        _this._scrollToOffset(toOffset - size / 2, options);
      }
    };
    this.scrollToIndex = function (index, _temp2) {
      let {
        align = 'auto',
        ...rest
      } = _temp2 === void 0 ? {} : _temp2;
      _this.pendingScrollToIndexCallback = null;
      const measurements = _this.getMeasurements();
      const offset = _this.scrollOffset;
      const size = _this.getSize();
      const {
        count
      } = _this.options;
      const measurement = measurements[Math.max(0, Math.min(index, count - 1))];
      if (!measurement) {
        return;
      }
      if (align === 'auto') {
        if (measurement.end >= offset + size - _this.options.scrollPaddingEnd) {
          align = 'end';
        } else if (measurement.start <= offset + _this.options.scrollPaddingStart) {
          align = 'start';
        } else {
          return;
        }
      }
      const toOffset = align === 'end' ? measurement.end + _this.options.scrollPaddingEnd : measurement.start - _this.options.scrollPaddingStart;
      _this.scrollToOffset(toOffset, {
        align,
        ...rest
      });
      const isDynamic = Object.keys(_this.measureElementCache).length > 0;
      if (isDynamic) {
        const didSeen = () => typeof _this.itemMeasurementsCache[_this.options.getItemKey(index)] === 'number';
        if (!didSeen()) {
          _this.pendingScrollToIndexCallback = () => {
            if (didSeen()) {
              _this.pendingScrollToIndexCallback = null;
              _this.scrollToIndex(index, {
                align,
                ...rest
              });
            }
          };
        }
      }
    };
    this.getTotalSize = () => {
      var _this$getMeasurements;
      return (((_this$getMeasurements = this.getMeasurements()[this.options.count - 1]) == null ? void 0 : _this$getMeasurements.end) || this.options.paddingStart) + this.options.paddingEnd;
    };
    this._scrollToOffset = (offset, _ref4) => {
      let {
        adjustments,
        behavior,
        sync
      } = _ref4;
      this.options.scrollToFn(offset, {
        behavior,
        sync,
        adjustments
      }, this);
    };
    this.measure = () => {
      this.itemMeasurementsCache = {};
      this.notify();
    };
    this.setOptions(_opts);
    this.scrollRect = this.options.initialRect;
    this.scrollOffset = this.options.initialOffset;
    this.calculateRange();
  }
}
const findNearestBinarySearch = (low, high, getCurrentValue, value) => {
  while (low <= high) {
    const middle = (low + high) / 2 | 0;
    const currentValue = getCurrentValue(middle);
    if (currentValue < value) {
      low = middle + 1;
    } else if (currentValue > value) {
      high = middle - 1;
    } else {
      return middle;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
function calculateRange(_ref5) {
  let {
    measurements,
    outerSize,
    scrollOffset
  } = _ref5;
  const count = measurements.length - 1;
  const getOffset = index => measurements[index].start;
  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);
  let endIndex = startIndex;
  while (endIndex < count && measurements[endIndex].end < scrollOffset + outerSize) {
    endIndex++;
  }
  return {
    startIndex,
    endIndex
  };
}

export { Virtualizer, defaultKeyExtractor, defaultRangeExtractor, elementScroll, measureElement, observeElementOffset, observeElementRect, observeWindowOffset, observeWindowRect, windowScroll };
//# sourceMappingURL=index.mjs.map
