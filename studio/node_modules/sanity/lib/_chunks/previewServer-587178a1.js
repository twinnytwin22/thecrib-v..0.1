'use strict';

var path = require('path');
var fs = require('fs/promises');
var fs$1 = require('fs');
var vite = require('vite');
var readPkgUp = require('read-pkg-up');
var runtime = require('./runtime-87e16971.js');
var chalk = require('chalk');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
var path__default = /*#__PURE__*/_interopDefaultCompat(path);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var fs__default$1 = /*#__PURE__*/_interopDefaultCompat(fs$1);
var readPkgUp__default = /*#__PURE__*/_interopDefaultCompat(readPkgUp);
var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
const debug$1 = runtime.debug.extend("static");
async function buildStaticFiles(options) {
  const {
    cwd,
    outputDir,
    sourceMap = false,
    minify = true,
    basePath,
    vite: extendViteConfig
  } = options;
  debug$1("Writing Sanity runtime files");
  await runtime.writeSanityRuntime({
    cwd,
    reactStrictMode: false,
    watch: false
  });
  debug$1("Resolving vite config");
  let viteConfig = await runtime.getViteConfig({
    cwd,
    basePath,
    outputDir,
    minify,
    sourceMap,
    mode: "production"
  });
  if (extendViteConfig) {
    debug$1("Extending vite config with user-specified config");
    viteConfig = runtime.finalizeViteConfig(extendViteConfig(viteConfig));
  }
  debug$1("Copying static files from /static to output dir");
  const staticPath = path__default.default.join(outputDir, "static");
  await copyDir(path__default.default.join(cwd, "static"), staticPath);
  debug$1("Writing favicons to output dir");
  const faviconBasePath = "".concat(basePath.replace(/\/+$/, ""), "/static");
  await writeFavicons(faviconBasePath, staticPath);
  debug$1("Bundling using vite");
  const bundle = await vite.build(viteConfig);
  debug$1("Bundling complete");
  if (Array.isArray(bundle) || !("output" in bundle)) {
    return {
      chunks: []
    };
  }
  const stats = [];
  bundle.output.forEach(chunk => {
    if (chunk.type !== "chunk") {
      return;
    }
    stats.push({
      name: chunk.name,
      modules: Object.entries(chunk.modules).map(_ref => {
        let [rawFilePath, chunkModule] = _ref;
        const filePath = rawFilePath.startsWith("\0") ? rawFilePath.slice("\0".length) : rawFilePath;
        return {
          name: path__default.default.isAbsolute(filePath) ? path__default.default.relative(cwd, filePath) : filePath,
          originalLength: chunkModule.originalLength,
          renderedLength: chunkModule.renderedLength
        };
      })
    });
  });
  return {
    chunks: stats
  };
}
async function copyDir(srcDir, destDir, skipExisting) {
  await fs__default.default.mkdir(destDir, {
    recursive: true
  });
  for (const file of await tryReadDir(srcDir)) {
    const srcFile = path__default.default.resolve(srcDir, file);
    if (srcFile === destDir) {
      continue;
    }
    const destFile = path__default.default.resolve(destDir, file);
    const stat = await fs__default.default.stat(srcFile);
    if (stat.isDirectory()) {
      await copyDir(srcFile, destFile, skipExisting);
    } else if (skipExisting) {
      await fs__default.default.copyFile(srcFile, destFile, fs$1.constants.COPYFILE_EXCL).catch(skipIfExistsError);
    } else {
      await fs__default.default.copyFile(srcFile, destFile);
    }
  }
}
async function tryReadDir(dir) {
  try {
    const content = await fs__default.default.readdir(dir);
    return content;
  } catch (err) {
    if (err.code === "ENOENT") {
      return [];
    }
    throw err;
  }
}
function skipIfExistsError(err) {
  if (err.code === "EEXIST") {
    return;
  }
  throw err;
}
async function writeFavicons(basePath, destDir) {
  var _a;
  const sanityPkgPath = (_a = await readPkgUp__default.default({
    cwd: __dirname
  })) == null ? void 0 : _a.path;
  const faviconsPath = sanityPkgPath ? path__default.default.join(path__default.default.dirname(sanityPkgPath), "static", "favicons") : void 0;
  if (!faviconsPath) {
    throw new Error("Unable to resolve `sanity` module root");
  }
  await fs__default.default.mkdir(destDir, {
    recursive: true
  });
  await copyDir(faviconsPath, destDir, true);
  await writeWebManifest(basePath, destDir);
}
async function writeWebManifest(basePath, destDir) {
  const content = JSON.stringify(runtime.generateWebManifest(basePath), null, 2);
  await fs__default.default.writeFile(path__default.default.join(destDir, "manifest.webmanifest"), content, "utf8").catch(skipIfExistsError);
}
const debug = runtime.debug.extend("preview");
async function startPreviewServer(options) {
  const {
    httpPort,
    httpHost,
    basePath: base,
    root
  } = options;
  const startTime = Date.now();
  if (!fs__default$1.default.existsSync(path__default.default.join(root, "index.html"))) {
    const err = new Error("Could not find a production build in the '".concat(root, "' directory. Try building your studio app with 'sanity build' before starting the preview server."));
    err.name = "BUILD_NOT_FOUND";
    throw err;
  }
  const previewConfig = {
    root,
    base: base || "/",
    configFile: false,
    preview: {
      port: httpPort,
      host: httpHost,
      strictPort: true
    },
    // Needed for vite to not serve `root/dist`
    build: {
      outDir: root
    }
  };
  debug("Creating vite server");
  const server = await vite.preview(previewConfig);
  const info = server.config.logger.info;
  const url = server.resolvedUrls.local[0];
  const startupDuration = Date.now() - startTime;
  info("Sanity Studio using ".concat(chalk__default.default.cyan("vite@".concat(require("vite/package.json").version)), " ready in ").concat(chalk__default.default.cyan("".concat(Math.ceil(startupDuration), "ms")), " and running at ").concat(chalk__default.default.cyan(url), " (production preview mode)"));
  return {
    urls: server.resolvedUrls,
    close: () => new Promise((resolve, reject) => server.httpServer.close(err => err ? reject(err) : resolve()))
  };
}
exports.buildStaticFiles = buildStaticFiles;
exports.startPreviewServer = startPreviewServer;
//# sourceMappingURL=previewServer-587178a1.js.map
