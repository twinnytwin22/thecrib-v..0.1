import path from 'path';
import fs from 'fs/promises';
import fs$1, { constants } from 'fs';
import { build, preview } from 'vite';
import readPkgUp from 'read-pkg-up';
import { debug as debug$2, writeSanityRuntime, getViteConfig, finalizeViteConfig, generateWebManifest } from './runtime-061fef02.js';
import chalk from 'chalk';
const debug$1 = debug$2.extend("static");
async function buildStaticFiles(options) {
  const {
    cwd,
    outputDir,
    sourceMap = false,
    minify = true,
    basePath,
    vite: extendViteConfig
  } = options;
  debug$1("Writing Sanity runtime files");
  await writeSanityRuntime({
    cwd,
    reactStrictMode: false,
    watch: false
  });
  debug$1("Resolving vite config");
  let viteConfig = await getViteConfig({
    cwd,
    basePath,
    outputDir,
    minify,
    sourceMap,
    mode: "production"
  });
  if (extendViteConfig) {
    debug$1("Extending vite config with user-specified config");
    viteConfig = finalizeViteConfig(extendViteConfig(viteConfig));
  }
  debug$1("Copying static files from /static to output dir");
  const staticPath = path.join(outputDir, "static");
  await copyDir(path.join(cwd, "static"), staticPath);
  debug$1("Writing favicons to output dir");
  const faviconBasePath = "".concat(basePath.replace(/\/+$/, ""), "/static");
  await writeFavicons(faviconBasePath, staticPath);
  debug$1("Bundling using vite");
  const bundle = await build(viteConfig);
  debug$1("Bundling complete");
  if (Array.isArray(bundle) || !("output" in bundle)) {
    return {
      chunks: []
    };
  }
  const stats = [];
  bundle.output.forEach(chunk => {
    if (chunk.type !== "chunk") {
      return;
    }
    stats.push({
      name: chunk.name,
      modules: Object.entries(chunk.modules).map(_ref => {
        let [rawFilePath, chunkModule] = _ref;
        const filePath = rawFilePath.startsWith("\0") ? rawFilePath.slice("\0".length) : rawFilePath;
        return {
          name: path.isAbsolute(filePath) ? path.relative(cwd, filePath) : filePath,
          originalLength: chunkModule.originalLength,
          renderedLength: chunkModule.renderedLength
        };
      })
    });
  });
  return {
    chunks: stats
  };
}
async function copyDir(srcDir, destDir, skipExisting) {
  await fs.mkdir(destDir, {
    recursive: true
  });
  for (const file of await tryReadDir(srcDir)) {
    const srcFile = path.resolve(srcDir, file);
    if (srcFile === destDir) {
      continue;
    }
    const destFile = path.resolve(destDir, file);
    const stat = await fs.stat(srcFile);
    if (stat.isDirectory()) {
      await copyDir(srcFile, destFile, skipExisting);
    } else if (skipExisting) {
      await fs.copyFile(srcFile, destFile, constants.COPYFILE_EXCL).catch(skipIfExistsError);
    } else {
      await fs.copyFile(srcFile, destFile);
    }
  }
}
async function tryReadDir(dir) {
  try {
    const content = await fs.readdir(dir);
    return content;
  } catch (err) {
    if (err.code === "ENOENT") {
      return [];
    }
    throw err;
  }
}
function skipIfExistsError(err) {
  if (err.code === "EEXIST") {
    return;
  }
  throw err;
}
async function writeFavicons(basePath, destDir) {
  var _a;
  const sanityPkgPath = (_a = await readPkgUp({
    cwd: __dirname
  })) == null ? void 0 : _a.path;
  const faviconsPath = sanityPkgPath ? path.join(path.dirname(sanityPkgPath), "static", "favicons") : void 0;
  if (!faviconsPath) {
    throw new Error("Unable to resolve `sanity` module root");
  }
  await fs.mkdir(destDir, {
    recursive: true
  });
  await copyDir(faviconsPath, destDir, true);
  await writeWebManifest(basePath, destDir);
}
async function writeWebManifest(basePath, destDir) {
  const content = JSON.stringify(generateWebManifest(basePath), null, 2);
  await fs.writeFile(path.join(destDir, "manifest.webmanifest"), content, "utf8").catch(skipIfExistsError);
}
const debug = debug$2.extend("preview");
async function startPreviewServer(options) {
  const {
    httpPort,
    httpHost,
    basePath: base,
    root
  } = options;
  const startTime = Date.now();
  if (!fs$1.existsSync(path.join(root, "index.html"))) {
    const err = new Error("Could not find a production build in the '".concat(root, "' directory. Try building your studio app with 'sanity build' before starting the preview server."));
    err.name = "BUILD_NOT_FOUND";
    throw err;
  }
  const previewConfig = {
    root,
    base: base || "/",
    configFile: false,
    preview: {
      port: httpPort,
      host: httpHost,
      strictPort: true
    },
    // Needed for vite to not serve `root/dist`
    build: {
      outDir: root
    }
  };
  debug("Creating vite server");
  const server = await preview(previewConfig);
  const info = server.config.logger.info;
  const url = server.resolvedUrls.local[0];
  const startupDuration = Date.now() - startTime;
  info("Sanity Studio using ".concat(chalk.cyan("vite@".concat(require("vite/package.json").version)), " ready in ").concat(chalk.cyan("".concat(Math.ceil(startupDuration), "ms")), " and running at ").concat(chalk.cyan(url), " (production preview mode)"));
  return {
    urls: server.resolvedUrls,
    close: () => new Promise((resolve, reject) => server.httpServer.close(err => err ? reject(err) : resolve()))
  };
}
export { buildStaticFiles, startPreviewServer };
//# sourceMappingURL=previewServer-c358d590.js.map
