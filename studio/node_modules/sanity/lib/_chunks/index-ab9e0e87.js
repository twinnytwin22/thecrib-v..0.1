'use strict';

var jsxRuntime = require('react/jsx-runtime');
var React = require('react');
var ui = require('@sanity/ui');
var shallowEquals = require('shallow-equals');
var icons = require('@sanity/icons');
require('sanity/router');
var desk = require('./desk-fb576030.js');
var index = require('./index-8d36f50b.js');
var PathUtils = require('@sanity/util/paths');
var types = require('@sanity/types');
var sanity = require('sanity');
var PaneItem = require('./PaneItem-fa040ebd.js');
require('lodash/omit.js');
require('lodash/isNumber.js');
require('lodash/isString.js');
require('react-rx');
var rxjs = require('rxjs');
var operators = require('rxjs/operators');
var deepCompare = require('react-fast-compare');
function _interopDefaultCompat(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    default: e
  };
}
function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}
var shallowEquals__default = /*#__PURE__*/_interopDefaultCompat(shallowEquals);
var PathUtils__namespace = /*#__PURE__*/_interopNamespaceCompat(PathUtils);
var deepCompare__default = /*#__PURE__*/_interopDefaultCompat(deepCompare);
const PARTIAL_PAGE_LIMIT = 100;
const FULL_LIST_LIMIT = 2e3;
const DEFAULT_ORDERING = {
  by: [{
    field: "_updatedAt",
    direction: "desc"
  }]
};
const EMPTY_RECORD = {};
function getDocumentKey(value, index) {
  return value._id ? sanity.getPublishedId(value._id) : "item-".concat(index);
}
function removePublishedWithDrafts(documents) {
  return sanity.collate(documents).map(entry => {
    const doc = entry.draft || entry.published;
    return {
      ...doc,
      hasPublished: !!entry.published,
      hasDraft: !!entry.draft
    };
  });
}
const RE_TYPE_NAME_IN_FILTER = /\b_type\s*==\s*(['"].*?['"]|\$.*?(?:\s|$))|\B(['"].*?['"]|\$.*?(?:\s|$))\s*==\s*_type\b/;
function getTypeNameFromSingleTypeFilter(filter) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const matches = filter.match(RE_TYPE_NAME_IN_FILTER);
  if (!matches) {
    return null;
  }
  const match = (matches[1] || matches[2]).trim().replace(/^["']|["']$/g, "");
  if (match[0] === "$") {
    const k = match.slice(1);
    const v = params[k];
    return typeof v === "string" ? v : null;
  }
  return match;
}
function isSimpleTypeFilter(filter) {
  return /^_type\s*==\s*['"$]\w+['"]?\s*$/.test(filter.trim());
}
function toOrderClause(orderBy) {
  return orderBy.map(ordering => [wrapFieldWithFn(ordering), (ordering.direction || "").toLowerCase()].map(str => str.trim()).filter(Boolean).join(" ")).join(",");
}
function wrapFieldWithFn(ordering) {
  return ordering.mapWith ? "".concat(ordering.mapWith, "(").concat(ordering.field, ")") : ordering.field;
}
function applyOrderingFunctions(order, schemaType) {
  const orderBy = order.by.map(by => {
    if (by.mapWith) {
      return by;
    }
    const fieldType = tryResolveSchemaTypeForPath(schemaType, by.field);
    if (!fieldType) {
      return by;
    }
    if (fieldExtendsType(fieldType, "datetime")) {
      return {
        ...by,
        mapWith: "dateTime"
      };
    }
    if (fieldType.jsonType === "string") {
      return {
        ...by,
        mapWith: "lower"
      };
    }
    return by;
  });
  return orderBy.every((item, index) => item === order.by[index]) ? order : {
    ...order,
    by: orderBy
  };
}
function tryResolveSchemaTypeForPath(baseType, path) {
  const pathSegments = PathUtils__namespace.fromString(path);
  let current = baseType;
  for (const segment of pathSegments) {
    if (!current) {
      return void 0;
    }
    if (typeof segment === "string") {
      current = getFieldTypeByName(current, segment);
      continue;
    }
    const isArrayAccessor = types.isKeySegment(segment) || types.isIndexSegment(segment);
    if (!isArrayAccessor || current.jsonType !== "array") {
      return void 0;
    }
    const [memberType, otherType] = current.of || [];
    if (otherType || !memberType) {
      return void 0;
    }
    if (!types.isReferenceSchemaType(memberType)) {
      current = memberType;
      continue;
    }
    const [refType, otherRefType] = memberType.to || [];
    if (otherRefType || !refType) {
      return void 0;
    }
    current = refType;
  }
  return current;
}
function getFieldTypeByName(type, fieldName) {
  if (!("fields" in type)) {
    return void 0;
  }
  const fieldType = type.fields.find(field => field.name === fieldName);
  return fieldType ? fieldType.type : void 0;
}
function fieldExtendsType(field, ofType) {
  let current = field.type;
  while (current) {
    if (current.name === ofType) {
      return true;
    }
    if (!current.type && current.jsonType === ofType) {
      return true;
    }
    current = current.type;
  }
  return false;
}
function DocumentListPaneContent(props) {
  const {
    childItemId,
    error,
    filterIsSimpleTypeContraint,
    fullList,
    isActive,
    isLoading,
    items,
    layout,
    onListChange,
    onRetry,
    showIcons
  } = props;
  const schema = sanity.useSchema();
  const {
    collapsed: layoutCollapsed
  } = desk.usePaneLayout();
  const {
    collapsed,
    index: index$1
  } = desk.usePane();
  const [shouldRender, setShouldRender] = React.useState(false);
  React.useEffect(() => {
    if (collapsed) return void 0;
    const timer = setTimeout(() => {
      setShouldRender(true);
    }, 0);
    return () => {
      clearTimeout(timer);
    };
  }, [collapsed]);
  const renderItem = React.useCallback(item => {
    const publishedId = sanity.getPublishedId(item._id);
    const isSelected = childItemId === publishedId;
    const pressed = !isActive && isSelected;
    const selected = isActive && isSelected;
    return /* @__PURE__ */jsxRuntime.jsx(PaneItem.PaneItem, {
      icon: showIcons === false ? false : void 0,
      id: publishedId,
      pressed,
      selected,
      layout,
      schemaType: schema.get(item._type),
      value: item
    });
  }, [childItemId, isActive, layout, schema, showIcons]);
  const content = React.useMemo(() => {
    if (!shouldRender) {
      return null;
    }
    if (error) {
      return /* @__PURE__ */jsxRuntime.jsx(ui.Flex, {
        align: "center",
        direction: "column",
        height: "fill",
        justify: "center",
        children: /* @__PURE__ */jsxRuntime.jsx(ui.Container, {
          width: 1,
          children: /* @__PURE__ */jsxRuntime.jsxs(ui.Stack, {
            paddingX: 4,
            paddingY: 5,
            space: 4,
            children: [/* @__PURE__ */jsxRuntime.jsx(ui.Heading, {
              as: "h3",
              children: "Could not fetch list items"
            }), /* @__PURE__ */jsxRuntime.jsxs(ui.Text, {
              as: "p",
              children: ["Error: ", /* @__PURE__ */jsxRuntime.jsx("code", {
                children: error.message
              })]
            }), onRetry && /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
              children: /* @__PURE__ */jsxRuntime.jsx(ui.Button, {
                icon: icons.SyncIcon,
                onClick: onRetry,
                text: "Retry",
                tone: "primary"
              })
            })]
          })
        })
      });
    }
    if (items === null) {
      return /* @__PURE__ */jsxRuntime.jsx(ui.Flex, {
        align: "center",
        direction: "column",
        height: "fill",
        justify: "center",
        children: /* @__PURE__ */jsxRuntime.jsx(index.Delay, {
          ms: 300,
          children: /* @__PURE__ */jsxRuntime.jsxs(jsxRuntime.Fragment, {
            children: [/* @__PURE__ */jsxRuntime.jsx(ui.Spinner, {
              muted: true
            }), /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
              marginTop: 3,
              children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
                align: "center",
                muted: true,
                size: 1,
                children: "Loading documents\u2026"
              })
            })]
          })
        })
      });
    }
    if (!isLoading && items.length === 0) {
      return /* @__PURE__ */jsxRuntime.jsx(ui.Flex, {
        align: "center",
        direction: "column",
        height: "fill",
        justify: "center",
        children: /* @__PURE__ */jsxRuntime.jsx(ui.Container, {
          width: 1,
          children: /* @__PURE__ */jsxRuntime.jsx(ui.Box, {
            paddingX: 4,
            paddingY: 5,
            children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
              align: "center",
              muted: true,
              size: 2,
              children: filterIsSimpleTypeContraint ? "No documents of this type" : "No matching documents"
            })
          })
        })
      });
    }
    const hasMoreItems = fullList && items.length === FULL_LIST_LIMIT;
    return /* @__PURE__ */jsxRuntime.jsxs(ui.Box, {
      padding: 2,
      children: [items.length > 0 && /* @__PURE__ */jsxRuntime.jsx(ui.VirtualList, {
        gap: 1,
        getItemKey: getDocumentKey,
        items,
        renderItem,
        onChange: onListChange
      }, "".concat(index$1, "-").concat(collapsed)), isLoading && /* @__PURE__ */jsxRuntime.jsx(ui.Card, {
        borderTop: true,
        marginTop: 1,
        paddingX: 3,
        paddingY: 4,
        children: /* @__PURE__ */jsxRuntime.jsx(ui.Text, {
          align: "center",
          muted: true,
          size: 1,
          children: "Loading\u2026"
        })
      }), hasMoreItems && /* @__PURE__ */jsxRuntime.jsx(ui.Card, {
        marginTop: 1,
        paddingX: 3,
        paddingY: 4,
        radius: 2,
        tone: "transparent",
        children: /* @__PURE__ */jsxRuntime.jsxs(ui.Text, {
          align: "center",
          muted: true,
          size: 1,
          children: ["Displaying a maximum of ", FULL_LIST_LIMIT, " documents"]
        })
      })]
    });
  }, [error, filterIsSimpleTypeContraint, fullList, onListChange, isLoading, items, onRetry, renderItem, shouldRender, collapsed, index$1]);
  return /* @__PURE__ */jsxRuntime.jsx(desk.PaneContent, {
    overflow: layoutCollapsed ? void 0 : "auto",
    children: content
  });
}
const DocumentListPaneHeader = React.memo(_ref => {
  let {
    index: index$1,
    initialValueTemplates = [],
    menuItems = [],
    menuItemGroups = [],
    setLayout,
    setSortOrder,
    title
  } = _ref;
  const {
    features
  } = index.useDeskTool();
  const actionHandlers = React.useMemo(() => {
    return {
      setLayout: _ref2 => {
        let {
          layout: value
        } = _ref2;
        setLayout(value);
      },
      setSortOrder: sort => {
        setSortOrder(sort);
      }
    };
  }, [setLayout, setSortOrder]);
  return /* @__PURE__ */jsxRuntime.jsx(desk.PaneHeader, {
    backButton: features.backButton && index$1 > 0 && /* @__PURE__ */jsxRuntime.jsx(ui.Button, {
      as: desk.BackLink,
      "data-as": "a",
      icon: icons.ArrowLeftIcon,
      mode: "bleed"
    }),
    title,
    actions: /* @__PURE__ */jsxRuntime.jsx(desk.PaneHeaderActions, {
      initialValueTemplateItems: initialValueTemplates,
      actionHandlers,
      menuItemGroups,
      menuItems
    })
  });
});
DocumentListPaneHeader.displayName = "DocumentListPaneHeader";
const INITIAL_CHILD_PROPS = {
  result: null,
  error: false
};
const createResultChildProps = documents => ({
  result: {
    documents
  },
  loading: false,
  error: false
});
const createErrorChildProps = error => ({
  result: null,
  loading: false,
  error
});
const getQueryResults = function (receivedProps$) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const onRetry$ = new rxjs.Subject();
  const onRetry = onRetry$.next.bind(onRetry$);
  const queryProps$ = receivedProps$.pipe(operators.map(props => ({
    client: props.client,
    query: props.query,
    params: props.params
  })), operators.distinctUntilChanged(deepCompare__default.default), operators.publishReplay(1), operators.refCount());
  const queryResults$ = queryProps$.pipe(operators.switchMap(queryProps => {
    const query$ = sanity.listenQuery(queryProps.client, queryProps.query, queryProps.params, options).pipe(operators.map(createResultChildProps), operators.share());
    return rxjs.merge(rxjs.of({
      loading: true
    }).pipe(operators.delay(400), operators.takeUntil(query$)), query$);
  }));
  return queryResults$.pipe(operators.startWith(INITIAL_CHILD_PROPS), operators.catchError((err, caught$) => rxjs.concat(rxjs.of(createErrorChildProps(err)), rxjs.merge(rxjs.fromEvent(window, "online"), onRetry$).pipe(operators.take(1), operators.mergeMapTo(caught$)))), operators.scan((prev, next) => ({
    ...prev,
    ...next,
    onRetry
  })));
};
function useDocumentList(opts) {
  var _a;
  const {
    apiVersion,
    filter,
    params,
    sortOrder
  } = opts;
  const client = sanity.useClient(sanity.DEFAULT_STUDIO_CLIENT_OPTIONS);
  const [fullList, setFullList] = React.useState(false);
  const fullListRef = React.useRef(fullList);
  const [result, setResult] = React.useState(null);
  const error = (result == null ? void 0 : result.error) || null;
  const isLoading = (result == null ? void 0 : result.loading) || result === null;
  const onRetry = result == null ? void 0 : result.onRetry;
  const documents = (_a = result == null ? void 0 : result.result) == null ? void 0 : _a.documents;
  const items = React.useMemo(() => documents ? removePublishedWithDrafts(documents) : null, [documents]);
  const query = React.useMemo(() => {
    const extendedProjection = sortOrder == null ? void 0 : sortOrder.extendedProjection;
    const projectionFields = ["_id", "_type"];
    const finalProjection = projectionFields.join(",");
    const sortBy = (sortOrder == null ? void 0 : sortOrder.by) || [];
    const limit = fullList ? FULL_LIST_LIMIT : PARTIAL_PAGE_LIMIT;
    const sort = sortBy.length > 0 ? sortBy : DEFAULT_ORDERING.by;
    const order = toOrderClause(sort);
    if (extendedProjection) {
      const firstProjection = projectionFields.concat(extendedProjection).join(",");
      return ["*[".concat(filter, "] {").concat(firstProjection, "}"), "order(".concat(order, ") [0...").concat(limit, "]"), "{".concat(finalProjection, "}")].join("|");
    }
    return "*[".concat(filter, "]|order(").concat(order, ")[0...").concat(limit, "]{").concat(finalProjection, "}");
  }, [filter, fullList, sortOrder]);
  const handleListChange = React.useCallback(_ref3 => {
    let {
      toIndex
    } = _ref3;
    if (isLoading || fullListRef.current) {
      return;
    }
    if (toIndex >= PARTIAL_PAGE_LIMIT / 2) {
      setFullList(true);
      fullListRef.current = true;
    }
  }, [isLoading]);
  React.useEffect(() => {
    const filterFn = fullList ? queryResult => Boolean(queryResult.result) : () => true;
    setResult(r => r ? {
      ...r,
      loading: true
    } : null);
    const queryResults$ = getQueryResults(rxjs.of({
      client,
      query,
      params
    }), {
      apiVersion,
      tag: "desk.document-list"
    }).pipe(operators.filter(filterFn));
    const sub = queryResults$.subscribe(setResult);
    return () => sub.unsubscribe();
  }, [apiVersion, client, fullList, query, params]);
  React.useEffect(() => {
    setResult(null);
    setFullList(false);
    fullListRef.current = false;
  }, [filter, params, sortOrder, apiVersion]);
  return {
    error,
    fullList,
    handleListChange,
    isLoading,
    items,
    onRetry
  };
}
const emptyArray = [];
function useShallowUnique(value) {
  const valueRef = React.useRef(value);
  if (!shallowEquals__default.default(valueRef.current, value)) {
    valueRef.current = value;
  }
  return valueRef.current;
}
const DocumentListPane = React.memo(function DocumentListPane2(props) {
  const {
    childItemId,
    index: index$1,
    isActive,
    isSelected,
    pane,
    paneKey
  } = props;
  const schema = sanity.useSchema();
  const {
    name: parentSourceName
  } = sanity.useSource();
  const {
    defaultLayout = "default",
    displayOptions,
    initialValueTemplates = emptyArray,
    menuItems,
    menuItemGroups,
    options,
    title
  } = pane;
  const {
    apiVersion,
    defaultOrdering = emptyArray,
    filter
  } = options;
  const params = useShallowUnique(options.params || EMPTY_RECORD);
  const sourceName = pane.source;
  const typeName = React.useMemo(() => getTypeNameFromSingleTypeFilter(filter, params), [filter, params]);
  const showIcons = (displayOptions == null ? void 0 : displayOptions.showIcons) !== false;
  const [layout, setLayout] = index.useDeskToolSetting(typeName, "layout", defaultLayout);
  const defaultSortOrder = React.useMemo(() => {
    return (defaultOrdering == null ? void 0 : defaultOrdering.length) > 0 ? {
      by: defaultOrdering
    } : DEFAULT_ORDERING;
  }, [defaultOrdering]);
  const [sortOrderRaw, setSortOrder] = index.useDeskToolSetting(typeName, "sortOrder", defaultSortOrder);
  const sortWithOrderingFn = typeName && sortOrderRaw ? applyOrderingFunctions(sortOrderRaw, schema.get(typeName)) : sortOrderRaw;
  const sortOrder = sanity.useUnique(sortWithOrderingFn);
  const filterIsSimpleTypeContraint = isSimpleTypeFilter(filter);
  const {
    error,
    fullList,
    handleListChange,
    isLoading,
    items,
    onRetry
  } = useDocumentList({
    filter,
    params,
    sortOrder,
    apiVersion
  });
  return /* @__PURE__ */jsxRuntime.jsx(sanity.SourceProvider, {
    name: sourceName || parentSourceName,
    children: /* @__PURE__ */jsxRuntime.jsxs(desk.Pane, {
      currentMaxWidth: 350,
      id: paneKey,
      maxWidth: 640,
      minWidth: 320,
      selected: isSelected,
      children: [desk._DEBUG, /* @__PURE__ */jsxRuntime.jsx(DocumentListPaneHeader, {
        index: index$1,
        initialValueTemplates,
        menuItems,
        menuItemGroups,
        setLayout,
        setSortOrder,
        title
      }), /* @__PURE__ */jsxRuntime.jsx(DocumentListPaneContent, {
        childItemId,
        error,
        filterIsSimpleTypeContraint,
        fullList,
        isActive,
        isLoading,
        items,
        layout,
        onListChange: handleListChange,
        onRetry,
        showIcons
      })]
    })
  });
});
exports.default = DocumentListPane;
//# sourceMappingURL=index-ab9e0e87.js.map
